<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 8ad0d94e1c87b2daabff88e74acc31e8a11eec0a Maintainer: aeoris Status: ready -->
<!-- Reviewed: no Maintainer: andresdzphp -->
<sect1 xml:id="language.types.string">
 <title>Cadenas</title>
 
 <!-- FIXME PHP_6 Likely unicode support will alter this -->
 <para>
  Un <type>string</type> es una serie de caracteres donde un caracter es
  lo mismo que un byte. Esto significa que PHP solo soporta el conjunto de 256 caracteres
  y por lo tanto no tiene soporte nativo Unicode. Ver
  <link linkend="language.types.string.details">detalles del tipo de dato
   string</link>.
 </para>
 
 <note>
  <simpara>
   <type>string</type> puede llegar a alcanzar 2GB de tamaño.
  </simpara>
 </note>
 
 <sect2 xml:id="language.types.string.syntax">
  <title>Sintaxis</title>
  
  <para>
   Un <type>string</type> literal puede ser especificado de cuatro formas diferentes:
  </para>
  
  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">comillas simples</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">comillas dobles</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">sintaxis heredoc</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">sintaxis nowdoc</link>
     (desde PHP 5.3.0)
    </simpara>
   </listitem>
  </itemizedlist>
  
  <sect3 xml:id="language.types.string.syntax.single">
   <title>Comillas simples</title>
   
   <para>
    La manera más sencilla de especificar un <type>string</type> es encerrarlo entre comillas
    simples (el caracter <literal>'</literal>).
   </para>
   
   <para>
    Para especificar una comilla simple literal, se escapa con una barra invertida
    (<literal>\</literal>). Para especificar una barra invertida literal, se duplica
    (<literal>\\</literal>). Todas las otras instancias de barras invertidas serán tratadas
    como una barra invertida literal: esto significa que otras secuencias de escape que
    se puedan utilizar, tales como <literal>\r</literal> or <literal>\n</literal>,
    serán mostradas literalmente como se especifican en lugar de tener cualquier significado
    especial
   </para>
   
   <note>
    <simpara>
     A diferencia de las sintaxis de <link linkend="language.types.string.syntax.double">comillas dobles</link>
     y <link linkend="language.types.string.syntax.heredoc">heredoc</link>, las
     <link linkend="language.variables">variables</link> y las sentencias de escape
     para caracteres especiales <emphasis>no</emphasis> se expandirán cuando estén
     incluidas dentro de un <type>string</type> con comillas simples.
    </simpara>
   </note>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'Esto es una cadena sencilla';

echo 'Tambien puede incluir nuevas líneas en
cadenas de esta forma ya que es
correcto hacerlo así';

// Resultado: Arnold una vez dijo: "I'll be back"
echo 'Arnold una vez dijo: "I\'ll be back"';

// Resultado: Ha borrado C:\*.*?
echo 'Ha borrado C:\\*.*?';

// Resultado: Ha borrado C:\*.*?
echo 'Ha borrado C:\*.*?';

// Resultado: Esto no se expandirá: \n una nueva línea
echo 'Esto no se expandirá: \n una nueva línea';

// Resultado: Las variables $tampoco se $expandiran
echo 'Las variables $tampoco se $expandiran';
?>
]]>
    </programlisting>
   </informalexample>
   
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.double">
   <title>Comillas dobles</title>
   
   <para>
    Si un <type>string</type> está encerrado entre comillas dobles ("), PHP
    interpretará más sentencias de escape como caracteres especiales:
   </para>
   
   <table>
    <title>Caracteres escapados</title>
    
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sentencia</entry>
       <entry>Significado</entry>
      </row>
     </thead>
     
     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>avance de línea (LF o 0x0A (10) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>retorno de carro (CR o 0x0D (13) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>tabulador horizontal (HT o 0x09 (9) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>tabulador vertical (VT o 0x0B (11) en ASCII) (desde PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>escape (ESC o 0x1B (27) en ASCII) (desde PHP 5.4.0)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>avance de página (FF o 0x0C (12) en ASCII) (desde PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>barra invertida</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>signo del dólar</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>comillas dobles</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        la secuencia de caracteres que coincida con la expresión regular
        es un caracter en notación octal
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        la secuencia de caracteres que coincida con la expresión regular
        es un caracter en notación hexadecimal
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
   <para>
    Al igual que en la delimitación de un <type>string</type> mediante
    comillas simples, escapar cualquier otro caracter puede dar lugar
    a que se muestre tambien la barra invertida. Antes de PHP 5.1.1,
    la barra invertida en <literal>\{$var}</literal> no se mostraba.
   </para>
   
   <para>
    La característica más importante de entrecomillar un <type>string</type>
    mediante comillas dobles es el hecho que los nombres de las variables
    son expandidas. Consulte <link linkend="language.types.string.parsing">string parsing</link>
    para más detalles.
   </para>
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>
   
   <simpara>
    Una tercera forma de delimitar un <type>string</type> es mediante la sintaxis heredoc:
    <literal>&lt;&lt;&lt;</literal>. Después de este operador, se deberá ofrecer un
    identificador y después una nueva línea. A continuación va el propio <type>string</type>,
    y para cerrar la notación se pone el mismo identificador.
   </simpara>
   
   <simpara>
    El identificador de cierre <emphasis>debe</emphasis> empezar en la primera columna
    de la nueva línea. Asimismo, el identificador debe seguir las mismas reglas de
    nomenclatura de las etiquetas en PHP: debe contener solo caracteres alfanuméricos y
    guiones bajos, y debe empezar con un caracter alfabético o un guión bajo.
   </simpara>
   
   <warning>
    <simpara>
     Es muy importante señalar que la línea con el identificador de cierre no debe contener
     ningún caracter, excepto <emphasis>posiblemente</emphasis> un
     punto y coma (<literal>;</literal>). Esto significa en particular que el identificador
     <emphasis>no debe usar sangría</emphasis>, y que no deben existir ningún espacio
     ni tabulación antes o después del punto y coma. Es muy importante darse cuenta que
     el primer caracter antes del identificador de cierre debe ser un salto de línea
     definida por el sistema operativo local. En los sistemas UNIX sería <literal>\n</literal>,
     al igual que en Mac OS X. El delimitador de cierre (posiblemente seguido de un
     punto y coma) también debe ser seguido de un salto de línea.
    </simpara>
    
    <simpara>
     Si se rompe esta regla y el identificador de cierre no está "limpio", no será
     considerado como un identificador de cierre, y PHP continuará buscando uno. Si no se
     encuentra ningún identificador de cierre antes del final del fichero, se
     producirá un error de análisis en la última línea.
    </simpara>
    
    <para>
     Tampoco se puede emplear Heredocs para inicializar las propiedades de una clase.
     Desde PHP 5.3, esta limitación solo concierne a los heredocs que contengan variables.
    </para>
    
    <example>
     <title>Ejemplo no válido</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>
   
   <para>
    El texto heredoc se comporta como un <type>string</type> entre comillas dobles,
    pero sin tener comillas dobles. Esto significa que las comillas en Heredoc no
    necesitan ser escapadas, pero los caracteres escapados indicados arriba se pueden
    seguir empleando. Las variables son expandidas, y se debe tener el mismo cuidado dentro
    de un Heredoc cuando se quieren expresar variables complejas, al igual que en
    los <type>string</type>.
   </para>
   
   <example>
    <title>Ejemplo de entrecomillado de string Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Ejemplo de una cadena
expandida en varias líneas
empleando la sintaxis heredoc.
EOD;

/* Un ejemplo más complejo con variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MiNombre';

echo <<<EOT
Mi nombre es "$name". Estoy escribiendo un poco de $foo->foo.
Ahora, estoy escribiendo un poco de {$foo->bar[1]}.
Esto debe mostrar una 'A' mayúscula: \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mi nombre es "MiNombre". Estoy escribiendo un poco de Foo.
Ahora, estoy escribiendo un poco de Bar2.
Esto debe mostrar una 'A' mayúscula: A]]>
    </screen>
   </example>
   
   <para>
    Tambien se puede emplear la sintaxis Heredoc para pasar datos como
    argumento de una función:
   </para>
   
   <example>
    <title>Ejemplo de Heredoc como argumento</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>
   
   <para>
    Desde PHP 5.3.0 es posible inicializar variables estáticas y propiedades/constantes
    de clase mediante la sintaxis Heredoc:
   </para>
   
   <example>
    <title>Usando Heredoc para inicializar valores estáticos</title>
    <programlisting role="php">
<![CDATA[
<?php
// Variables estáticas
function foo()
{
    static $bar = <<<LABEL
Nada aqui dentro...
LABEL;
}

// Propiedades/Constantes de clase
class foo
{
    const BAR = <<<FOOBAR
Ejemplo de constante
FOOBAR;

    public $baz = <<<FOOBAR
Ejemplo de propiedad
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>
   
   <para>
    PHP 5.3.0 tambien introdujo la posibilidad en Heredoc de emplear las comillas
    dobles en declaraciones:
   </para>
   
   <example>
    <title>Empleando comillas dobles en Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Hola Mundo!
FOOBAR;
?>
]]>
    </programlisting>
   </example>
   
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   
   <para>
    Nowdocs son a las cadenas con comillas simples lo mismo que Heredoc lo es a las
    comillas dobles. Una cadena nowdoc se especifica de forma análoga a la heredoc, pero
    <emphasis>no se realiza ningún análisis</emphasis> dentro de nowdoc. Esta construcción
    es ideal para embeber código PHP o grandes fragmentos de texto sin necesidad de
    escaparlo. Comparte algunas características comunes con la construcción SGML
    <literal>&lt;![CDATA[ ]]&gt;</literal>, donde se declara un fragmento de texto
    que no debe ser analizado.
   </para>
   
   <para>
    Una cadena nowdoc se identifica con la misma sintaxis <literal>&lt;&lt;&lt;</literal>
    usada para heredoc, pero el identificador que le sigue esta encerrado entre
    comillas simples, por ejemplo <literal>&lt;&lt;&lt;'EOT'</literal>. Todas las reglas
    para los identificadores heredoc también son aplicables a los identificadores
    nowdoc, especialmente aquellos que se refieren al empleo del identificador de cierre.
   </para>
   
   <example>
    <title>Ejemplo de entrecomillado de string Nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Ejemplo de una cadena
expandida en varias líneas
empleando la sintaxis nowdoc.
EOD;

/* Un ejemplo más complejo con variables. */
class foo
{
    public $foo;
    public $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MiNombre';

echo <<<'EOT'
Mi nombre es "$name". Estoy escribiendo un poco de $foo->foo.
Ahora, estoy escribiendo un poco de {$foo->bar[1]}.
Esto debe mostrar una 'A' mayúscula: \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mi nombre es "$name". Estoy escribiendo un poco de $foo->foo.
Ahora, estoy escribiendo un poco de {$foo->bar[1]}.
Esto debe mostrar una 'A' mayúscula: \x41]]>
    </screen>
   </example>
   
   <note>
    <para>
     A diferencia de heredoc, nowdoc puede ser usado en cuaquier contexto de
     datos estáticos. Un ejemplo típico es la inicialización de
     propiedades o constantes en una clase:
    </para>
   </note>
   
   <example>
    <title>Ejemplo de datos estáticos</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
    </programlisting>
   </example>
   
   <note>
    <para>
     El soporte de Nowdoc se añadió en PHP 5.3.0.
    </para>
   </note>
   
  </sect3>
  
  <sect3 xml:id="language.types.string.parsing">
   <title>Análisis de variables</title>
   
   <simpara>
    Cuando un <type>string</type> es especificado mediante comillas dobles o mediante
    sintaxis heredoc, las <link linkend="language.variables">variables</link> dentro
    de dicha cadena son analizadas.
   </simpara>
   
   <simpara>
    Existen dos tipos de sintaxis: una <link linkend="language.types.string.parsing.simple">simple</link>
    y otra <link linkend="language.types.string.parsing.complex">compleja</link>. La
    sintaxis simple es la más empleada y conveniente. Proporciona una forma de incluir
    una variable, un valor de un <type>array</type> o una propiedad de un <type>object</type>
    dentro de un <type>string</type> con el mínimo esfuerzo.
   </simpara>
   
   <simpara>
    La sintaxis compleja puede ser reconocida por las llaves 
    que encierran la expresión.
   </simpara>
   
   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Sintaxis simple</title>
    
    <simpara>
     Si se encuentra un signo de dólar (<literal>$</literal>), el analizador ávidamente
     cogerá el mayor número de símbolos para formar un nombre de variable válido.
     Encerrar el nombre de la variable entre llaves permite especificar explícitamente
     el final del nombre.
    </simpara>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$jugo = "manzana";

echo "El tomó algo de jugo de $jugo.".PHP_EOL; 
// Inválido. "s" es un caracter válido para un nombre de variable, pero la variable es $jugo.
echo "El tomó algo de jugo hecho de $jugos.";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
El tomó algo de jugo de manzana.
El tomó algo de jugo hecho de .
]]>
     </screen>
    </informalexample>
    
    <simpara>
     De forma parecida, el índice de un <type>array</type> o la propiedad de un
     <type>object</type> puede ser analizado. Con los índices de los arrays, el
     corchete de cierre (<literal>]</literal>) marca el final del índice. La misma
     regla se puede aplicar a las propiedades de los objetos y a las variables simples.
    </simpara>
    
    <example><title>Ejemplo de sintaxis simple</title>
     <programlisting role="php">
<![CDATA[
<?php
$jugos = array("manzana", "naranja", "koolaid1" => "púrpura");

echo "El tomó algo de jugo de $jugos[0].".PHP_EOL;
echo "El tomó algo de jugo de $jugos[1].".PHP_EOL;
echo "El tomó algo de jugo hecho de $jugo[0]s.".PHP_EOL;// No funcionará
echo "El tomó algo de jugo $jugos[koolaid1].".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";
    
    public $smith = "Smith";
}

$people = new people();

echo "$people->john tomó algo de jugo de $jugos[0].".PHP_EOL;
echo "$people->john entonces dijo hola a $people->jane.".PHP_EOL;
echo "La esposa de $people->john's saludó a $people->robert.".PHP_EOL;
echo "$people->robert saludó a los dos $people->smiths."; // No funcionará
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
El tomó algo de jugo de manzana.
El tomó algo de jugo de naranja.
El tomó algo de jugo hecho de s.
El tomó algo de jugo púrpura.
John Smith tomó algo de jugo de manzana.
John Smith entonces dijo hola a Jane Smith.
La esposa de John Smith's saludó a Robert Paulsen.
Robert Paulsen saludó a los dos .
]]>
     </screen>
    </example>
    
    <simpara>
     Para casos más complejos se debe emplear la sintaxis compleja.
    </simpara>
   </sect4>
   
   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Sintaxis compleja (llaves)</title>
    
    <simpara>
     Esta sintaxis no se llama compleja poque sea compleja de aplicar, sino porque
     permite el empleo de expresiones complejas.
    </simpara>
    
    <simpara>
     Cualquier variable escalar, elemento de array o propiedad de objeto con una
     representación de <type>string</type> puede ser incluido a través de esta sintaxis.
     Simplemente se escribe la expresión del mismo modo en que debe aparecer por fuera del 
     <type>string</type>, y entonces se encierra ente <literal>{</literal> y
     <literal>}</literal>. Dado que  <literal>{</literal> no puede ser escapado, esta
     sintaxis será reconocida únicamente cuando el <literal>$</literal> siga
     inmediatamente al <literal>{</literal>. Utilice <literal>{\$</literal> para obtener un
     <literal>{$</literal> literal. Algunos ejemplos para que quede más claro:
    </simpara>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Muestra todos los errores
error_reporting(E_ALL);

$great = 'fantastico';

// No funciona, resultado: Esto es { fantastico}
echo "Esto es { $great}";

// Funciona, resultado: Esto es fantastico
echo "Esto es {$great}";
echo "Esto es ${great}";

// Funciona
echo "Este cuadrado tiene {$square->width}00 centímetros de lado.";

// Funciona, claves entre comillas sólo funcionan utilizando la sintaxis de llaves
echo "Esto funciona: {$arr['key']}";

// Funciona
echo "Funciona: {$arr[4][3]}";

// No funciona por la misma razón que $foo[bar] es incorrecto fuera de una cadena.
// En otras palabras, funcionaría pero solo porque PHP primero busca por una constante
// llamada foo; un error del nivel E_NOTICE (constante no definida) puede ser lanzado.
echo "No funciona: {$arr[foo][3]}";

// Funciona. Cuando se usan arrays multidimensionales, siempre emplee llaves encerrando
// los arrays cuando se encuentre dentro de una cadena
echo "Funciona: {$arr['foo'][3]}";

// Funciona.
echo "Funciona: " . $arr['foo'][3];

echo "Tambien funciona: {$obj->values[3]->name}";

echo "Este es el valor de la variable llamada $name: {${$name}}";

echo "Este es el valor de la variable llamada por el valor de retorno de getName(): {${getName()}}";

echo "Este es el valor de la variable llamada por el valor de retorno de \$object->getName(): {${$object->getName()}}";

//No funciona, imprime: Esto es el valor de retorno de getName(): {getName ()}
echo "Esto es el valor de retorno de getName(): {getName()}";
?>
]]>
      <!-- maybe it's better to leave this out??
      // this works, but i disencourage its use, since this is NOT
      // involving functions, rather than mere variables, arrays and objects.
      $beer = 'Heineken';
      echo "I'd like to have another {${ strrev('reeb') }}, hips";
      -->
     </programlisting>
    </informalexample>
    
    <para>
     También es posible acceder a las propiedades de una clase usando variables 
     dentro de cadenas al emplear ésta sintaxis.
    </para>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'Soy bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->$baz[1]}\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Soy bar.
Soy bar.
]]>
     </screen>
    </informalexample>
    
    <note>
     <para>
      Funciones, llamadas a métodos, variables estáticas de clases y constantes de
      clases dentro de <literal>{$}</literal> funcionan desde PHP 5. Sin embargo,
      el valor accedido puede ser interpretado como el nombre de la variable en el
      ámbito en el que la cadena está definida. Empleando llaves simples
      (<literal>{}</literal>) no servirá para acceder al valor de retorno de
      las funciones o métodos, constantes o variables estáticas de clases.
     </para>
    </note>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Muestra todos los errores.
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// Funciona; resultado: Me gusta una A & W
echo "Me gusta una {${beers::softdrink}}\n";

// Tambien funciona; resultado: Me gusta una Alexander Keith's
echo "Me gusta una {${beers::$ale}}\n";
?>
]]>
     </programlisting>
    </informalexample>
    
   </sect4>
  </sect3>
  
  <sect3 xml:id="language.types.string.substr">
   <title>Acceso a cadenas y modificacion por caracteres</title>
   
   <para>
    Los caracteres dentro de un <type>string</type> pueden ser accedidos y modificados
    especificando la posición de caracter deseado (en base a la posición cero del primer
    caracter del <type>string</type>) empleando los corchetes de <type>array</type>,
    como en <varname>$str[42]</varname>. Piense en este caso que un <type>string</type>
    se comporta como un <type>array</type> de caracteres. Las funciones
    <function>substr</function> y <function>substr_replace</function>
    pueden ser empleados para extraer y reemplazar más de un caracter.
   </para>
   
   <note>
    <simpara>
     Los <type>String</type> también pueden accederse utilizando llaves, como en
     <varname>$str{42}</varname>, para el mismo propósito.
    </simpara>
   </note>
   
   <warning>
    <simpara>
     Escribir fuera del rango es compensado rellenando el string con espacios.
     Los tipos que no sean integer son convertidos a integer. Las compensaciones fuera
     de rango emiten <constant>E_NOTICE</constant>. Las compensaciones negativas
     emiten <constant>E_NOTICE</constant> en la escritura pero en la lectura obtienen
     una cadena vacía. Sólo se emplea el primer carácter de un string asignado. La
     asignación de un string vacío asigna un byte NULL.
    </simpara>
   </warning>
   
   <warning>
    <simpara>
     Internamente, las cadenas de PHP son arrays de bytes. Por tanto, acceder o
     modificar una cadena utilizando los corchetes de array no es seguro con caracteres multi-byte, y
     sólo debe hacerse con cadenas en codificaciones de un solo bit como
     ISO-8859-1.
    </simpara>
   </warning>
   
   <example>
    <title>Algunos ejemplos de cadenas</title>
    <programlisting role="php">
<![CDATA[
<?php
// Obtención del primer caracter de una cadena
$str = 'Esto es un test.';
$first = $str[0];

// Obtención del tercer caracter de una cadena
$third = $str[2];

// Obtención del último caracter de una cadena
$str = 'Esto sigue siendo un test.';
$last = $str[strlen($str)-1];

// Modificación del último caracter de una cadena
$str = 'Mira el mar';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>
   
   <para>
    A partir de PHP 5.4 los índices de cadenas tienen que ser enteros o enteros en forma de cadena, si no se lanzará
    una advertencia. Anteriormente un índice como <literal>"foo"</literal> era convertido de manera silenciosa a <literal>0</literal>.
   </para>
   
   <example>
    <title>Diferencias entre PHP 5.3 y PHP 5.4</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = 'abc';

var_dump($str['1']);
var_dump(isset($str['1']));

var_dump($str['1.0']);
var_dump(isset($str['1.0']));

var_dump($str['x']);
var_dump(isset($str['x']));

var_dump($str['1x']);
var_dump(isset($str['1x']));
?>
]]>
    </programlisting>
    &example.outputs.53;
    <screen>
<![CDATA[
string(1) "b"
bool(true)
string(1) "b"
bool(true)
string(1) "a"
bool(true)
string(1) "b"
bool(true)
]]>
    </screen>
    &example.outputs.54;
    <screen>
<![CDATA[
string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' in /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' in /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)
]]>
    </screen>
   </example>
   
   <note>
    <para>
     El acceso a variables de otros tipos (sin incluir arrays u objetos
     implementando las interfaces apropiadas) utilizando <literal>[]</literal> o
     <literal>{}</literal> silenciosamente retorna &null;.
    </para>
   </note>
   
   <note>
    <para>
     PHP 5.5 añadió soporte para acceder a caracteres dentro de cadenas literales
     utilizando <literal>[]</literal> o <literal>{}</literal>.
    </para>
   </note>   
  </sect3>
 </sect2><!-- end syntax -->
 
 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Funciones y operadores útiles</title>
  
  <para>
   Los <type>string</type> pueden ser concatenados empleando el operador '.' (punto).
   Fíjese que el operador '+' (suma) <emphasis>no</emphasis> servirá para concatenar.
   Consulte <link linkend="language.operators.string">operadores de string</link> para
   más información.
  </para>
  
  <para>
   Hay una serie de funciones útiles para la manipulación de <type>string</type>.
  </para>
  
  <simpara>
   Consulte la <link linkend="ref.strings">sección de funciones de string</link>
   para funciones generales, y las <link linkend="ref.regex">funciones de expresiones
   regulares</link> o las <link linkend="ref.pcre">funciones de expresiones regulares
   compatibles con Perl</link> para funcionalidades avanzadas de búsqueda y sustitución.
  </simpara>
  
  <simpara>
   Tambien existen <link linkend="ref.url">funciones para cadenas URL</link>, y
   funciones para encriptar/desencriptar cadenas (<link linkend="ref.mcrypt">mcrypt</link>
   y <link linkend="ref.mhash">mhash</link>).
  </simpara>
  
  <simpara>
   Finalmente, tambien existen las <link linkend="ref.ctype">funciones para el tipo
   caracter</link>.
  </simpara>
 </sect2>
 
 <sect2 xml:id="language.types.string.casting">
  <title>Conversión a cadena</title>
  
  <para>
   Un valor puede convertirse a una <type>string</type> mediante el forzado
   <literal>(string)</literal> o la función <function>strval</function>.
   La conversión automática a <type>string</type> tiene lugar en el contexto de
   una expresióin que necesita un <type>string</type>. Esto ocurre cuando se utilizan
   las funciones <function>echo</function> o <function>print</function>, o cuando
   una variables es comparada con un <type>string</type>. Las secciones sobre
   <link linkend="language.types">tipos</link> y
   <link linkend="language.types.type-juggling">Manipulación de tipos</link> pueden ayudarle
   a enterderlo con más claridad. Consulte tambien la función <function>settype</function>.
  </para>
  
  <para>
   El valor &true; del tipo <type>boolean</type> es convertido en el
   <type>string</type> <literal>"1"</literal>. El valor &false; del tipo
   <type>boolean</type> es convertido en el <type>string</type> <literal>""</literal>
   (la cadena vacía). Esto permite la conversión en ambos sentidos entre los valores de
   los tipos <type>boolean</type> y <type>string</type>.
  </para>
  
  <para>
   Un <type>integer</type> o <type>float</type> es convertido en un
   <type>string</type> representando textualmente el número (incluyendo
   la parte exponencial para los <type>float</type>s. Los números de
   punto flotante pueden ser convertidos mediante la notación exponencial
   (<literal>4.1E+6</literal>).
  </para>
  
  <note>
   <para>
    El caracter para el punto decimal se define en el script de configuración
    regional (categoría LC_NUMERIC). Consulte la función <function>setlocale</function>.
   </para>
  </note>
  
  <para>
   Los <type>array</type>s siempre se convierten en un <type>string</type>
   <literal>"Array"</literal>. Debido a esto, tanto <function>echo</function> y
   <function>print</function> no pueden pos sí mismos mostrar el contenido de un
   <type>array</type>. Para ver un elemento individualmente, utilice una
   construcción como <literal>echo $arr['foo']</literal>. Mire los trucos en la parte
   inferior para mostrar el contenido por completo.
  </para>
  
  <para>
   Los <type>object</type>s en PHP 4 siempre se convierten en un <type>string</type>
   <literal>"Object"</literal>. Para mostrar los valores de las propiedades de un
   objeto para depuración, mire los parrafos siguientes. Para obtener el nombre de
   la clase del objeto emplée la función <function>get_class</function>. A partir
   de PHP 5 se puede emplear el método <link linkend="language.oop5.magic">__toString</link>.
  </para>
  
  <para>
   Los <type>resource</type>s siempre se convierten en <type>string</type>s mediante
   la estructura <literal>"Resource id #1"</literal>, donde <literal>1</literal> es
   el número único asignado al <type>resource</type> por PHP en tiempo de ejecución.
   No debe confiar en esta estructura, ya que está sujeto a cambios. Para obtener
   el tipo del <type>resource</type> emplee la función <function>get_resource_type</function>.
  </para>
  
  <para>
   &null; siempre es convertido a una cadena vacía.
  </para>
  
  <para>
   Como se ha indicado anteriormente, la conversión directa de un <type>array</type>,
   <type>object</type> o <type>resource</type> a un <type>string</type> no proporciona
   información útil acerca del valor, más allá de su tipo. Consulte las funciones
   <function>print_r</function> y <function>var_dump</function> para obtener maneras
   más efectivas de inspeccionar el contenido de estos tipos.
  </para>
  
  <para>
   La mayoría de los valores de PHP pueden ser convertidos a <type>string</type>s para
   su almacenamiento permanente. Este método se denomina serialización, y es realizado
   mediante la función <function>serialize</function>. Si la máquina PHP está contruida con
   soporte de <link linkend="ref.wddx">WDDX</link>, los valores de PHP tambien pueden
   ser serializacos como texto XML correctamente formateado.
  </para>
  
 </sect2>
 
 <sect2 xml:id="language.types.string.conversion">
  <title>Conversión de cadenas a números</title>
  
  <simpara>
   Cuando una <type>string</type> es evaluada en un contexto numérico, el valor
   resultante y el tipo se determina como se explica a continuación.
  </simpara>
  
  <simpara>
   Si el <type>string</type> no contiene ninguno de los caracteres '.', 'e',
   o 'E' y el valor numérico está entre los límites del tipo entero (como se
   define en <constant>PHP_INT_MAX</constant>), la <type>string</type> será
   evaluada como un <type>integer</type>. En todos los demas casos será
   evaluado como un <type>float</type>.
  </simpara>
  
  <para>
   El valor es dado por la parte inicial del <type>string</type>. Si el
   <type>string</type> empieza con un número válido, éste será el valor usado. De
   otra forma, el valor será 0 (cero). Se considera número válido a un signo
   opcional, seguido de uno o más dígitos (opcionalmente puede contener un
   punto decimal), seguido de un exponente opcional. El exponente es una 'e' o
   'E' seguida de uno o más dígitos.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo es float (11.5)
$foo = 1 + "-1.3e3";              // $foo es float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo es integer (1)
$foo = 1 + "bob3";                // $foo es integer (1)
$foo = 1 + "10 Small Pigs";       // $foo es integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo es float (14.2)
$foo = "10.0 pigs " + 1;          // $foo es float (11)
$foo = "10.0 pigs " + 1.0;        // $foo es float (11)     
?>
]]>
   </programlisting>
  </informalexample>
  
  <simpara>
   Para más información sobre esta conversión, consulte la página del manual UNIX
   correspondiente a strtod(3).
  </simpara>
  
  <para>
   Para probar cualquiera de los ejemplos en esta sección, copie y pegue los ejemplos e
   incluya la siguiente línea para ver que está ocurriendo:
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; tipo es " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   No espere obtener el código de un caracter convirtiendolo a un entero,
   como ocurre en C. Emplee las funciones <function>ord</function> y
   <function>chr</function> para convertir entre código ASCII y caracteres.
  </para>
  
 </sect2>
 
 <sect2 xml:id="language.types.string.details">
  
  <title>Detalles del tipo de dato String</title>
  
  <para>
   En PHP, los <type>string</type> se implementan como una matriz de bytes y con un
   entero que indica la longitud del buffer. No guarda ninguna información sobre cómo
   traducir esos bytes, relegando esa tarea al programador.
   No existe ninguna limitación sobre el valor que puede contener un string; en
   concreto, está permitido colocar un bytes con valor <literal>0</literal> (“bytes NUL”)
   en cualquier posición del string (existen algunas funciones, marcadas en este manual como
   que no utilizan "modo binario seguro", podrían rechazar estos strings para aquellas
   bibliotecas que ignoren los datos preceden a un byte NUL.)
  </para>
  <para>
   Este comportamiento de los strings justifica el que no exista un tipo de dato "byte"
   en PHP – los strings se encargan de esto. Las funciones que no devuelvan datos de texto – por
   ejemplo, cualquier dato leído a partir de un socket de red – devolverán 
   strings.
  </para>
  <para>
   Dado que PHP no obliga a utilizar ninguna condificación en particular, uno podría
   preguntarse cómo se codifican los textos literales. Por ejemplo, ¿es el string
   <literal>"á"</literal> equivalente a <literal>"\xE1"</literal> (ISO-8859-1),
   <literal>"\xC3\xA1"</literal> (forma en C UTF-8),
   <literal>"\x61\xCC\x81"</literal> (forma en D UTF-8) o cualquier otra representación
   posible? La resuesta es que un string se codifica en cualesquiera forma en que
   estuviera el fichero de código. Por tanto, si un fichero de código estuviera escrito en
   ISO-8859-1, el string se codificará en ISO-8859-1, y así. Sin embargo,
   esto no es aplicable si Zend Multibyte está habilitado; en ese caso, el fichero de código
   podría estar escrito en cualquier codificación (declarada explícitamente o bien
   detectada) para después convertirse a una determinada codificación interna, que será
   entonces la codificación usada para los textos literales.
   Tenga presente que existen algunas limitaciones sobre la codificación del código fuente (o en
   la codificación internal, si Zend Multibyte estuviera habilitado) – esto suele significar
   que se debe usar uan codificación complatible con el conjunto ASCII, como por ejemplo
   UTF-8 o ISO-8859-1. Por contra, las codificaciones dependientes de estados, donde
   un mismo byte se puede utilizar en estados de desplazamiento iniciales y no iniciales,
   podría generar problemas.
  </para>
  <para>
   Por supuesto, para poder ser útil, las funciones que operen con texto podrán partir de unos
   supuestos sobre cómo está codificado el string. Desafortunadamente, respecto a 
   esto existen muchas variaciones en la funciones de PHP:
  </para>
  <itemizedlist>
   <listitem>
    <simpara>
     Algunas funciones asumen que el string está codificado en una codificación
     simple de bytes, por lo que no necesitan interpretar estos bytes como caracteres
     específicos. Este es el caso de, por ejemplo, <function>substr</function>, 
     <function>strpos</function>, <function>strlen</function> o
     <function>strcmp</function>. Otra forma de entender estas funciones es pensando
     que operan sobre buffers de memoria, es decir, trabajan con bytes y con desplazamientos
     de bytes.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     A otras funciones se les indica la codificación del string, si bien es posible
     que tengan una codificación predeterminada. Este es el caso de
     <function>htmlentities</function> y la mayoría de funciones de la extensión
     <link linkend="book.mbstring">mbstring</link>.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Otras, utilizan las locales en uso (ver <function>setlocale</function>), pero 
     operan byte a byte. Este es el caso de <function>strcasecmp</function>,
     <function>strtoupper</function> y <function>ucfirst</function>.
     Esto significa que sólo se pueden usar con codificaciones de un byte, siempre y
     cuando la codificación coincida con la de la local. Por ejemplo
     <literal>strtoupper("á")</literal> podría devolver <literal>"Á"</literal> si las
     locales están correctamente habilitadas y <literal>á</literal> está codificado con un
     único byte. Si está codificado en UTF-8, no se devolverá un resultado correcto
     y el string resultante podría, o no, devolverse corrupto, en función de las
     locales en uso.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Por último, podrán tambien asumir que se utiliza una codificación en particular,
     usualmente UTF-8. Este es el caso de la mayoría de las funciones de la extensión
     <link linkend="book.intl">intl</link> y de la extensión
     <link linkend="book.pcre">PCRE</link>
     (en este último caso, sólo cuando se utiliza el modificador <literal>u</literal>).
     Debido a su propósito especial, la función
     <function>utf8_decode</function> asume una codificación UTF-8, mientras que la
     función <function>utf8_encode</function> asume una codificación ISO-8859-1.
    </simpara>
   </listitem>
  </itemizedlist>
  
  <para>
   En resumen, esto significa que para escribir programas Unicode de forma correcta
   hay que evitar cuidadosamente las funciones que pudean fallar y que muy probablemente
   vuelvan los datos corruptos, y utilizar en su lugar las funciones que se comportan de forma
   correcta, generalmente de las extensiones <link linkend="book.intl">intl</link> y
   <link linkend="book.mbstring">mbstring</link>.
   Sin embargo, el utilizar funciones que puedan manejar codificaciones Unicode es sólo
   el principio. No importa qué funciones incorpore el lenguaje; es primordial
   conocer la especificación Unicode. Por ejemplo, un programa que asuma que sólo
   hay mayúsculas y minúsculas estará haciendo una suposición erronea.
  </para>
 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

