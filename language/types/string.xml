<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 2832df2e1bd7daa1ec29ffb167dce1c9feb8cc6b Maintainer: PhilDaiguille Status: ready -->
<!-- Reviewed: no Maintainer: girgias -->
<sect1 xml:id="language.types.string">
 <title>Cadenas</title>

 <para>
  Un <type>string</type> es una serie de caracteres, donde un caracter
  es lo mismo que un octeto. Esto significa que PHP solo admite un conjunto
  de 256 caracteres, y por lo tanto no ofrece soporte nativo para Unicode. Ver
  <link linkend="language.types.string.details">los detalles del tipo string</link>.
 </para>

 <note>
  <simpara>
   En las versiones de 32 bits, un <type>string</type> puede ser tan grande como 2 Go
   (2147483647 octetos maximo)
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Sintaxis</title>

  <para>
   Un <type>string</type> literal puede especificarse de cuatro maneras diferentes:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">entre comillas simples</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">entre comillas dobles</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">sintaxis heredoc</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">sintaxis nowdoc</link>
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Entre comillas simples</title>

   <para>
    La manera más simple de especificar un <type>string</type> es encerrarlo entre
    comillas simples (el caracter <literal>'</literal>).
   </para>

   <para>
    Para especificar una comilla simple literal, escápela con un backslash
    (<literal>\</literal>). Para especificar un backslash literal, duplíquelo
    (<literal>\\</literal>). Todas las demás ocurrencias del backslash serán tratadas
    como un backslash literal: esto significa que otras secuencias de escape que usted
    podría conocer, tales como <literal>\r</literal> o <literal>\n</literal>,
    serán salidas literalmente como se especifica en lugar de tener un significado especial.
   </para>

   <note>
    <simpara>
     A diferencia de las <link linkend="language.types.string.syntax.double">comillas dobles</link>
     y <link linkend="language.types.string.syntax.heredoc">sintaxis heredoc</link>,
     las <link linkend="language.variables">variables</link> y las secuencias de escape
     para caracteres especiales <emphasis>no</emphasis> serán <emphasis>extendidas</emphasis>
     cuando se encuentren en <type>strings</type> entre comillas simples.
    </simpara>
   </note>

   <example>
    <title>Variantes de sintaxis</title>
    <programlisting role="php">
<![CDATA[
<?php
echo 'esto es un string simple', PHP_EOL;

echo 'Usted puede también tener nuevas líneas integradas
en los strings de esta manera, ya que
es aceptable hacerlo.', PHP_EOL;

// Muestra: Arnold dijo una vez: "Volveré"
echo 'Arnold dijo una vez: "Volveré"', PHP_EOL;

// Muestra: ¿Usted ha borrado C:\*.*?
echo '¿Usted ha borrado C:\\*.* ?', PHP_EOL;

// Muestra: ¿Usted ha borrado C:\*.*?
echo '¿Usted ha borrado C:\*.* ?', PHP_EOL;

// Muestra: Esto no se extenderá: \n una nueva línea
echo 'Esto no se\'extenderá: \n una nueva línea', PHP_EOL;

// Muestra: Las variables no $se\'extienden $tampoco
echo 'Las variables no $se\'extienden $tampoco', PHP_EOL;
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Entre comillas dobles</title>

   <para>
    Si el <type>string</type> está encerrado entre comillas dobles (<literal>"</literal>), PHP interpretará
    las siguientes secuencias de escape para caracteres especiales:
   </para>

   <table>
    <title>Caracteres escapados</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Secuencia</entry>
       <entry>Significado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>retorno de carro (LF o 0x0A (10) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>retorno de carro (CR o 0x0D (13) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>tabulación horizontal (HT o 0x09 (9) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>tabulación vertical (VT o 0x0B (11) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>escape (ESC o 0x1B (27) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>avance de formulario (FF o 0x0C (12) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>backslash</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>signo de dólar</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>comilla doble</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        Octal: la secuencia de caracteres correspondiente a la expresión regular <literal>[0-7]{1,3}</literal>
        es un caracter en notación octal (por ejemplo, <literal>"\101" === "A"</literal>),
        que desborda silenciosamente para adaptarse a un octeto (por ejemplo, <literal>"\400" === "\000"</literal>)
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        Hexadecimal: la secuencia de caracteres correspondiente a la expresión regular
        <literal>[0-9A-Fa-f]{1,2}</literal> es un caracter en notación hexadecimal
        (por ejemplo, <literal>"\x41" === "A"</literal>)
       </entry>
      </row>
      <row>
       <entry><literal>\u{[0-9A-Fa-f]+}</literal></entry>
       <entry>
        Unicode: la secuencia de caracteres correspondiente a la expresión regular <literal>[0-9A-Fa-f]+</literal>
        es un punto de código Unicode, que será salido en el string bajo la representación UTF-8 de este punto de código.
        Las llaves son requeridas en la secuencia. Por ejemplo, <literal>"\u{41}" === "A"</literal>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
<para>
    Como para los <type>strings</type> entre comillas simples, escapar cualquier otro caracter
    también resultará en la impresión del backslash.
</para>

<para>
    La característica más importante de los <type>strings</type> entre comillas dobles es el hecho
    de que los nombres de variables serán extendidos. Ver
    <link linkend="language.types.string.parsing">la interpolación de strings</link> para
    más detalles.
</para>
</sect3>

<sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Una tercera manera de delimitar los <type>strings</type> es la sintaxis heredoc:
    <literal>&lt;&lt;&lt;</literal>. Después de este operador, se
    proporciona un identificador, luego una nueva línea. El <type>string</type> mismo sigue, luego
    el mismo identificador nuevamente para cerrar la cita.
   </simpara>

   <simpara>
    El identificador de cierre puede estar indentado con espacios o tabulaciones, en cuyo caso
    la indentación será eliminada de todas las líneas en el string doc.
    Antes de PHP 7.3.0, el identificador de cierre <emphasis>debe</emphasis>
    comenzar en la primera columna de la línea.
   </simpara>

   <simpara>
    Además, el identificador de cierre debe seguir las mismas reglas de nombramiento que cualquier
    otro etiqueta en PHP: debe contener solo caracteres alfanuméricos y guiones bajos,
    y debe comenzar con un carácter no numérico o un guión bajo.
   </simpara>

   <example>
    <title>Ejemplo básico de Heredoc a partir de PHP 7.3.0</title>
    <programlisting role="php">
<![CDATA[
<?php
// sin indentación
echo <<<END
      a
     b
    c
\n
END;

// 4 espacios de indentación
echo <<<END
      a
     b
    c
    END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
      a
     b
    c

  a
 b
c
]]>
    </screen>
   </example>

   <simpara>
    Si el identificador de cierre está indentado más que cualquier línea del cuerpo, entonces se levantará un <classname>ParseError</classname>:
   </simpara>

   <example>
    <title>El identificador de cierre no debe estar indentado más que cualquier línea del cuerpo</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<END
  a
 b
c
   END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
Parse error: Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4
]]>
    </screen>
   </example>

   <simpara>
    Si el identificador de cierre está indentado, las tabulaciones también pueden ser utilizadas, sin embargo,
    las tabulaciones y los espacios <emphasis>no deben</emphasis> mezclarse en cuanto a
    la indentación del identificador de cierre y la indentación del cuerpo
    (hasta el identificador de cierre). En cualquiera de estos casos, se levantará un <classname>ParseError</classname>.

    Estas restricciones de espacio han sido incluidas porque mezclar espacios y tabulaciones para la indentación perjudica la legibilidad.
   </simpara>

   <example>
    <title>Indentación diferente para el cuerpo (espacios) identificador de cierre</title>
    <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
// Todo el código siguiente no funciona.

// indentación diferente para el cuerpo (espacios) marcador de fin (tabulaciones)
{
    echo <<<END
        a
        END;
}

// mezcla de espacios y tabulaciones en el cuerpo
{
    echo <<<END
            a
        END;
}

// mezcla de espacios y tabulaciones en el marcador de fin
{
    echo <<<END
            a
        END;
}
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
Parse error: Invalid indentation - tabs and spaces cannot be mixed in example.php line 8
]]>
    </screen>
   </example>

   <simpara>
    El identificador de cierre para el string del cuerpo no es requerido para ser
    seguido de un punto y coma o un salto de línea. Por ejemplo, el siguiente
    código es permitido a partir de PHP 7.3.0:
   </simpara>

   <example>
    <title>Continuación de una expresión después de un identificador de cierre</title>
    <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
  b
    c
END, 'd e f'];
var_dump($values);
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
array(2) {
  [0] =>
  string(11) "a
  b
    c"
  [1] =>
  string(5) "d e f"
}
]]>
    </screen>
   </example>

   <warning>
    <simpara>
     Si el identificador de cierre ha sido encontrado al principio de una línea, entonces
     no importa si formaba parte de otra palabra, puede ser considerado
     como el identificador de cierre y provocar un <classname>ParseError</classname>.
    </simpara>

    <example>
     <title>El identificador de cierre en el cuerpo del string tiende a provocar un ParseError</title>
     <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
b
END ING
END, 'd e f'];
]]>
     </programlisting>
     &example.outputs.73;
    <screen>
<![CDATA[
Parse error: syntax error, unexpected identifier "ING", expecting "]" in example.php on line 5
]]>
     </screen>
    </example>

    <simpara>
     Para evitar este problema, es seguro seguir la regla simple:
     <emphasis>no elegir una palabra que aparezca en el cuerpo del texto
     como identificador de cierre</emphasis>.
    </simpara>

   </warning>

   <warning>
    <simpara>
     Antes de PHP 7.3.0, es muy importante señalar que la línea que contiene el
     identificador de cierre no debe contener ningún otro carácter, excepto un punto y coma
     (<literal>;</literal>).
     Esto significa principalmente que el identificador
     <emphasis>no puede estar indentado</emphasis>, y no debe haber espacios
     o tabulaciones antes o después del punto y coma. También es importante darse cuenta de que
     el primer carácter antes del identificador de cierre debe ser un salto de línea tal como
     se define en el sistema operativo local. Es <literal>\n</literal> en
     los sistemas UNIX, incluyendo macOS. El delimitador de cierre también debe ser
     seguido de un salto de línea.
    </simpara>

    <simpara>
     Si esta regla se viola y el identificador de cierre no está "limpio", no será
     considerado como un identificador de cierre, y PHP continuará buscando uno. Si un
     identificador de cierre adecuado no se encuentra antes del final del archivo
     actual, se producirá un error de análisis en la última línea.
    </simpara>

    <example>
     <title>Ejemplo inválido, antes de PHP 7.3.0</title>
     <programlisting role="php">
      <!-- Esto es un ejemplo INVÁLIDO -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
// El identificador no debe estar indentado
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Ejemplo válido, incluso antes de PHP 7.3.0</title>
     <programlisting role="php">
      <!-- Esto es un ejemplo VÁLIDO -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>

    <para>
     Los heredocs que contienen variables no pueden ser utilizados para inicializar propiedades de clase.
    </para>

   </warning>

   <para>
    El texto heredoc se comporta exactamente como un <type>string</type> entre comillas dobles, sin las comillas. Esto significa que las comillas en un heredoc no necesitan ser escapadas, pero los códigos de escape mencionados anteriormente pueden seguir siendo utilizados. Las variables son desarrolladas, pero debe tenerse el mismo cuidado al expresar variables complejas dentro de un heredoc que para los <type>strings</type>.
   </para>

   <example>
    <title>Ejemplo de cita de string heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Ejemplo de string
que se extiende sobre múltiples líneas
usando la sintaxis heredoc.
EOD;

/* Ejemplo más complejo, con variables. */
class foo
{
    var $foo;
    var $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
Mi nombre es "$name". Estoy imprimiendo $foo->foo.
Ahora, estoy imprimiendo {$foo->bar[1]}.
Esto debería imprimir una 'A' mayúscula: \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mi nombre es "MyName". Estoy imprimiendo Foo.
Ahora, estoy imprimiendo Bar2.
Esto debería imprimir una 'A' mayúscula: A]]>
    </screen>
   </example>

   <para>
    También es posible utilizar la sintaxis heredoc para pasar datos a los argumentos de función:
   </para>

   <example>
    <title>Heredoc en ejemplos de argumentos</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>

   <para>
    Es posible inicializar variables estáticas y propiedades/constantes de clase utilizando la sintaxis heredoc:
   </para>

   <example>
    <title>Uso de Heredoc para inicializar valores estáticos</title>
    <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
// Variables estáticas
function foo()
{
    static $bar = <<<LABEL
Nada aquí...
LABEL;
}

// Propiedades/constantes de clase
class foo
{
    const BAR = <<<FOOBAR
Ejemplo de constante
FOOBAR;

    public $baz = <<<FOOBAR
Ejemplo de propiedad
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>

   <para>
    El identificador de apertura del Heredoc puede eventualmente ser
    encerrado entre comillas dobles:
   </para>

   <example>
    <title>Uso de comillas dobles en el Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
¡Hola mundo!
FOOBAR;
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>

   <para>
    Los nowdocs son para los strings entre comillas simples lo que los heredocs son para los strings entre comillas dobles. Un nowdoc se especifica de manera similar a un heredoc, pero <emphasis>ninguna interpolación de string es realizada</emphasis> dentro de un nowdoc. La construcción es ideal para integrar código PHP o otros bloques de texto voluminosos sin necesidad de escapar. Comparte algunas características con la construcción SGML
    <literal>&lt;![CDATA[ ]]&gt;</literal>, en el sentido de que declara
    un bloque de texto que no está destinado a ser analizado.
   </para>

   <para>
    Un nowdoc es identificado por la misma secuencia <literal>&lt;&lt;&lt;</literal>
    utilizada para los heredocs, pero el identificador que sigue está encerrado entre comillas simples, por ejemplo <literal>&lt;&lt;&lt;'EOT'</literal>. Todas las reglas para los identificadores heredoc se aplican también a los identificadores nowdoc, en particular aquellas concernientes a la apariencia del identificador de cierre.
   </para>

   <example>
    <title>Ejemplo de cita de string nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<'EOD'
Ejemplo de string que se extiende sobre múltiples líneas
usando la sintaxis nowdoc. Las barras invertidas son siempre tratadas literalmente,
es decir \\ y \'.
EOD;
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Ejemplo de string que se extiende sobre múltiples líneas
usando la sintaxis nowdoc. Las barras invertidas son siempre tratadas literalmente,
es decir \\ y \'.
]]>
    </screen>
   </example>

   <example>
    <title>Ejemplo de cita de string nowdoc con variables</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo
{
    public $foo;
    public $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
Mi nombre es "$name". Estoy imprimiendo $foo->foo.
Ahora, estoy imprimiendo {$foo->bar[1]}.
Esto no debería imprimir una 'A' mayúscula: \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mi nombre es "$name". Estoy imprimiendo $foo->foo.
Ahora, estoy imprimiendo {$foo->bar[1]}.
Esto no debería imprimir una 'A' mayúscula: \x41]]>
    </screen>
   </example>

   <example>
    <title>Ejemplo de datos estáticos</title>
    <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Interpolación de strings</title>

   <simpara>
    Cuando un <type>string</type> es especificado entre comillas dobles o con heredoc,
    las <link linkend="language.variables">variables</link> pueden ser sustituidas dentro.
   </simpara>

   <simpara>
    Existen dos tipos de sintaxis: una
    <link linkend="language.types.string.parsing.basic">básica</link> y una
    <link linkend="language.types.string.parsing.advanced">avanzada</link>.
    La sintaxis básica es la más común y práctica. Ofrece un medio para incorporar una variable,
    un valor <type>array</type> o una propiedad <type>objeto</type> en un <type>string</type> con un mínimo de esfuerzo.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.basic">
    <title>Sintaxis básica</title>
    <simpara>
     Si un signo de dólar (<literal>$</literal>) es encontrado, los caracteres que lo siguen y que pueden ser utilizados en un nombre de variable serán interpretados como tales y sustituidos.
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$juice = "manzana";

echo "Él bebió un poco de $juice jugo." . PHP_EOL;

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Él bebió un poco de manzana jugo.
]]>
     </screen>
    </informalexample>

    <simpara>
     Formalmente, la estructura para la sintaxis de sustitución de variable básica es la siguiente:
    </simpara>
    <example>
     <title>Interpolación de strings</title>
     <programlisting>
<![CDATA[
string-variable::
     variable-name   (offset-or-property)?
   | ${   expression   }

offset-or-property::
     offset-in-string
   | property-in-string

offset-in-string::
     [   name   ]
   | [   variable-name   ]
   | [   integer-literal   ]

property-in-string::
     ->  name

variable-name::
     $   name

name::
     [a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*

]]>
     </programlisting>
    </example>

    <warning>
     <para>
      La sintaxis <literal>${ expression }</literal> está deprecada desde
      PHP 8.2.0, ya que puede ser interpretada como
      <link linkend="language.variables.variable">variables de variables</link>:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
const foo = 'bar';
$foo = 'foo';
$bar = 'bar';
var_dump("${foo}");
var_dump("${(foo)}");
?>
]]>
       </programlisting>
       &example.outputs.82;
       <screen>
<![CDATA[
Deprecated: Usar ${var} en strings está deprecado, use {$var} en su lugar en el archivo en la línea 6

Deprecated: Usar ${expr} (variables de variables) en strings está deprecado, use {${expr}} en su lugar en el archivo en la línea 9
string(3) "foo"
string(3) "bar"
]]>
       </screen>
       &example.outputs;
       <screen>
<![CDATA[
string(3) "foo"
string(3) "bar"
]]>
       </screen>
      </informalexample>
      La sintaxis de interpolación de string <link linkend="language.types.string.parsing.advanced">avanzada</link> debería ser utilizada en su lugar.
     </para>
    </warning>

    <note>
     <simpara>
      Si no es posible formar un nombre válido, el signo de dólar
      tal cual en el string:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "Ninguna interpolación $  ha ocurrido\n";
echo "Ninguna interpolación $\n ha ocurrido\n";
echo "Ninguna interpolación $2 ha ocurrido\n";
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Ninguna interpolación $  ha ocurrido
Ninguna interpolación $
 ha ocurrido
Ninguna interpolación $2 ha ocurrido
]]>
      </screen>
    </informalexample>
    </note>

    <example>
     <title>Interpolación del valor de la primera dimensión de un array o propiedad</title>
     <programlisting role="php">
<![CDATA[
<?php
$juices = array("manzana", "naranja", "string_key" => "violet");

echo "Él bebió un poco de $juices[0] jugo.";
echo PHP_EOL;
echo "Él bebió un poco de $juices[1] jugo.";
echo PHP_EOL;
echo "Él bebió un poco de $juices[string_key] jugo.";
echo PHP_EOL;

class A {
    public $s = "string";
}

$o = new A();

echo "Valor del objeto: $o->s.";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Él bebió un poco de manzana jugo.
Él bebió un poco de naranja jugo.
Él bebió un poco de violet jugo.
Valor del objeto: string.
]]>
     </screen>
    </example>

    <note>
     <simpara>
      La clave del array debe ser no citada, y por lo tanto no es posible
      referenciar una constante como clave con la sintaxis básica. Utilice la
      sintaxis <link linkend="language.types.string.parsing.advanced">avanzada</link>
      en su lugar.
     </simpara>
    </note>

    <simpara>
     Desde PHP 7.1.0, los índices numéricos <emphasis>negativos</emphasis> también
     son soportados.
    </simpara>

    <example><title>Índices numéricos negativos</title>
     <programlisting role="php">
<![CDATA[
<?php
$string = 'string';
echo "El carácter en el índice -2 es $string[-2].", PHP_EOL;
$string[-3] = 'o';
echo "Cambiar el carácter en el índice -3 a o da $string.", PHP_EOL;
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
El carácter en el índice -2 es n.
Cambiar el carácter en el índice -3 a o da strong.
]]>
     </screen>
    </example>

    <simpara>
     Para todo lo que es más complejo, la
     <link linkend="language.types.string.parsing.advanced">sintaxis avanzada</link>
     debe ser utilizada.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.advanced">
    <title>Sintaxis avanzada (sintaxis de llaves)</title>

    <simpara>
     La sintaxis avanzada permite la interpolación de
     <emphasis>variables</emphasis> con accesorios arbitrarios.
    </simpara>

    <simpara>
     Cualquier variable escalar, elemento de array o propiedad de objeto
     (<modifier>estática</modifier> o no) con una representación
     <type>string</type> puede ser incluida mediante esta sintaxis.
     La expresión es escrita de la misma manera que aparecería fuera de la
     <type>string</type>, luego encerrada entre <literal>{</literal> y
     <literal>}</literal>. Dado que <literal>{</literal> no puede ser escapado, esta
     sintaxis solo será reconocida cuando el <literal>$</literal> siga inmediatamente al
     <literal>{</literal>. Utilice <literal>{\$</literal> para obtener un
     <literal>{$</literal>. Aquí hay algunos ejemplos para aclarar:
    </simpara>

     <example>
     <title>Sintaxis con llaves</title>
     <programlisting role="php">
<![CDATA[
<?php
const DATA_KEY = 'const-key';
$great = 'fantástico';
$arr = [
    '1',
    '2',
    '3',
    [41, 42, 43],
    'key' => 'Valor indexado',
    'const-key' => 'Clave con un signo menos',
    'foo' => ['foo1', 'foo2', 'foo3']
];

// No funcionará, mostrará: Esto es { fantástico}
echo "Esto es { $great}";

// Funciona, mostrará: Esto es fantástico
echo "Esto es {$great}";

class Square {
    public $width;

    public function __construct(int $width) { $this->width = $width; }
}

$square = new Square(5);

// Funciona
echo "Este cuadrado mide {$square->width}00 centímetros de ancho.";

// Funciona, las claves entre comillas solo funcionan con la sintaxis de llaves
echo "Esto funciona: {$arr['key']}";

// Funciona
echo "Esto funciona: {$arr[3][2]}";

echo "Esto funciona: {$arr[DATA_KEY]}";

// Al utilizar arrays multidimensionales, siempre use llaves alrededor de los arrays
// cuando estén dentro de strings
echo "Esto funciona: {$arr['foo'][2]}";

echo "Esto funciona: {$obj->values[3]->name}";

echo "Esto funciona: {$obj->$staticProp}";

// No funcionará, mostrará: C:\directory\{fantástico}.txt
echo "C:\directory\{$great}.txt";

// Funciona, mostrará: C:\directory\fantástico.txt
echo "C:\\directory\\{$great}.txt";
?>
]]>
     </programlisting>
    </example>

    <note>
     <simpara>
      Como esta sintaxis permite expresiones arbitrarias, es posible utilizar
      <link linkend="language.variables.variable">variables de variables</link>
      en la sintaxis avanzada.
     </simpara>
    </note>
   </sect4>
  </sect3>

  <sect3 xml:id="language.types.string.substr">
   <title>Acceso y modificación de string por carácter</title>

   <para>
    Los caracteres en los <type>strings</type> pueden ser accedidos y modificados especificando
    el offset basado en cero del carácter deseado después del
    <type>string</type> utilizando corchetes <type>array</type>, como en
    <varname>$str[42]</varname>. Piense en un <type>string</type> como un
    <type>array</type> de caracteres para este propósito. Las funciones
    <function>substr</function> y <function>substr_replace</function>
    pueden ser utilizadas cuando se desea extraer o reemplazar más de un carácter.
   </para>

   <note>
    <simpara>
     Desde PHP 7.1.0, los offsets de string negativos también son soportados. Estos especifican
     el offset desde el final del string.
     Anteriormente, los offsets negativos emitían <constant>E_NOTICE</constant> para la lectura
     (produciendo un string vacío) y <constant>E_WARNING</constant> para la escritura
     (dejando el string intacto).
    </simpara>
   </note>

   <note>
    <simpara>
     Antes de PHP 8.0.0, los <type>strings</type> también podían ser accedidos utilizando llaves, como en
     <varname>$str{42}</varname>, para el mismo propósito.
     Esta sintaxis de llaves fue deprecada desde PHP 7.4.0 y ya no es soportada desde PHP 8.0.0.
    </simpara>
   </note>

   <warning>
    <simpara>
     Escribir en un offset fuera de alcance llena el string con espacios.
     Los tipos no enteros son convertidos a entero.
     Un tipo de offset ilegal emite <constant>E_WARNING</constant>.
     Solo el primer carácter de un string asignado es utilizado.
     Desde PHP 7.1.0, asignar un string vacío genera un error fatal. Anteriormente,
     esto asignaba un octeto NULL.
    </simpara>
   </warning>

   <warning>
    <simpara>
     Internamente, los strings PHP son arrays de octetos. En consecuencia, acceder o
     modificar un string utilizando corchetes de array no es seguro para multi-octetos, y
     solo debe hacerse con strings en codificación de un solo octeto como ISO-8859-1.
    </simpara>
   </warning>

   <note>
    <simpara>
     Desde PHP 7.1.0, aplicar el operador de índice vacío a un string vacío genera un error fatal.
     Anteriormente, el string vacío era silenciosamente convertido a array.
    </simpara>
   </note>

   <example>
    <title>Algunos ejemplos de strings</title>
    <programlisting role="php">
<![CDATA[
<?php
// Obtener el primer carácter de un string
$str = 'Esto es una prueba.';
$first = $str[0];
var_dump($first);

// Obtener el tercer carácter de un string
$third = $str[2];
var_dump($third);

// Obtener el último carácter de un string.
$str = 'Esto sigue siendo una prueba.';
$last = $str[strlen($str)-1];
var_dump($last);

// Modificar el último carácter de un string
$str = 'Mire el mar';
$str[strlen($str)-1] = 'e';
var_dump($str);
?>
]]>
    </programlisting>
   </example>

   <para>
    Los offsets de string deben ser enteros o strings que parezcan enteros,
    de lo contrario se emitirá una advertencia.
   </para>

   <example>
    <title>Ejemplo de offsets de string ilegales</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = 'abc';

foreach ($keys as $keyToTry) {
    var_dump(isset($str[$keyToTry]));

    try {
        var_dump($str[$keyToTry]);
    } catch (TypeError $e) {
        echo $e->getMessage(), PHP_EOL;
    }

    echo PHP_EOL;
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
string(1) "b"

bool(false)
Cannot access offset of type string on string

bool(false)
Cannot access offset of type string on string

bool(false)

Warning: Illegal string offset "1x" in Standard input code on line 10
string(1) "b"
]]>
    </screen>
   </example>

   <note>
    <para>
     Acceder a variables de otros tipos (excepto arrays u objetos
     que implementen las interfaces apropiadas) utilizando <literal>[]</literal> o
     <literal>{}</literal> devuelve silenciosamente &null;.
    </para>
   </note>

   <note>
    <para>
     Los caracteres en literales de string pueden ser accedidos
     utilizando <literal>[]</literal> o <literal>{}</literal>.
    </para>
   </note>

   <note>
    <para>
     Acceder a caracteres en literales de string utilizando la
     sintaxis <literal>{}</literal> fue deprecada en PHP 7.4.
     Esto fue eliminado en PHP 8.0.
    </para>
   </note>
  </sect3>
 </sect2><!-- fin de la sintaxis -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Funciones y operadores útiles</title>

  <para>
   Los <type>strings</type> pueden ser concatenados utilizando el operador '.' (punto). Tenga en cuenta
   que el operador '+' (suma) <emphasis>no</emphasis> funcionará para esto.
   Consulte <link linkend="language.operators.string">los operadores de string</link> para
   más información.
  </para>

  <para>
   Existen varias funciones útiles para la manipulación de <type>strings</type>.
  </para>

  <simpara>
   Consulte la <link linkend="ref.strings">sección de funciones de string</link> para
   funciones generales, y la <link linkend="ref.pcre">sección de funciones de expresiones regulares compatibles con Perl</link> para
   funcionalidades avanzadas de búsqueda y reemplazo.
  </simpara>

  <simpara>
   También existen <link linkend="ref.url">funciones para strings de URL</link>, y
   funciones para cifrar/descifrar strings
   (<link linkend="ref.sodium">Sodium</link> y
   <link linkend="ref.hash">Hash</link>).
  </simpara>

  <simpara>
   Finalmente, consulte también las <link linkend="ref.ctype">funciones de tipo de carácter</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Conversión a string</title>

  <para>
   Un valor puede ser convertido a <type>string</type> utilizando el
   cast <literal>(string)</literal> o la función <function>strval</function>.
   La conversión a <type>string</type> es realizada automáticamente en el contexto de una
   expresión donde un <type>string</type> es necesario. Esto ocurre al utilizar las
   funciones <function>echo</function> o <function>print</function>, o cuando
   una variable es comparada con un <type>string</type>. Las secciones sobre
   <link linkend="language.types">Tipos</link> y
   <link linkend="language.types.type-juggling">Type Juggling</link> aclararán
   lo siguiente. Ver también la función <function>settype</function>.
  </para>

  <para>
   Un valor <type>bool</type> &true; es convertido al <type>string</type>
   <literal>"1"</literal>. El <type>bool</type> &false; es convertido a
   <literal>""</literal> (el string vacío). Esto permite una conversión de ida y vuelta entre
   los valores <type>bool</type> y <type>string</type>.
  </para>

  <para>
   Un <type>int</type> o <type>float</type> es convertido a un
   <type>string</type> representando el número textualmente (incluyendo la
   parte exponencial para los <type>float</type>). Los números de punto flotante pueden ser
   convertidos utilizando la notación exponencial (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    A partir de PHP 8.0.0, el carácter de la coma decimal es siempre
    un punto ("<literal>.</literal>"). Antes de PHP 8.0.0,
    el carácter de la coma decimal está definido en la localización del script (categoría
    LC_NUMERIC). Consulte la función <function>setlocale</function>.
   </para>
  </note>

  <para>
   Los <type>arrays</type> siempre son convertidos al <type>string</type>
   <literal>"Array"</literal>; por lo tanto, <function>echo</function> y
   <function>print</function> no pueden por sí solos mostrar el contenido de un
   <type>array</type>. Para mostrar un solo elemento, utilice una construcción como
   <literal>echo $arr['foo']</literal>. Consulte a continuación consejos para visualizar todo el contenido.
  </para>

  <para>
   Para convertir <type>objetos</type> a <type>strings</type>, el método mágico
   <link linkend="language.oop5.magic">__toString</link> debe ser utilizado.
  </para>

  <para>
   Los <type>recursos</type> siempre son convertidos a <type>strings</type> con la
   estructura <literal>"Resource id #1"</literal>, donde <literal>1</literal>
   es el número de recurso asignado al <type>recurso</type> por PHP en
   tiempo de ejecución. Aunque la estructura exacta de este string no debe ser considerada como
   confiable y está sujeta a cambios, siempre será única para un recurso dado
   durante la duración de ejecución de un script (es decir, una solicitud web o un proceso CLI)
   y no será reutilizada. Para obtener el tipo de un <type>recurso</type>, utilice
   la función <function>get_resource_type</function>.
  </para>

  <para>
   &null; siempre es convertido a un string vacío.
  </para>

  <para>
   Como se indicó anteriormente, convertir directamente un <type>array</type>,
   un <type>objeto</type> o un <type>recurso</type> a <type>string</type> no proporciona
   información útil sobre el valor más allá de su tipo. Consulte las funciones
   <function>print_r</function> y <function>var_dump</function> para
   medios más eficaces de inspeccionar el contenido de estos tipos.
  </para>

  <para>
   La mayoría de los valores PHP también pueden ser convertidos a <type>strings</type> para un almacenamiento permanente.
   Este método se denomina serialización y es realizado por la función
   <function>serialize</function>.
  </para>

 </sect2>
<sect2 xml:id="language.types.string.details">

  <title>Detalles del tipo string</title>

  <para>
   El <type>string</type> en PHP está implementado como un array de octetos y un
   entero indicando la longitud del búfer. No tiene ninguna información sobre cómo
   estos octetos se traducen en caracteres, dejando esta tarea al programador.
   No hay limitaciones sobre los valores de los que el string puede estar compuesto; en
   particular, los octetos de valor <literal>0</literal> («octetos NUL») son permitidos
   en cualquier parte del string (aunque algunas funciones, dichas en este manual de no
   ser «seguras para binarios», pueden pasar los strings a bibliotecas
   que ignoran los datos después de un octeto NUL.)
  </para>
  <para>
   Esta naturaleza del tipo string explica por qué no hay un tipo «octeto» distinto
   en PHP - los strings toman este rol. Las funciones que no devuelven datos
   textuales - por ejemplo, datos arbitrarios leídos desde un socket de red -
   devolverán strings de todos modos.
  </para>
  <para>
   Dado que PHP no dicta una codificación específica para los strings, uno podría
   preguntarse cómo los literales de string están codificados. Por ejemplo, el string
   <literal>"á"</literal> ¿es equivalente a <literal>"\xE1"</literal> (ISO-8859-1),
   <literal>"\xC3\xA1"</literal> (UTF-8, forma C),
   <literal>"\x61\xCC\x81"</literal> (UTF-8, forma D) o cualquier otra representación
   posible? La respuesta es que el string será codificado de la manera en que está
   codificado en el archivo de script. Por lo tanto, si el script está escrito en ISO-8859-1, el
   string será codificado en ISO-8859-1 y viceversa. Sin embargo, esto no se aplica
   si Zend Multibyte está activado; en este caso, el script puede estar escrito en una
   codificación arbitraria (que es explícitamente declarada o detectada) y luego convertido
   a una cierta codificación interna, que luego será la codificación utilizada para los
   literales de string.
   Tenga en cuenta que hay ciertas restricciones sobre la codificación del script (o sobre la codificación
   interna, si Zend Multibyte está activado) - esto significa casi siempre que esta
   codificación debe ser un superconjunto compatible con ASCII, como UTF-8 o ISO-8859-1.
   Tenga en cuenta, sin embargo, que las codificaciones dependientes del estado donde las mismas
   valores de octeto pueden ser utilizados en estados de desplazamiento iniciales y no iniciales
   pueden causar problemas.
  </para>
  <para>
   Por supuesto, para ser útiles, las funciones que operan sobre texto pueden necesitar
   hacer ciertas suposiciones sobre cómo el string está codificado. Desafortunadamente,
   hay muchas variaciones en este sentido en las funciones de PHP:
  </para>
  <itemizedlist>
   <listitem>
    <simpara>
     Algunas funciones asumen que el string está codificado en un (todo) conjunto de codificación de un octeto, pero no necesitan interpretar estos octetos como caracteres específicos. Este es el caso, por ejemplo, de <function>substr</function>,
     <function>strpos</function>, <function>strlen</function> o
     <function>strcmp</function>. Otra forma de pensar en estas funciones es que operan sobre búferes de memoria, es decir, que trabajan con octetos y desplazamientos de octetos.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Otras funciones reciben la codificación del string, asumiendo posiblemente un valor predeterminado si no se proporciona información de este tipo. Este es el caso de
     <function>htmlentities</function> y la mayoría de las funciones en
     la <link linkend="book.mbstring">extensión mbstring</link>.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Otras utilizan la localización actual (ver <function>setlocale</function>),
     pero funcionan octeto por octeto.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Finalmente, pueden simplemente asumir que el string utiliza una codificación
     específica, generalmente UTF-8. Este es el caso de la mayoría de las funciones en
     la <link linkend="book.intl">extensión intl</link> y en
     la <link linkend="book.pcre">extensión PCRE</link>
     (en este último caso, solo cuando se utiliza el modificador <literal>u</literal>).
    </simpara>
   </listitem>
  </itemizedlist>

  <para>
   En última instancia, esto significa que escribir programas correctos que utilicen
   Unicode depende de evitar cuidadosamente las funciones que no funcionarán y
   que probablemente corromperán los datos, y de utilizar en su lugar las
   funciones que se comportan correctamente, generalmente provenientes de las extensiones
   <link linkend="book.intl">intl</link> y <link linkend="book.mbstring">mbstring</link>.
   Sin embargo, utilizar funciones capaces de manejar codificaciones Unicode es solo el comienzo. Independientemente de las funciones que el lenguaje proporciona, es esencial conocer la especificación Unicode. Por ejemplo, un programa que asume que solo hay mayúsculas y minúsculas hace una suposición errónea.
  </para>
 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
