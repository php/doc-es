<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: d332b5ae70bd27873fa1b51b366a721957042e69 Maintainer: seros Status: ready -->
<!-- Reviewed: no Maintainer: andresdzphp -->

<sect1 xml:id="language.types.array">
 <title>Arrays</title>

 <para>
  Un <type>array</type> en PHP es en realidad un mapa ordenado. Un mapa es un tipo de
  datos que asocia <emphasis>valores</emphasis> con <emphasis>claves</emphasis>. Este tipo
  se optimiza para varios usos diferentes; se puede emplear como un array,
  lista (vector), tabla asociativa (tabla hash - una implementación de un mapa), diccionario,
  colección, pila, cola, y posiblemente más. Ya que los valores de un <type>array</type>
  pueden ser otros <type>array</type>s, también son posibles árboles y <type>array</type>s
  multidimensionales.
 </para>

 <para>
  Una explicación sobre tales estructuras de datos está fuera del alcance de este manual,
  aunque se proporciona al menos un ejemplo de cada uno de ellos. Para más información,
  consulte la extensa literatura que existe sobre este amplio tema.
 </para>

 <sect2 xml:id="language.types.array.syntax">
  <title>Sintaxis</title>

  <sect3 xml:id="language.types.array.syntax.array-func">
   <title>Especificación con <function>array</function></title>

   <para>
    Un <type>array</type> puede ser creado con el constructor del lenguaje
    <function>array</function>. Éste toma cualquier número de parejas
    <literal><replaceable>clave</replaceable> =&gt; <replaceable>valor</replaceable></literal>
    como argumentos.
   </para>

   <synopsis>
    array(
    <optional><replaceable>clave</replaceable>  =&gt; </optional><replaceable>valor</replaceable>,
    <optional><replaceable>clave2</replaceable> =&gt; </optional><replaceable>valor2</replaceable>,
    <optional><replaceable>clave3</replaceable> =&gt; </optional><replaceable>valor3</replaceable>,
    ...
    )</synopsis>
   <!-- Do not fix the whitespace for the synopsis end element. A limitation of PhD prevents proper trimming -->

   <para>
    La coma después del último elemento del array es opcional, pudiéndose omitir. Esto normalmente se hace
    para arrays de una única línea, es decir, es preferible <literal>array(1, 2)</literal> que
    <literal>array(1, 2, )</literal>. Por otra parte, para arrays multilínea, la coma final
    se usa frecuentemente, ya que permite una adición más sencilla de nuevos elementos al final.
   </para>

   <para>
    A partir de PHP 5.4 también se puede usar la sintaxis de array corta, la cual reemplaza
    <literal>array()</literal> con <literal>[]</literal>.
   </para>

   <example>
    <title>Un array simple</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// a partir de PHP 5.4
$array = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
]]>
    </programlisting>
   </example>

   <para>
    La <replaceable>clave</replaceable> puede ser un <type>integer</type>
    o un <type>string</type>. El <replaceable>valor</replaceable> puede ser
    de cualquier tipo.
   </para>

   <para xml:id="language.types.array.key-casts">
    Además, se darán los siguientes amoldamientos de <replaceable>clave</replaceable>:
    <itemizedlist>
     <listitem>
     <simpara>
       <type>String</type>s que contiene un decimal válido <type>integer</type>, a menos que el número esté precedido por un signo <literal>+</literal>, será amoldado al
       tipo <type>integer</type>. Por ejemplo, la llave <literal>"8"</literal> será en realidad
       almacenado como <literal>8</literal>. Por otro lado <literal>"08"</literal> no será
       moldeado, ya que no es un entero decimal válido.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Un <type>float</type>s también será amoldado a <type>integer</type>, lo que significa que la
       parte fraccionaria se elimina. P.ej., la clave <literal>8.7</literal> en realidad será
       almacenada como <literal>8</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Un <type>bool</type>eano son amoldados a <type>integer</type>s también, es decir, la clave
       <literal>true</literal> en realidad será almacenada como <literal>1</literal>
       y la clave <literal>false</literal> como <literal>0</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Un <type>null</type> será amoldado a un string vacío, es decir, la clave
       <literal>null</literal> en realidad será almacenada como <literal>""</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Los <type>array</type>s y los <type>object</type>s <emphasis>no pueden</emphasis> utilizarse como claves.
       Si se hace, dará lugar a una advertencia: <literal>Illegal offset type</literal>.
      </simpara>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Si varios elementos en la declaración del array usan la misma clave, sólo se utilizará
    la última, siendo los demás sobrescritos.
   </para>

   <example>
    <title>Ejemplo de amoldamiento de tipo y sobrescritura</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  [1]=>
  string(1) "d"
}
]]>
    </screen>
    <para>
     Como todas las claves en el ejemplo anterior se convierten en <literal>1</literal>, los valores serán sobrescritos
     en cada nuevo elemento, por lo que el último valor asignado <literal>"d"</literal> es el único que queda.
    </para>
   </example>

   <para>
    Los arrays de PHP pueden contener claves  <type>integer</type> y <type>string</type> al mismo tiempo
    ya que PHP no distingue entre arrays indexados y asociativos.
   </para>

   <example>
    <title>Claves mixtas <type>integer</type> y <type>string</type></title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
    100   => -100,
    -100  => 100,
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  ["foo"]=>
  string(3) "bar"
  ["bar"]=>
  string(3) "foo"
  [100]=>
  int(-100)
  [-100]=>
  int(100)
}
]]>
    </screen>
   </example>

   <para>
    La <replaceable>clave</replaceable> es opcional. Si no se especifica, PHP usará
    el incremento de la clave de tipo <type>integer</type> mayor utilizada anteriormente.
   </para>

   <example>
    <title>Arrays indexados sin clave</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array("foo", "bar", "hello", "world");
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(5) "hello"
  [3]=>
  string(5) "world"
}
]]>
    </screen>
   </example>

   <para>
    Es posible especificar la clave sólo para algunos elementos y excluir a los demás:
   </para>

   <example>
    <title>Claves no en todos los elementos</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
         "a",
         "b",
    6 => "c",
         "d",
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [6]=>
  string(1) "c"
  [7]=>
  string(1) "d"
}
]]>
    </screen>
    <para>
     Como se puede ver, al último valor <literal>"d"</literal> se le asignó la clave
     <literal>7</literal>. Esto es debido a que la mayor clave integer anterior era
     <literal>6</literal>.
    </para>
   </example>
  </sect3>

  <sect3 xml:id="language.types.array.syntax.accessing">
   <title>Acceso a elementos de array con la sintaxis de corchete</title>

   <para>
    Los elementos de array se pueden acceder utilizando la sintaxis <literal>array[key]</literal>.
   </para>

   <example>
    <title>Acceso a elementos de un array</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
         "dimensional" => array(
             "array" => "foo"
         )
    )
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["multi"]["dimensional"]["array"]);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(3) "bar"
int(24)
string(3) "foo"
]]>
    </screen>
   </example>

   <note>
    <para>
     Tanto los corchetes como las llaves pueden ser utilizados de forma intercambiable
     para acceder a los elementos de un array (p.ej.: <literal>$array[42]</literal> y <literal>$array{42}</literal>
     tendrán el mismo resultado en el ejemplo anterior).
    </para>
   </note>

   <para>
    A partir de PHP 5.4 es posible hacer referencia al array del resultado de una llamada a una función
    o método directamente. Antes sólo era posible utilizando una variable
    temporal.
   </para>

   <para>
    Desde PHP 5.5 es posible hacer referencia directa un elemento de un array literal.
   </para>

   <example>
    <title>Hacer referencia al resultado array de funciones</title>
    <programlisting role="php">
<![CDATA[
<?php
function getArray() {
    return array(1, 2, 3);
}

// en PHP 5.4
$secondElement = getArray()[1];

// anteriormente
$tmp = getArray();
$secondElement = $tmp[1];

// o
list(, $secondElement) = getArray();
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Intentar acceder a una clave de un array que no se ha definido es
     lo mismo que el acceder a cualquier otra variable no definida:
     se emitirá un mensaje de error de nivel <constant>E_NOTICE</constant>,
     y el resultado será &null;.
    </para>
   </note>
    <note>
    <para>
     Array que dereferencia un valor escalar que no es un <type>string</type>
     silenciosamente arroja &null;, es decir, sin emitir un mensaje de error.
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.array.syntax.modifying">
   <title>Creación/modificación con la sintaxis de corchete</title>

   <para>
    Un <type>array</type> existente puede ser modificado estableciendo explícitamente valores
    en él.
   </para>

   <para>
    Esto se realiza asignando valores al <type>array</type>, especificando la
    clave entre corchetes. Esta también se puede omitir, resultando en un par de
    corchetes vacíos (<literal>[]</literal>).
   </para>

   <synopsis>
    $arr[<replaceable>clave</replaceable>] = <replaceable>valor</replaceable>;
    $arr[] = <replaceable>valor</replaceable>;
    // <replaceable>clave</replaceable> puede ser un <type>integer</type> o un <type>string</type>
    // <replaceable>valor</replaceable> puede ser cualquier valor de cualquier tipo</synopsis>

   <para>
    Si <varname>$arr</varname> aún no existe, se creará, siendo también esta
    forma una alternativa de crear un <type>array</type>. Sin embargo, se
    desaconsejada esta práctica porque que si <varname>$arr</varname> ya contiene
    algún valor (p.ej. un <type>string</type> de una variable de petición), este
    estará en su lugar y <literal>[]</literal> puede significar realmente
    el <link linkend="language.types.string.substr">operador de acceso a
    strings</link>. Siempre es mejor inicializar variables mediante una asignación
    directa.
   </para>
    <note>
    <simpara>
     A partir de PHP 7.1.0, la aplicación del operador de índice vacío en un string lanza un fatal
     error. Antes, el string se convertía silenciosamente en un array.
    </simpara>
   </note>

   <para>
    Para cambiar un valor determinado
    se debe asignar un nuevo valor a ese elemento empleando su clave. Para quitar una
    pareja clave/valor, se debe llamar a la función <function>unset</function> con éste.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Esto es lo mismo que $arr[13] = 56;
                // en este punto de el script

$arr["x"] = 42; // Esto agrega un nuevo elemento a
                // el array con la clave "x"

unset($arr[5]); // Esto elimina el elemento del array

unset($arr);    // Esto elimina el array completo
?>
]]>
    </programlisting>
   </informalexample>

   <note>
    <para>
     Como se mencionó anteriormente, si no se especifica una clave, se toma el máximo
     de los índices <type>integer</type> existentes, y la nueva clave será ese valor
     máximo más 1 (aunque al menos 0). Si todavía no existen índices <type>integer</type>,
     la clave será <literal>0</literal> (cero).
    </para>

    <para>
     Tenga en cuenta que la clave integer máxima utilizada para éste <emphasis>no es necesario que
     actualmente exista en el <type>array</type></emphasis>. Ésta sólo debe haber existido en el
     <type>array</type> en algún momento desde la última vez que el <type>array</type> fué re-indexado.
     El siguiente ejemplo ilustra este comportamiento:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Crear un array simple.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Ahora elimina cada elemento, pero deja el mismo array intacto:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Agregar un elemento (note que la nueva clave es 5, en lugar de 0).
$array[] = 6;
print_r($array);

// Re-indexar:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
     </screen>
    </informalexample>

   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.array.useful-funcs">
  <title>Funciones útiles</title>

  <para>
   Hay un buen número de funciones útiles para trabajar con arrays. Véase la
   sección <link linkend="ref.array">funciones de array</link>.
  </para>

  <note>
   <para>
    La función <function>unset</function> permite remover claves de un
    <type>array</type>. Tenga en cuenta que el array <emphasis>no</emphasis> es
    re-indexado. Si se desea un verdadero comportamiento "eliminar y desplazar", el
    <type>array</type> puede ser re-indexado usando la función <function>array_values</function>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'uno', 2 => 'dos', 3 => 'tres');
unset($a[2]);
/* producirá un array que se ha definido como
   $a = array(1 => 'uno', 3 => 'tres');
   y NO
   $a = array(1 => 'uno', 2 =>'tres');
*/

$b = array_values($a);
// Ahora $b es array(0 => 'uno', 1 =>'tres')
?>
]]>
    </programlisting>
   </informalexample>
  </note>

  <para>
   La estructura de control &foreach;
   existe específicamente para <type>array</type>s. Ésta provee una manera fácil
   de recorrer un <type>array</type>.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.donts">
  <title>Recomendaciones sobre arrays y cosas a evitar</title>

  <sect3 xml:id="language.types.array.foo-bar">
   <title>¿Por qué es incorrecto <literal>$foo[bar]</literal>?</title>

   <para>
    Siempre deben usarse comillas alrededor de un índice de array tipo
    string literal. Por ejemplo, <literal>$foo['bar']</literal> es correcto,
    mientras que <literal>$foo[bar]</literal> no lo es. ¿Pero por qué? Es
    común encontrar este tipo de sintaxis en scripts viejos:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto está mal, pero funciona. La razón es que este código tiene una constante
    indefinida (<literal>bar</literal>) en lugar de un <type>string</type> (<literal>'bar'</literal> - observe las
    comillas). Funciona porque PHP automáticamente convierte un
    <emphasis>string puro</emphasis> (un <type>string</type> sin comillas que no
    corresponde con ningún símbolo conocido) en un <type>string</type> que contiene el
    <type>string</type> puro. Por ejemplo, si no se ha definido una constante llamada
    <constant>bar</constant>, entonces PHP reemplazará su valor por el
    <type>string</type> <literal>'bar'</literal> y usará éste último.
   </para>
   <warning>
    <simpara>
     La alternativa de tratar una constante indefinida como string vacío está obsoleto a partir
     de PHP 7.2.0, y emite un error de nivel <constant>E_WARNING</constant>.
     Anteriormente, un error de nivel <constant>E_NOTICE</constant> era emitido.
    </simpara>
   </warning>

   <note>
    <simpara>
     Esto no quiere decir que <emphasis>siempre</emphasis> haya que usar
     comillas en la clave. No use comillas con claves que sean <link linkend="language.constants">constantes</link> o
     <link linkend="language.variables">variables</link>, ya que en tal caso PHP
     no podrá interpretar sus valores.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Array simple:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nRevisando $i: \n";
    echo "Mal: " . $array['$i'] . "\n";
    echo "Bien: " . $array[$i] . "\n";
    echo "Mal: {$array['$i']}\n";
    echo "Bien: {$array[$i]}\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    &example.outputs;
    <screen>
<![CDATA[
Revisando 0:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal:
Bien: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal:
Bien: 1

Revisando 1:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal:
Bien: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal:
Bien: 2
]]>
    </screen>
   </note>

   <para>
    Más ejemplos para demostrar este comportamiento:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Mostrar todos los errores
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Correcto
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Incorrecto. Esto funciona pero también genera un error de PHP de
// nivel E_NOTICE ya que no hay definida una constante llamada fruit
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Esto define una constante para demostrar lo que pasa. El valor 'veggie'
// es asignado a una constante llamada fruit.
define('fruit', 'veggie');

// Note la diferencia ahora
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// Lo siguiente está bien ya que se encuentra al interior de una cadena. Las constantes no son procesadas al
// interior de cadenas, así que no se produce un error E_NOTICE aquí
print "Hello $arr[fruit]";      // Hello apple

// Con una excepción, los corchetes que rodean las matrices al
// interior de cadenas permiten el uso de constantes
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// Esto no funciona, resulta en un error de intérprete como:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Esto por supuesto se aplica también al uso de superglobales en cadenas
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// La concatenación es otra opción
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Cuando se habilita <link linkend="ini.error-reporting">error_reporting</link> para mostrar
    errores de nivel <constant>E_NOTICE</constant> (como por ejemplo
    definiendo el valor <constant>E_ALL</constant>), este tipo de usos serán
    inmediatamente visibles. Por omisión, <link linkend="ini.error-reporting">error_reporting</link> se encuentra
    configurado para no mostrarlos.
   </para>

   <para>
    Tal y como se indica en la sección de <link linkend="language.types.array.syntax">sintaxis</link>, lo que existe
    entre los corchetes cuadrados ('<literal>[</literal>' y '<literal>]</literal>') debe ser una expresión. Esto quiere decir que
    código como el siguiente funciona:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Este es un ejemplo del uso de un valor devuelto por una función como índice del array. PHP
    también conoce las constantes:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "Un error fatal ha ocurrido";
$error_descriptions[E_WARNING] = "PHP produjo una advertencia";
$error_descriptions[E_NOTICE]  = "Esta es una noticia informal";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Note que <constant>E_ERROR</constant> es también un identificador válido,
    asi como <literal>bar</literal> en el primer ejemplo. Pero el último
    ejemplo es equivalente a escribir:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Un error fatal ha ocurrido";
$error_descriptions[2] = "PHP produjo una advertencia";
$error_descriptions[8] = "Esta es una noticia informal";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    ya que <constant>E_ERROR</constant> es igual a <literal>1</literal>, etc.
   </para>

   <sect4 xml:id="language.types.array.foo-bar.why">
    <title>¿Entonces porqué está mal?</title>

    <para>
     En algún momento en el futuro, puede que el equipo de PHP quiera usar
     otra constante o palabra clave, o una constante proveniente de otro
     código puede interferir.  Por ejemplo, en este momento no puede usar
     las palabras <literal>empty</literal> y <literal>default</literal> de
     esta forma, ya que son <link linkend="reserved">palabras clave reservadas</link>.
    </para>

    <note>
     <simpara>
      Reiterando, al interior de un valor <type>string</type> entre comillas
      dobles, es válido no rodear los índices de array con comillas, así
      que <literal>"$foo[bar]"</literal> es válido. Consulte los ejemplos
      anteriores para más detalles sobre el porqué, así como la sección
      sobre <link linkend="language.types.string.parsing">procesamiento de variables
      en cadenas</link>.
     </simpara>
    </note>

   </sect4>
  </sect3>
 </sect2>

 <sect2 xml:id="language.types.array.casting">
  <title>Conversión a array</title>

  <para>
   Para cualquiera de los tipos <type>integer</type>, <type>float</type>,
   <type>string</type>, <type>boolean</type> y <type>resource</type>,
   convertir un valor a un <type>array</type> resulta en un array con un
   solo elemento, con índice 0, y el valor del escalar que fue convertido.
   En otras palabras, <literal>(array)$scalarValue</literal> es exactamente
   lo mismo que <literal>array($scalarValue)</literal>.
  </para>

  <para>
   Si convierte un <type>object</type> a un <type>array</type>, el resultado
   es un <type>array</type> cuyos elementos son las propiedades del <type>object</type>. Las claves
   son los nombres de las variables miembro, con algunas excepciones
   notables: las variables privadas tienen el nombre de la clase al comienzo
   del nombre de la variable; las variables protegidas tienen un caracter
   '*' al comienzo del nombre de la variable. Estos valores adicionados al
   inicio tienen bytes <literal>NUL</literal> a los lados.
   Las <link linkend="language.oop5.properties.typed-properties">propiedades tipificadas</link> no inicializadas
   se descartan silenciosamente.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class A {
    private $A; //  Este campo se convertirá en '\0A\0A'
}

class B extends A {
    private $A; // Este campo se convertirá en '\0B\0A'
    public $AA; // Este campo se convertirá en 'AA'
}

var_dump((array) new B());
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   En el ejemplo anterior parecerá que se tienen dos claves llamadas 'AA',
   aunque en realidad una de ellas se llama '\0A\0A'.
  </para>

  <para>
   Si convierte un valor &null; a <type>array</type>, obtiene un
   <type>array</type> vacío.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.comparing">
  <title>Comparación</title>

  <para>
   Es posible comparar arrays con la función <function>array_diff</function> y mediante
   <link linkend="language.operators.array">operadores de arrays</link>.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.unpacking">
  <title>Array unpacking</title>

  <para>
   An array prefixed by <code>...</code> will be expanded in place during array definition.
   Only arrays and objects which implement <interfacename>Traversable</interfacename> can be expanded.
   Array unpacking with <code>...</code> is available as of PHP 7.4.0.
  </para>

  <para>
   It's possible to expand multiple times, and add normal elements before or after the <code>...</code> operator:

   <example>
    <title>Simple array unpacking</title>
    <programlisting role="php">
<![CDATA[
<?php
// Using short array syntax.
// Also, works with array() syntax.
$arr1 = [1, 2, 3];
$arr2 = [...$arr1]; //[1, 2, 3]
$arr3 = [0, ...$arr1]; //[0, 1, 2, 3]
$arr4 = [...$arr1, ...$arr2, 111]; //[1, 2, 3, 1, 2, 3, 111]
$arr5 = [...$arr1, ...$arr1]; //[1, 2, 3, 1, 2, 3]

function getArr() {
  return ['a', 'b'];
}
$arr6 = [...getArr(), 'c' => 'd']; //['a', 'b', 'c' => 'd']
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   Unpacking an array with the <code>...</code> operator follows the semantics of the <function>array_merge</function> function.
   That is, later string keys overwrite earlier ones and integer keys are renumbered:

   <example>
    <title>Array unpacking with duplicate key</title>
    <programlisting role="php">
<![CDATA[
<?php
// string key
$arr1 = ["a" => 1];
$arr2 = ["a" => 2];
$arr3 = ["a" => 0, ...$arr1, ...$arr2];
var_dump($arr3); // ["a" => 2]

// integer key
$arr4 = [1, 2, 3];
$arr5 = [4, 5, 6];
$arr6 = [...$arr4, ...$arr5];
var_dump($arr6); // [1, 2, 3, 4, 5, 6]
// Which is [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]
// where the original integer keys have not been retained.
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <para>
    Keys that are neither integers nor strings throw a <classname>TypeError</classname>.
    Such keys can only be generated by a <interfacename>Traversable</interfacename> object.
   </para>
  </note>
  <note>
   <para>
    Prior to PHP 8.1, unpacking an array which has a string key is not supported:
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

$arr1 = [1, 2, 3];
$arr2 = ['a' => 4];
$arr3 = [...$arr1, ...$arr2];
// Fatal error: Uncaught Error: Cannot unpack array with string keys in example.php:5

$arr4 = [1, 2, 3];
$arr5 = [4, 5];
$arr6 = [...$arr4, ...$arr5]; // works. [1, 2, 3, 4, 5]
?>
]]>
    </programlisting>
   </informalexample>
  </note>

 </sect2>

 <sect2 xml:id="language.types.array.examples">
  <title>Ejemplos</title>

  <para>
   El tipo array en PHP es bastante versátil. Aquí hay algunos ejempos:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// Esto:
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
            4        // la clave será 0
          );

$b = array('a', 'b', 'c');

// . . .es completamente equivalente a
$a = array();
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // la clave será 0

$b = array();
$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// Después de que se ejecute el código, $a será el array
// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',
// 'name' => 'apple', 0 => 4), y $b será el array
// array(0 => 'a', 1 => 'b', 2 => 'c'), o simplemente array('a', 'b', 'c').
?>
]]>
   </programlisting>
  </informalexample>

  <example>
   <title>Uso de array()</title>
   <programlisting role="php">
<![CDATA[
<?php
// Array como mapa de propiedades
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );

// Keys estrictamente numéricas
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// esto es lo mismo que array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7,
                    'a'  =>  4,
                            11, // key = 6 (el índice entero máximo era 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // el valor 10 será reemplazado por 12
                  );

// array vacío
$empty = array();
?>
]]>
    <!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
   </programlisting>
  </example>

  <example xml:id="language.types.array.examples.loop">
   <title>Colección</title>
   <programlisting role="php">
<![CDATA[
<?php
$colors = array('rojo', 'azul', 'verde', 'amarillo');

foreach ($colors as $color) {
    echo "¿Le gusta el $color?\n";
}

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
¿Le gusta el rojo?
¿Le gusta el azul?
¿Le gusta el verde?
¿Le gusta el amarillo?
]]>
   </screen>
  </example>

  <para>
   Modificar los valores del <type>array</type> directamente es posible
   pasándolos por referencia.
  </para>

  <example xml:id="language.types.array.examples.changeloop">
   <title>Cambiando elemento en el bucle</title>
   <programlisting role="php">
<![CDATA[
<?php
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* se asegura de que escrituras subsiguientes a $color
no modifiquen el último elemento del arrays */

print_r($colors);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => ROJO
    [1] => AZUL
    [2] => VERDE
    [3] => AMARILLO
)
]]>
   </screen>
  </example>

  <para>
   Este ejemplo crea un array con base uno.
  </para>

  <example>
   <title>Índice con base 1</title>
   <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'Enero', 'Febrero', 'Marzo');
print_r($firstquarter);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [1] => 'Enero'
    [2] => 'Febrero'
    [3] => 'Marzo'
)
]]>
   </screen>
  </example>

  <example>
   <title>Llenado de un array</title>
   <programlisting role="php">
<![CDATA[
<?php
// llenar un array con todos los ítems de un directorio
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle);
?>
]]>
   </programlisting>
  </example>

  <para>
   Los <type>Array</type>s son ordenados. El orden puede ser modificado usando varias
   funciones de ordenado. Vea la sección sobre <link linkend="ref.array">funciones de arrays</link>
   para más información. La función <function>count</function> puede ser usada para contar el
   número de elementos en un <type>array</type>.
  </para>

  <example>
   <title>Ordenado de un array</title>
   <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
   </programlisting>
  </example>

  <para>
   Dado que el valor de un <type>array</type> puede ser cualquier cosa, también puede
   ser otro <type>array</type>. De esta forma es posible crear <type>array</type>s
   recursivas y multi-dimensionales.
  </para>

  <example>
   <title>Arrays recursivos y multi-dimensionales</title>
   <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Algunos ejemplos que hacen referencia a los valores del array anterior
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Crear una nueva array multi-dimensional
$juices["apple"]["green"] = "good";
?>
]]>
   </programlisting>
  </example>

  <para>
   La asignación de <type>array</type>s siempre involucra la copia de valores. Use el
   <link linkend="language.operators">operador de referencia</link> para copiar
   un <type>array</type> por referencia.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 ha cambiado,
             // $arr1 sigue siendo array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // ahora $arr1 y $arr3 son iguales
?>
]]>
   </programlisting>
  </informalexample>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
