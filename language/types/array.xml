<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 22583751fbfdaa3eaa41aeb6470d1343f5cb2c78 Maintainer: seros Status: ready -->
<!-- Reviewed: no Maintainer: andresdzphp -->

<sect1 xml:id="language.types.array">
 <title>Arrays</title>

 <para>
  Un <type>array</type> en PHP es en realidad un mapa ordenado. Un mapa es un tipo de
  datos que asocia <emphasis>valores</emphasis> con <emphasis>claves</emphasis>. Este tipo
  se optimiza para varios usos diferentes; se puede emplear como un array,
  lista (vector), tabla asociativa (tabla hash - una implementación de un mapa), diccionario,
  colección, pila, cola, y posiblemente más. Ya que los valores de un <type>array</type>
  pueden ser otros <type>array</type>s, también son posibles árboles y <type>array</type>s
  multidimensionales.
 </para>

 <para>
  Una explicación sobre tales estructuras de datos está fuera del alcance de este manual,
  aunque se proporciona al menos un ejemplo de cada uno de ellos. Para más información,
  consulte la extensa literatura que existe sobre este amplio tema.
 </para>

 <sect2 xml:id="language.types.array.syntax">
  <title>Sintaxis</title>

  <sect3 xml:id="language.types.array.syntax.array-func">
   <title>Especificación con <function>array</function></title>

   <para>
    Un <type>array</type> puede ser creado con el constructor del lenguaje
    <function>array</function>. Éste toma cualquier número de parejas
    <literal><replaceable>clave</replaceable> =&gt; <replaceable>valor</replaceable></literal>,
    separados por comas, como argumentos.
   </para>

   <synopsis>
    array(
    <optional><replaceable>clave</replaceable>  =&gt; </optional><replaceable>valor</replaceable>,
    <optional><replaceable>clave2</replaceable> =&gt; </optional><replaceable>valor2</replaceable>,
    <optional><replaceable>clave3</replaceable> =&gt; </optional><replaceable>valor3</replaceable>,
    ...
    )</synopsis>
   <!-- Do not fix the whitespace for the synopsis end element. A limitation of PhD prevents proper trimming -->

   <para>
    La coma después del último elemento del array es opcional, pudiéndose omitir. Esto normalmente se hace
    para arrays de una única línea, es decir, es preferible <literal>array(1, 2)</literal> que
    <literal>array(1, 2, )</literal>. Por otra parte, para arrays multilínea, la coma final
    se usa frecuentemente, ya que permite una adición más sencilla de nuevos elementos al final.
   </para>

   <para>
    Existe una sintaxis de array corta, la cual reemplaza
    <literal>array()</literal> con <literal>[]</literal>.
   </para>

   <example>
    <title>Un array simple</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// Usando la sintaxis corta
$array = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
]]>
    </programlisting>
   </example>

   <para>
    La <replaceable>clave</replaceable> puede ser un <type>integer</type> (entero)
    o un <type>string</type> (una cadena de texto). El <replaceable>valor</replaceable>
    puede ser de cualquier tipo.
   </para>

   <para xml:id="language.types.array.key-casts">
    Además, se darán los siguientes amoldamientos de <replaceable>clave</replaceable>:
    <itemizedlist>
     <listitem>
      <simpara>
       <type>String</type>s que contiene un decimal válido <type>integer</type>, a menos que el número esté precedido por un signo <literal>+</literal>, será amoldado al
       tipo <type>integer</type>. Por ejemplo, la llave <literal>"8"</literal> será en realidad
       almacenado como <literal>8</literal>. Por otro lado <literal>"08"</literal> no será
       moldeado, ya que no es un entero decimal válido.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Un <type>float</type>s también será amoldado a <type>integer</type>, lo que significa que la
       parte fraccionaria se elimina. P.ej., la clave <literal>8.7</literal> en realidad será
       almacenada como <literal>8</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Un <type>bool</type>eano son amoldados a <type>integer</type>s también, es decir, la clave
       <literal>true</literal> en realidad será almacenada como <literal>1</literal>
       y la clave <literal>false</literal> como <literal>0</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Un <type>null</type> será amoldado a un string vacío, es decir, la clave
       <literal>null</literal> en realidad será almacenada como <literal>""</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Los <type>array</type>s y los <type>object</type>s <emphasis>no se pueden</emphasis>
       utilizar como claves.
       Si se hace, dará lugar a una advertencia: <literal>Illegal offset type</literal>.
      </simpara>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Si varios elementos en la declaración del array usan la misma clave, sólo se utilizará
    la última, siendo los demás sobrescritos.
   </para>

   <example>
    <title>Ejemplo de amoldamiento de tipo y sobrescritura</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  [1]=>
  string(1) "d"
}
]]>
    </screen>
    <para>
     Como todas las claves en el ejemplo anterior se convierten en <literal>1</literal>, los valores serán sobrescritos
     en cada nuevo elemento, por lo que el último valor asignado <literal>"d"</literal> es el único que queda.
    </para>
   </example>

   <para>
    Los arrays de PHP pueden contener claves <type>integer</type> y <type>string</type> al mismo tiempo
    ya que PHP no distingue entre arrays indexados y asociativos.
   </para>

   <example>
    <title>Claves mixtas <type>integer</type> y <type>string</type></title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
    100   => -100,
    -100  => 100,
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  ["foo"]=>
  string(3) "bar"
  ["bar"]=>
  string(3) "foo"
  [100]=>
  int(-100)
  [-100]=>
  int(100)
}
]]>
    </screen>
   </example>

   <para>
    La <replaceable>clave</replaceable> es opcional. Si no se especifica, PHP usará
    el incremento de la clave de tipo <type>integer</type> mayor utilizada anteriormente.
   </para>

   <example>
    <title>Arrays indexados sin clave</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array("foo", "bar", "hello", "world");
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(5) "hello"
  [3]=>
  string(5) "world"
}
]]>
    </screen>
   </example>

   <para>
    Es posible especificar la clave sólo para algunos elementos y excluir a los demás:
   </para>

   <example>
    <title>Claves no en todos los elementos</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
         "a",
         "b",
    6 => "c",
         "d",
);
var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [6]=>
  string(1) "c"
  [7]=>
  string(1) "d"
}
]]>
    </screen>
    <para>
     Como se puede ver, al último valor <literal>"d"</literal> se le asignó la clave
     <literal>7</literal>. Esto es debido a que la mayor clave integer anterior era
     <literal>6</literal>.
    </para>
   </example>

   <example>
    <title>Ejemplo de Conversión y Sobrescritura de tipos complejos</title>
    <para>
     Este ejemplo incluye todas las variaciones de conversión de tipos de claves
     y sobrescritura de elementos.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    1    => 'a',
    '1'  => 'b',  // El valor "a" será sobrescrito por "b"
    1.5  => 'c',  // El valor "b" será sobrescrito por "c"
    -1 => 'd',
    '01'  => 'e', // Al no tratarse de un entero en un string, este NO sobrescribirá la clave 1
    '1.5' => 'f', // Al no tratarse de un entero en un string, este NO sobrescribirá la clave 1
    true => 'g',  // El valor "c" será sobrescrito por "g"
    false => 'h',
    '' => 'i',
    null => 'j',  // El valor "i" será sobrescrito por "j"
    'k',          // El valor "k" será asignado a la clave 2. Esto es porque la clave entero más grande hasta el momento es 1
    2 => 'l',     // El valor "k" será sobrescrito por "l"
);

var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(7) {
  [1]=>
  string(1) "g"
  [-1]=>
  string(1) "d"
  ["01"]=>
  string(1) "e"
  ["1.5"]=>
  string(1) "f"
  [0]=>
  string(1) "h"
  [""]=>
  string(1) "j"
  [2]=>
  string(1) "l"
}
]]>
    </screen>
   </example>

   <example>
    <title>Ejemplo de índice negativo</title>
    <simpara>
     Cuando asignas una clave entera negativa <literal>n</literal>, PHP se encargará de
     asignar la siguiente clave a <literal>n+1</literal>.
    </simpara>
    <programlisting role="php">
     <![CDATA[
<?php
$array = [];

$array[-5] = 1;
$array[] = 2;

var_dump($array);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
     <![CDATA[
array(2) {
  [-5]=>
  int(1)
  [-4]=>
  int(2)
}
]]>
    </screen>

    <warning>
     <simpara>
      Antes de PHP 8.3.0, asignar una clave entera negativa <literal>n</literal>
      asignaría la siguiente clave a <literal>0</literal>, el ejemplo anterior
      por lo tanto mostraría:
     </simpara>
     <informalexample>
      <screen>
<![CDATA[
array(2) {
  [-5]=>
  int(1)
  [0]=>
  int(2)
}
]]>
      </screen>
     </informalexample>
    </warning>
   </example>
  </sect3>

  <sect3 xml:id="language.types.array.syntax.accessing">
   <title>Acceso a elementos de array con la sintaxis de corchete</title>

   <para>
    Los elementos de array se pueden acceder utilizando la sintaxis <literal>array[key]</literal>.
   </para>

   <example>
    <title>Acceso a elementos de un array</title>
    <programlisting role="php">
<![CDATA[
<?php
$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
         "dimensional" => array(
             "array" => "foo"
         )
    )
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["multi"]["dimensional"]["array"]);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(3) "bar"
int(24)
string(3) "foo"
]]>
    </screen>
   </example>

   <note>
    <para>
     Antes de PHP 8.0.0, tanto los corchetes como las llaves pueden ser utilizados de forma intercambiable
     para acceder a los elementos de un array (p.ej.: <literal>$array[42]</literal> y <literal>$array{42}</literal>
     tendrán el mismo resultado en el ejemplo anterior).
     La sintaxis de llaves se ha marcado como obsoleta en PHP 7.4.0 y se ha eliminado en PHP 8.0.0.
    </para>
   </note>

   <example>
    <title>Hacer referencia al resultado array de funciones</title>
    <programlisting role="php">
<![CDATA[
<?php
function getArray() {
    return array(1, 2, 3);
}

$secondElement = getArray()[1];
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Intentar acceder a una clave de un array que no se ha definido es
     lo mismo que el acceder a cualquier otra variable no definida:
     se emitirá un mensaje de error de nivel <constant>E_WARNING</constant>
     (<constant>E_NOTICE</constant> antes de PHP 8.0.0),
     y el resultado será &null;.
    </para>
   </note>
   <note>
    <para>
     Array que dereferencia un valor escalar que no es un <type>string</type>
     arroja &null;. Antes de PHP 7.4.0, sin emitir un mensaje de error.
     Desde PHP 7.4.0, emite un error de nivel <constant>E_NOTICE</constant>;
     desde PHP 8.0.0, emite un error de nivel <constant>E_WARNING</constant>;
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.array.syntax.modifying">
   <title>Creación/modificación con la sintaxis de corchete</title>

   <para>
    Un <type>array</type> existente puede ser modificado estableciendo explícitamente valores
    en él.
   </para>

   <para>
    Esto se realiza asignando valores al <type>array</type>, especificando la
    clave entre corchetes. La clave también se puede omitir, resultando en un par
    de corchetes vacíos (<literal>[]</literal>).
   </para>

   <synopsis>
    $arr[<replaceable>clave</replaceable>] = <replaceable>valor</replaceable>;
    $arr[] = <replaceable>valor</replaceable>;
    // <replaceable>clave</replaceable> puede ser un <type>integer</type> o un <type>string</type>
    // <replaceable>valor</replaceable> puede ser cualquier valor de cualquier tipo</synopsis>

   <para>
    Si <varname>$arr</varname> aún no existe, se creará, siendo también esta
    forma una alternativa de crear un <type>array</type>. Sin embargo, se
    desaconsejada esta práctica porque que si <varname>$arr</varname> ya contiene
    algún valor (p.ej. un <type>string</type> de una variable de petición), este
    estará en su lugar y <literal>[]</literal> puede significar realmente
    el <link linkend="language.types.string.substr">operador de acceso a
    strings</link>. Siempre es mejor inicializar variables mediante una asignación
    directa.
   </para>
    <note>
    <simpara>
     Desde PHP 7.1.0, aplicar el operador de índice vacío en un string lanza un error
     fatal. Antes, el string se convertía silenciosamente en un array.
    </simpara>
   </note>
   <note>
    <simpara>
     Desde PHP 8.1.0, la creación de un array a partir de &false; está obsoleta.
     Aún se permite crear un array a partir de &null; y valores no definidos.
    </simpara>
   </note>

   <para>
    Para cambiar un valor determinado se debe asignar un nuevo valor a ese elemento
    empleando su clave.
    Para quitar una pareja clave/valor, se debe llamar a la función <function>unset</function> con éste.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Esto es lo mismo que $arr[13] = 56;
                // en este punto de el script

$arr["x"] = 42; // Esto agrega un nuevo elemento a
                // el array con la clave "x"

unset($arr[5]); // Esto elimina el elemento del array

unset($arr);    // Esto elimina el array completo
?>
]]>
    </programlisting>
   </informalexample>

   <note>
    <para>
     Como se mencionó anteriormente, si no se especifica una clave, se toma el máximo
     de los índices <type>integer</type> existentes, y la nueva clave será ese valor
     máximo más 1 (aunque al menos 0). Si todavía no existen índices <type>integer</type>,
     la clave será <literal>0</literal> (cero).
    </para>

    <para>
     Tenga en cuenta que la clave integer máxima utilizada para éste <emphasis>no es necesario que
     actualmente exista en el <type>array</type></emphasis>. Ésta sólo debe haber existido en el
     <type>array</type> en algún momento desde la última vez que el <type>array</type> fué re-indexado.
     El siguiente ejemplo ilustra este comportamiento:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Crear un array simple.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Ahora elimina cada elemento, pero deja el mismo array intacto:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Agregar un elemento (note que la nueva clave es 5, en lugar de 0).
$array[] = 6;
print_r($array);

// Re-indexar:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
     </screen>
    </informalexample>

   </note>

  </sect3>

  <sect3 xml:id="language.types.array.syntax.destructuring">
   <title>Desestructuración de arrays</title>

   <para>
    Los arrays pueden ser desestructurados usando <literal>[]</literal>
    (desde PHP 7.1.0) o mediante el constructor de lenguaje <function>list</function>.
    Estos constructores se pueden utilizar para desestructurar un array en distintas variables.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$source_array = ['foo', 'bar', 'baz'];

[$foo, $bar, $baz] = $source_array;

echo $foo;    // Imprime "foo"
echo $bar;    // Imprime "bar"
echo $baz;    // Imprime "baz"
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    La desestructuración de arrays también puede ser utilizada en &foreach; para
    desestructurar un array multidimensional mientras se itera sobre él.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$source_array = [
    [1, 'John'],
    [2, 'Jane'],
];

foreach ($source_array as [$id, $name]) {
    // Aquí la lógica con $id y $name
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Se pueden ignorar elementos de un array al no proporcionar una variable.
    La desestructuración de arrays siempre comienza en el índice <literal>0</literal>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$source_array = ['foo', 'bar', 'baz'];

// Asignamos el elemento de índice 2 a la variable $baz
[, , $baz] = $source_array;

echo $baz;    // Imprime "baz"
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Desde PHP 7.1.0, los arrays asociativos también pueden ser desestructurados.
    Esto permite una selección más fácil del elemento correcto en arrays indexados
    Esto también permite una selección más fácil del elemento correcto en arrays indexados
    numéricamente, ya que el índice se puede especificar explícitamente.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$source_array = ['foo' => 1, 'bar' => 2, 'baz' => 3];

// Asignamos el elemento de índice 'baz' a la variable $three
['baz' => $three] = $source_array;

echo $three;    // Imprime 3

$source_array = ['foo', 'bar', 'baz'];

// Assign the element at index 2 to the variable $baz
[2 => $baz] = $source_array;

echo $baz;    // Imprime "baz"
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    La desestructuración de arrays se puede utilizar para intercambiar fácilmente dos variables.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

[$b, $a] = [$a, $b];

echo $a;    // Imprime 2
echo $b;    // Imprime 1
?>
]]>
    </programlisting>
   </informalexample>

   <note>
    <para>
      El operador <literal>spread</literal> de propagación (<literal>...</literal>)
      no se admite en las asignaciones.
    </para>
   </note>

   <note>
    <para>
     Intentar acceder a una clave de un array que no se ha definido es
     lo mismo que el acceder a cualquier otra variable no definida:
     se emitirá un mensaje de error de nivel <constant>E_WARNING</constant>
     (<constant>E_NOTICE</constant> antes de PHP 8.0.0),
     y el resultado será &null;.
    </para>
   </note>
  </sect3>

 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.array.useful-funcs">
  <title>Funciones útiles</title>

  <para>
   Hay un buen número de funciones útiles para trabajar con arrays. Véase la
   sección <link linkend="ref.array">funciones de array</link>.
  </para>

  <note>
   <para>
    La función <function>unset</function> permite eliminar claves de un
    <type>array</type>. Tenga en cuenta que el array <emphasis>no</emphasis> es
    re-indexado. Si se desea un verdadero comportamiento "eliminar y desplazar", el
    <type>array</type> puede ser re-indexado usando la función <function>array_values</function>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'uno', 2 => 'dos', 3 => 'tres');
unset($a[2]);
/* producirá un array que se ha definido como
   $a = array(1 => 'uno', 3 => 'tres');
   y NO
   $a = array(1 => 'uno', 2 =>'tres');
*/

$b = array_values($a);
// Ahora $b es array(0 => 'uno', 1 =>'tres')
?>
]]>
    </programlisting>
   </informalexample>
  </note>

  <para>
   La estructura de control &foreach; existe específicamente para <type>array</type>s.
   Ésta provee una manera fácil de recorrer un <type>array</type>.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.donts">
  <title>Recomendaciones sobre arrays y cosas a evitar</title>

  <sect3 xml:id="language.types.array.foo-bar">
   <title>¿Por qué es incorrecto <literal>$foo[bar]</literal>?</title>

   <para>
    Siempre deben usarse comillas alrededor de un índice de array tipo
    string literal. Por ejemplo, <literal>$foo['bar']</literal> es correcto,
    mientras que <literal>$foo[bar]</literal> no lo es. ¿Pero por qué? Es
    común encontrar este tipo de sintaxis en scripts viejos:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Esto está mal, pero funciona. La razón es que este código tiene una constante
    indefinida (<literal>bar</literal>) en lugar de un <type>string</type> (<literal>'bar'</literal> - observe las
    comillas). Funciona porque PHP automáticamente convierte un
    <emphasis>string puro</emphasis> (un <type>string</type> sin comillas que no
    corresponde con ningún símbolo conocido) en un <type>string</type> que contiene el
    <type>string</type> puro. Por ejemplo, si no se ha definido una constante llamada
    <constant>bar</constant>, entonces PHP reemplazará su valor por el
    <type>string</type> <literal>'bar'</literal> y usará éste último.
   </para>
   <warning>
    <simpara>
     La alternativa de tratar una constante indefinida como string vacío genera un error
     de nivel <constant>E_NOTICE</constant>.
     Este comportamiento está obsoleto desde PHP 7.2.0, y emite un error
     de nivel <constant>E_WARNING</constant>.
     Desde PHP 8.0.0, ha sido eliminado y lanza una
     excepción <classname>Error</classname>.
    </simpara>
   </warning>

   <note>
    <simpara>
     Esto no quiere decir que <emphasis>siempre</emphasis> haya que usar
     comillas en la clave. No use comillas con claves que sean <link linkend="language.constants">constantes</link> o
     <link linkend="language.variables">variables</link>, ya que en tal caso PHP
     no podrá interpretar sus valores.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Array simple:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nRevisando $i: \n";
    echo "Mal: " . $array['$i'] . "\n";
    echo "Bien: " . $array[$i] . "\n";
    echo "Mal: {$array['$i']}\n";
    echo "Bien: {$array[$i]}\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    &example.outputs;
    <screen>
<![CDATA[
Revisando 0:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal:
Bien: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal:
Bien: 1

Revisando 1:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mal:
Bien: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mal:
Bien: 2
]]>
    </screen>
   </note>

   <para>
    Más ejemplos para demostrar este comportamiento:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Mostrar todos los errores
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Correcto
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Incorrecto. Esto funciona pero también genera un error de PHP de
// nivel E_NOTICE ya que no hay definida una constante llamada fruit
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Esto define una constante para demostrar lo que pasa. El valor 'veggie'
// es asignado a una constante llamada fruit.
define('fruit', 'veggie');

// Note la diferencia ahora
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// Lo siguiente está bien ya que se encuentra al interior de una cadena. Las constantes no son procesadas al
// interior de cadenas, así que no se produce un error E_NOTICE aquí
print "Hello $arr[fruit]";      // Hello apple

// Con una excepción, los corchetes que rodean las matrices al
// interior de cadenas permiten el uso de constantes
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// La concatenación es otra opción
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
    </programlisting>
   </informalexample>
   <informalexample>
    <programlisting role="php">
<![CDATA[

// Esto no funciona, resulta en un error de intérprete como:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Esto por supuesto se aplica también al uso de superglobales en cadenas
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";
]]>
    </programlisting>
   </informalexample>

   <para>
    Cuando se habilita <link linkend="ini.error-reporting">error_reporting</link> para mostrar
    errores de nivel <constant>E_NOTICE</constant> (como por ejemplo
    definiendo el valor <constant>E_ALL</constant>), este tipo de usos serán
    inmediatamente visibles. Por omisión, <link linkend="ini.error-reporting">error_reporting</link> se encuentra
    configurado para no mostrarlos.
   </para>

   <para>
    Tal y como se indica en la sección de <link linkend="language.types.array.syntax">sintaxis</link>, lo que existe
    entre los corchetes cuadrados ('<literal>[</literal>' y '<literal>]</literal>') debe ser una expresión. Esto quiere decir que
    código como el siguiente funciona:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Este es un ejemplo del uso de un valor devuelto por una función como índice del array. PHP
    también conoce las constantes:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "Ha ocurrido un error fatal";
$error_descriptions[E_WARNING] = "PHP produjo una advertencia";
$error_descriptions[E_NOTICE]  = "Esta es una noticia informal";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Note que <constant>E_ERROR</constant> es también un identificador válido,
    asi como <literal>bar</literal> en el primer ejemplo. Pero el último
    ejemplo es equivalente a escribir:
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Ha ocurrido un error fatal";
$error_descriptions[2] = "PHP produjo una advertencia";
$error_descriptions[8] = "Esta es una noticia informal";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    ya que <constant>E_ERROR</constant> es igual a <literal>1</literal>, etc.
   </para>

   <sect4 xml:id="language.types.array.foo-bar.why">
    <title>¿Entonces porqué está mal?</title>

    <para>
     En algún momento en el futuro, puede que el equipo de PHP quiera usar
     otra constante o palabra clave, o una constante proveniente de otro
     código puede interferir.  Por ejemplo, en este momento no puede usar
     las palabras <literal>empty</literal> y <literal>default</literal> de
     esta forma, ya que son <link linkend="reserved">palabras clave reservadas</link>.
    </para>

    <note>
     <simpara>
      Reiterando, al interior de un valor <type>string</type> entre comillas
      dobles, es válido no rodear los índices de array con comillas, así
      que <literal>"$foo[bar]"</literal> es válido. Consulte los ejemplos
      anteriores para más detalles sobre el porqué, así como la sección
      sobre <link linkend="language.types.string.parsing">procesamiento de variables
      en cadenas</link>.
     </simpara>
    </note>

   </sect4>
  </sect3>
 </sect2>

 <sect2 xml:id="language.types.array.casting">
  <title>Conversión a array</title>

  <para>
   Para cualquiera de los tipos <type>integer</type>, <type>float</type>,
   <type>string</type>, <type>boolean</type> y <type>resource</type>,
   convertir un valor a un <type>array</type> resulta en un array con un
   solo elemento, con índice 0, y el valor del escalar que fue convertido.
   En otras palabras, <literal>(array)$scalarValue</literal> es exactamente
   lo mismo que <literal>array($scalarValue)</literal>.
  </para>

  <para>
   Si convierte un <type>object</type> a un <type>array</type>, el resultado
   es un <type>array</type> cuyos elementos son las propiedades del <type>object</type>. Las claves
   son los nombres de las variables miembro, con algunas excepciones
   notables: Las propiedades integer son inaccesibles;
   las variables privadas tienen el nombre de la clase al comienzo
   del nombre de la variable; las variables protegidas tienen un caracter
   '*' al comienzo del nombre de la variable. Estos valores adicionados al
   inicio tienen bytes <literal>NUL</literal> en cualquier lado.
   Las <link linkend="language.oop5.properties.typed-properties">propiedades tipificadas</link>
   no inicializadas se descartan silenciosamente.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class A {
    private $B;
    protected $C;
    public $D;
    function __construct()
    {
        $this->{1} = null;
    }
}

var_export((array) new A());
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
    <![CDATA[
array (
  '' . "\0" . 'A' . "\0" . 'B' => NULL,
  '' . "\0" . '*' . "\0" . 'C' => NULL,
  'D' => NULL,
  1 => NULL,
)
]]>
   </screen>
  </informalexample>

  <para>
   Estos <literal>NUL</literal> pueden generar algún comportamiento inesperado:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class A {
    private $A; // Esto se convertirá en '\0A\0A'
}

class B extends A {
    private $A; // Esto se convertirá en '\0B\0A'
    public $AA; // Esto se convertirá en 'AA'
}

var_dump((array) new B());
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
    <![CDATA[
array(3) {
  ["BA"]=>
  NULL
  ["AA"]=>
  NULL
  ["AA"]=>
  NULL
}
]]>
   </screen>
  </informalexample>

  <para>
   En el ejemplo anterior parecerá que se tienen dos claves llamadas 'AA',
   aunque en realidad una de ellas se llama '\0A\0A'.
  </para>

  <para>
   Si convierte un valor &null; a <type>array</type>, obtiene un
   <type>array</type> vacío.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.comparing">
  <title>Comparación</title>

  <para>
   Es posible comparar arrays con la función <function>array_diff</function> y mediante
   <link linkend="language.operators.array">operadores de arrays</link>.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.unpacking">
  <title>Desempaquetando arrays</title>

  <para>
   Un array precedido por <code>...</code> será expandido en su lugar durante la definición del array.
   Solo los arrays y objetos que implementan <interfacename>Traversable</interfacename> pueden ser expandidos.
   El desempaquetado de arrays con el operador <code>...</code> está disponible desde PHP 7.4.0.
  </para>

  <para>
   Es posible desempaquetar múltiples veces, y añadir elementos normales antes o después del operador <code>...</code>:

   <example>
    <title>Desempaquetado simple de array</title>
    <programlisting role="php">
<![CDATA[
<?php
// Utilizando la sintaxis corta.
// Tambien funciona con la sintaxis array().
$arr1 = [1, 2, 3];
$arr2 = [...$arr1]; //[1, 2, 3]
$arr3 = [0, ...$arr1]; //[0, 1, 2, 3]
$arr4 = [...$arr1, ...$arr2, 111]; //[1, 2, 3, 1, 2, 3, 111]
$arr5 = [...$arr1, ...$arr1]; //[1, 2, 3, 1, 2, 3]

function getArr() {
  return ['a', 'b'];
}
$arr6 = [...getArr(), 'c' => 'd']; //['a', 'b', 'c' => 'd']
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   Desempaquetando un array con el operador <code>...</code> sigue la semántica
   de la función <function>array_merge</function>.
   Es decir, las claves de los arrays desempaquetados se reindexan si son numéricas
   y se sobrescriben si son cadenas:

   <example>
    <title>Desempaquetado arrays con claves duplicadas</title>
    <programlisting role="php">
<![CDATA[
<?php
// string key
$arr1 = ["a" => 1];
$arr2 = ["a" => 2];
$arr3 = ["a" => 0, ...$arr1, ...$arr2];
var_dump($arr3); // ["a" => 2]

// integer key
$arr4 = [1, 2, 3];
$arr5 = [4, 5, 6];
$arr6 = [...$arr4, ...$arr5];
var_dump($arr6); // [1, 2, 3, 4, 5, 6]
// Que es [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]
// Donde no se han conservado las claves enteras originales.
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <para>
    Las claves que no son números enteros ni cadenas lanzan un <classname>TypeError</classname>.
    Estas claves solo pueden generarse mediante un objeto <interfacename>Traversable</interfacename>.
   </para>
  </note>
  <note>
   <para>
    Antes de PHP 8.1, no se permitía desempaquetar un array que tuviera una clave de tipo string:
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

$arr1 = [1, 2, 3];
$arr2 = ['a' => 4];
$arr3 = [...$arr1, ...$arr2];
// Fatal error: Uncaught Error: Cannot unpack array with string keys in example.php:5

$arr4 = [1, 2, 3];
$arr5 = [4, 5];
$arr6 = [...$arr4, ...$arr5]; // works. [1, 2, 3, 4, 5]
?>
]]>
    </programlisting>
   </informalexample>
  </note>

 </sect2>

 <sect2 xml:id="language.types.array.examples">
  <title>Ejemplos</title>

  <para>
   El tipo array en PHP es bastante versátil. Aquí hay algunos ejempos:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// Esto:
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
            4        // la clave será 0
          );

$b = array('a', 'b', 'c');

// . . .es completamente equivalente a
$a = array();
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // la clave será 0

$b = array();
$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// Después de que se ejecute el código, $a será el array
// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',
// 'name' => 'apple', 0 => 4), y $b será el array
// array(0 => 'a', 1 => 'b', 2 => 'c'), o simplemente array('a', 'b', 'c').
?>
]]>
   </programlisting>
  </informalexample>

  <example>
   <title>Uso de array()</title>
   <programlisting role="php">
<![CDATA[
<?php
// Array como mapa de propiedades
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );

// Keys estrictamente numéricas
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// esto es lo mismo que array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7,
                    'a'  =>  4,
                            11, // key = 6 (el índice entero máximo era 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // el valor 10 será reemplazado por 12
                  );

// array vacío
$empty = array();
?>
]]>
    <!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
   </programlisting>
  </example>

  <example xml:id="language.types.array.examples.loop">
   <title>Colección</title>
   <programlisting role="php">
<![CDATA[
<?php
$colors = array('rojo', 'azul', 'verde', 'amarillo');

foreach ($colors as $color) {
    echo "¿Le gusta el $color?\n";
}

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
¿Le gusta el rojo?
¿Le gusta el azul?
¿Le gusta el verde?
¿Le gusta el amarillo?
]]>
   </screen>
  </example>

  <para>
   Modificar los valores del <type>array</type> directamente es posible
   pasándolos por referencia.
  </para>

  <example xml:id="language.types.array.examples.changeloop">
   <title>Cambiando elemento en el bucle</title>
   <programlisting role="php">
<![CDATA[
<?php
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* Se asegura de que escrituras subsiguientes a $color
no modifiquen el último elemento del array */

print_r($colors);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => ROJO
    [1] => AZUL
    [2] => VERDE
    [3] => AMARILLO
)
]]>
   </screen>
  </example>

  <para>
   Este ejemplo crea un array con base uno.
  </para>

  <example>
   <title>Índice con base 1</title>
   <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'Enero', 'Febrero', 'Marzo');
print_r($firstquarter);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [1] => 'Enero'
    [2] => 'Febrero'
    [3] => 'Marzo'
)
]]>
   </screen>
  </example>

  <example>
   <title>Llenado de un array</title>
   <programlisting role="php">
<![CDATA[
<?php
// llenar un array con todos los ítems de un directorio
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle);
?>
]]>
   </programlisting>
  </example>

  <para>
   Los <type>Array</type>s son ordenados. El orden puede ser modificado usando varias
   funciones de ordenado. Vea la sección sobre <link linkend="ref.array">funciones de arrays</link>
   para más información. La función <function>count</function> puede ser usada para contar el
   número de elementos en un <type>array</type>.
  </para>

  <example>
   <title>Ordenado de un array</title>
   <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
   </programlisting>
  </example>

  <para>
   Dado que el valor de un <type>array</type> puede ser cualquier cosa, también puede
   ser otro <type>array</type>. De esta forma es posible crear <type>array</type>s
   recursivas y multi-dimensionales.
  </para>

  <example>
   <title>Arrays recursivos y multi-dimensionales</title>
   <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Algunos ejemplos que hacen referencia a los valores del array anterior
echo $fruits["holes"][5];    // Imprime "second"
echo $fruits["fruits"]["a"]; // Imprime "orange"
unset($fruits["holes"][0]);  // Elimina "first"

// Crear una nueva array multi-dimensional
$juices["apple"]["green"] = "good";
?>
]]>
   </programlisting>
  </example>

  <para>
   La asignación de <type>array</type>s siempre involucra la copia de valores. Use el
   <link linkend="language.operators">operador de referencia</link> para copiar
   un <type>array</type> por referencia.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 ha cambiado,
             // $arr1 sigue siendo array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // ahora $arr1 y $arr3 son iguales
?>
]]>
   </programlisting>
  </informalexample>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
