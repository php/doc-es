<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: f3c9e2b61ffbd7ff5d8c3756963ef371252a80ef Maintainer: gerardocdc Status: ready -->
<!-- Reviewed: no -->
<sect1 xml:id="language.types.integer">
 <title>Enteros</title>
 
 <simpara>
  Un entero o <type>integer</type> es un número del conjunto
  &#8484; = {..., -2, -1, 0, 1, 2, ...}.
 </simpara>
 
 <para>
  Consulte tambien:
 </para>
 
 <itemizedlist>
  <listitem>
   <simpara>
    <link linkend="ref.gmp">Entero de longitud arbitraria / GMP</link>
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <link linkend="language.types.float">Números de punto flotante</link>
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <link linkend="ref.bc">BCMath matemáticas de precisión arbitraria</link>
   </simpara>
  </listitem>
 </itemizedlist>
 
 <sect2 xml:id="language.types.integer.syntax">
  <title>Sintaxis</title>
  
  <simpara>
   Los <type>integer</type> pueden ser especificados mediante notación decimal
   (base 10), hexadecimal (base 16), octal (base 8) o binaria (base 2), opcionalmente precedidos
   por un signo (- o +).
  </simpara>
  
  <para>
   Los literales <type>integer</type> binarios están disponibles desde PHP 5.4.0.
  </para>
  
  <para>
   Para usar la notación octal, se antepone al número un <literal>0</literal> (cero).
   Para usar la notación hexadecimal, se antepone al número un <literal>0x</literal>.
   Para usar la notación binaria, se antepone al número un <literal>0b</literal>.
  </para>
  
  <example>
   <title>Enteros literales</title>
   <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // número decimal
$a = -123; // un número negativo
$a = 0123; // número octal (equivalente a 83 decimal)
$a = 0x1A; // número hexadecimal (equivalente a 26 decimal)
$a = 0b11111111; // número binario (equivalente al 255 decimal)
?>
]]>
   </programlisting>
  </example>
  
  <para>
   Formalmente, la estructura de <type>integer</type> literales es:
  </para>
  
  <informalexample>
   <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

binario     : 0b[01]+

entero      : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
            | [+-]?binary
]]>
   </programlisting>
  </informalexample>
  
  <para>
   El tamaño de un <type>integer</type> depende de la plataforma, aunque un valor máximo
   de aproximadamente dos mil millones es el valor usual (para 32 bits con signo).
   Las plataformas de 64-bits normalmente tienen un valor máximo de aproximadamente 9E18. PHP
   no admite <type>integer</type>s sin signo. El tamaño de un <type>integer</type>
   puede ser determinado mediante la constante <constant>PHP_INT_SIZE</constant> y el valor
   máximo mediante la constante <constant>PHP_INT_MAX</constant> desde
   PHP 4.4.0 y PHP 5.0.5.
  </para>
  
  <warning>
   <para>
    Si en un <type>integer</type> octal se da un dígito incorrecto (por ejemplo 8 o 9),
    el resto del número se ignora.
   </para>
   
   <example>
    <title>Octal raros</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010 octal = 8 decimal
?>
]]>
    </programlisting>
   </example>
  </warning>
 </sect2>
 
 <sect2 xml:id="language.types.integer.overflow">
  <title>Desbordamiento de enteros</title>
  
  <para>
   Si PHP encuentra un número fuera de los límites de un <type>integer</type>,
   se interpretará como un <type>float</type> en su lugar. Tambien, una operación cuyo 
   resultado es un número fuera de los límites de un <type>integer</type> devolverá en su
   lugar un <type>float</type>.
  </para>
  
  <example>
   <title>Desbordamiento de enteros en sistemas 32-bits</title>
   <programlisting role="php">
<![CDATA[
<?php
$large_number = 2147483647;
var_dump($large_number);                     // int(2147483647)

$large_number = 2147483648;
var_dump($large_number);                     // float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);                     // float(50000000000)
?>
]]>
   </programlisting>
  </example>
  
  <example>
   <title>Desbordamiento de enteros en sistemas 64-bits</title>
   <programlisting role="php">
<![CDATA[
<?php
$large_number = 9223372036854775807;
var_dump($large_number);                     // int(9223372036854775807)

$large_number = 9223372036854775808;
var_dump($large_number);                     // float(9.2233720368548E+18)

$million = 1000000;
$large_number =  50000000000000 * $million;
var_dump($large_number);                     // float(5.0E+19)
?>
]]>
   </programlisting>
  </example>
  
  <para>
   No existe operador de división de <type>integer</type> en PHP.
   <literal>1/2</literal>produce el <type>float</type> <literal>0.5</literal>.
   El valor puede ser forzado a ser un <type>integer</type> redondeando por defecto, o 
   mediante la función <function>round</function> que permite un mayor control 
   sobre el redondeo.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286) 
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4) 
?>
]]>
   </programlisting>
  </informalexample>
 </sect2>
 
 <sect2 xml:id="language.types.integer.casting">
  <title>Conversión a enteros</title>
  
  <simpara>
   Para convertir explicitamente un valor a <type>integer</type>, se puede emplear 
   tanto <literal>(int)</literal> como <literal>(integer)</literal>. Sin embargo,
   la mayoría de las veces la conversión no es necesaria, ya que un valor es 
   convertido de forma automática cuando un operador, función o estructura de 
   control necesite un argumento del tipo <type>integer</type>. Un valor tambien
   puede ser convertido a <type>integer</type> mediante la función 
   <function>intval</function>.
  </simpara>
  
  <simpara>
   Consulte también la <link linkend="language.types.type-juggling">manipulación de tipos</link>.
  </simpara>
  
  <sect3 xml:id="language.types.integer.casting.from-boolean">
   <title>Desde <link linkend="language.types.boolean">booleanos</link></title>
   
   <simpara>
    &false; produce <literal>0</literal> (cero), y &true; produce
    <literal>1</literal> (uno).
   </simpara>
  </sect3>
  
  <sect3 xml:id="language.types.integer.casting.from-float">
   <title>
    Desde <link linkend="language.types.float">números de punto flotante</link>
   </title> 
   
   <simpara>
    Cuando se convierte de un <type>float</type> a un <type>integer</type>, el 
    número será redondeado <emphasis>hacia cero</emphasis>.
   </simpara>
   
   <para>
    Si el float esta por debajo de los límites de un <type>integer</type> (normalmente
    <literal>+/- 2.15e+9 = 2^31</literal> en plataformas de 32 bits y 
    <literal>+/- 9.22e+18 = 2^63</literal> en plataformas de 64 bits), el resultado es
    indefinido, debido a que <type>float</type> no tiene la precisión suficiente para 
    ofrecer el resultado como un <type>integer</type> exacto. No se mostrará ninguna 
    advertencia, ni siquiera un aviso cuando esto ocurre!
   </para>
   
   <warning>
    <para>
     Nunca se debe convertir una fracción desconocida a un <type>integer</type>, ya que
     a veces puede producir resultados inesperados.
    </para>
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // muestra 7!
?>
]]>
     </programlisting>
    </informalexample>
    
    <para>
     Consulte tambien <link linkend="warn.float-precision">aviso sobre la precisión de
     float</link>
    </para>
   </warning>
  </sect3>
  
  <sect3 xml:id="language.types.integer.casting.from-string">
   <title>Desde cadenas</title>
   
   <simpara>
    Consulte <link linkend="language.types.string.conversion">Conversión de cadenas a números</link>
   </simpara>
  </sect3>
  
  <sect3 xml:id="language.types.integer.casting.from-other">
   <title>Desde otros tipos</title>
   
   <caution>
    <simpara>
     El comportamiento de la conversion de <type>integer</type> a otros tipos es indefinido.
     <emphasis>No</emphasis> espere que exista un comportamiento esperado, ya que puede 
     cambiar sin previo aviso.
    </simpara>
   </caution>
  </sect3>
  
 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
