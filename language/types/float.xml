<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: ea5ef878791d0182c69e3fb69e05a7ddd97aad15 Maintainer: jpberdejo Status: ready -->
<!-- Reviewed: no Maintainer: andresdzphp -->

<sect1 xml:id="language.types.float" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Números de punto flotante</title>
 
 <para>
  Los números de punto flotante (también conocidos como "flotantes",
  "dobles" o "números reales") pueden ser especificados usando cualquiera de las siguientes sintaxis:
 </para>
 
 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;
?>
]]>
  </programlisting>
 </informalexample>
 
 <para>
  Formalmente: 
 </para>
 
 <informalexample>
  <programlisting>
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
  </programlisting>
 </informalexample>
 
 <para>
  El tamaño de un flotante depende de la plataforma, aunque un valor común
  consiste en un máximo de ~1.8e308 con una precisión de aproximadamente 14
  dígitos decimales (lo que es un valor de 64 bits en formato IEEE).
 </para>
 
 <warning xml:id="warn.float-precision">
  <title>Precisión del punto flotante</title>
  
  <para>
   Los números de punto flotante tienen una precisión limitada. Aunque depende del
   sistema, PHP típicamente utiliza el formato de doble precisión IEEE 754, el cual
   dará un error relativo máximo por aproximación del orden de 1.11e-16.
   Las operaciones aritméticas elementales no podrán dar grandes errores y por supuesto,
   los errores por propagación deben ser considerados cuando varias operaciones son
   compuestas.
  </para>
  
  <para>
   Adicionalmente, los numeros racionales que son representables exactamente como números
   de punto flotante en base 10, como <literal>0.1</literal> o
   <literal>0.7</literal>, no tienen una representación exacta como números
   de punto flotante en base 2, el cual es usado internamente, sin importar el tamaño de
   la mantisa. Por lo tanto, no se puede convertir en sus contrapartes binarias
   internas sin una pequeña pérdida de precisión. Esto puede llevar a confundir
   resultados: Por ejemplo, <literal>floor((0.1+0.7)*10)</literal> usualmente
   retornará <literal>7</literal> en lugar del <literal>8</literal> esperado,
   ya que la representación interna será algo así como
   <literal>7.9999999999999991118...</literal>.
  </para>
  
  <para>
   Así que nunca se confía en resultados de números flotantes hasta el último dígito y no se comparan
   números de punto flotante directamente para igualdad. Si es necesaria una mejor precisión,
   están disponibles las <link linkend="ref.bc">funciones matemáticas de precisión arbitraria</link>
   y las funciones <link linkend="ref.gmp">gmp</link>.
  </para>
  
   <para>
   Para una explicación "simple", véase la <link xlink:href="&url.floating.point.guide;">guía de punto flotante</link>
   que también se titula "¿Por qué no suman mis números?"
  </para>
 </warning>
 
 <sect2 xml:id="language.types.float.casting">
  <title>Conversión a flotante</title>
  
  <para>
   Para más información sobre las conversiones de <type>string</type> a
   <type>float</type>, vea <link
   linkend="language.types.string.conversion">Conversión de cadenas a
   números</link>. Para valores de otros tipos, la conversión es la misma
   que si el valor hubiese sido convertido a <type>integer</type>  y luego 
   a <type>float</type>.  Vea
   <link linkend="language.types.integer.casting">Conversión a entero</link>
   para más información. A partir de PHP 5, una noticia es generada si
   intenta convertir un objeto a <type>float</type>.
  </para>
  
 </sect2>

 <sect2 xml:id="language.types.float.comparison">
  <title>Comparing floats</title>

  <para>
   Como se indica en la advertencia anterior, comprobar la igualdad de valores de punto flotante 
   es problemático, debido a la forma en que se representan internamente. Sin embargo,
   hay maneras de hacer comparaciones de los valores de punto flotante que trabajan rodeando
   a estas limitaciones.
  </para>

  <para>
   Para comprobar la igualdad de valores de punto flotante, se utiliza un límite superior en el error
   relativo debido al redondeo. Este valor se conoce como el epsilon de la máquina
   o unidad de redondeo y es la menor diferencia aceptable en los cálculos.
  </para>
  
  <informalexample>
   <simpara>
    <varname>$a</varname> y <varname>$b</varname> son iguales a 5 dígitos de
    precisión.
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
$a = 1.23456789;
$b = 1.23456780;
$epsilon = 0.00001;

if(abs($a-$b) < $epsilon) {
    echo "true";
}
?>
]]>
   </programlisting>
  </informalexample>
 </sect2>
 
 <sect2 xml:id="language.types.float.nan">
  <title>NaN</title>
  <para>
   Algunas operaciones numéricas pueden resultar en un valor representado por la constante
   <constant>NAN</constant>. Este resultado representa un valor no definido o
   no representable mediante cálculos de coma flotante. Cualquier comparación, ya sea poco
   rígida o estricta, de esta valor con cualquier otro valor, incluido él mismo
   tenfrá un resultado de &false;.
  </para>
  <para>
   Ya que <constant>NAN</constant> representa cualquier número de diferentes valores,
   <constant>NAN</constant> no debería compararse con otros valores, incluido
   él mismo; en su lugar debería comprobarse usando la función <function>is_nan</function>.
  </para>
 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
