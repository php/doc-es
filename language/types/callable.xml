<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 147b80d1974b969caad1db188a48f4bcd90f5eb8 Maintainer: Marqitos Status: ready -->
<!-- Reviewed: no -->
<sect1 xml:id="language.types.callable">
 <title>Callables</title>

 <simpara>
  Un callable es una referencia a una función o método que se pasa a
  otra función como argumento.
  Se representa con la declaración de tipo <type>callable</type>.
 </simpara>
 <informalexample>
  <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
function foo(callable $callback) {
    $callback();
}
?>
]]>
  </programlisting>
 </informalexample>

 <simpara>
  Algunas funciones aceptan funciones de retrollamada como parámetro, por ejemplo
  <function>array_map</function>, <function>usort</function>, o
  <function>preg_replace_callback</function>.
 </simpara>

 <sect2 xml:id="language.types.callable.passing">
  <title>Creación de callables</title>

  <simpara>
   Un callable es un tipo que representa algo que se puede invocar.
   Los callables se pueden pasar como argumentos a funciones o métodos que
   esperan un parámetro de retrollamada o se pueden invocar directamente.
   El tipo <type>callable</type> no se puede usar como declaración de tipo para propiedades
   de clase. En su lugar, use una declaración de tipo <classname>Closure</classname>.
  </simpara>

  <simpara>
   Los callables se pueden crear de varias maneras diferentes:
  </simpara>

  <itemizedlist>
   <listitem>
    <simpara>Un objeto <classname>Closure</classname></simpara>
   </listitem>
   <listitem>
    <simpara>Un &string; conteniendo el nombre de una función o método</simpara>
   </listitem>
   <listitem>
    <simpara>
     Un &array; conteniendo un nombre de clase o un <type>object</type>
     en el índice 0 y el nombre del método en el índice 1
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Un &object; implementando el método mágico
     <link linkend="object.invoke">__invoke()</link>
    </simpara>
   </listitem>
  </itemizedlist>

  <simpara>
   Un objeto <classname>Closure</classname> puede ser creado usando la sintaxis de
   <link linkend="functions.anonymous">funciones anónimas</link>, sintaxis de
   <link linkend="functions.arrow">funciones de flecha</link>,
   <link linkend="functions.first_class_callable_syntax">sintaxis callable de primera
   clase</link>, o el método <methodname>Closure::fromCallable</methodname>.
  </simpara>

  <note>
   <simpara>
    La <link linkend="functions.first_class_callable_syntax">sintaxis callable de primera
   clase</link> solo está disponible a partir de PHP 8.1.0.
   </simpara>
  </note>

  <example>
   <title>
    Ejemplo de callback usando una <classname>Closure</classname>
   </title>
  <programlisting role="php">
<![CDATA[
<?php
// Usando sintaxis de función anónima
$double1 = function ($a) {
    return $a * 2;
};

// Usando sintaxis de callable de primera clase
function double_function($a) {
    return $a * 2;
}
$double2 = double_function(...);

// Usando sintaxis de función de flecha
$double3 = fn($a) => $a * 2;

// Usando Closure::fromCallable
$double4 = Closure::fromCallable('double_function');

// Utilizar clousure como función de devolución de retrollamada
// para duplicar el tamaño de cada elemento en nuestro rango
$new_numbers = array_map($double1, range(1, 5));
print implode(' ', $new_numbers) . PHP_EOL;

$new_numbers = array_map($double2, range(1, 5));
print implode(' ', $new_numbers) . PHP_EOL;

$new_numbers = array_map($double3, range(1, 5));
print implode(' ', $new_numbers) . PHP_EOL;

$new_numbers = array_map($double4, range(1, 5));
print implode(' ', $new_numbers);

?>
]]>
   </programlisting>
   &example.outputs.81;
   <screen>
<![CDATA[
2 4 6 8 10
2 4 6 8 10
2 4 6 8 10
2 4 6 8 10
]]>
   </screen>
  </example>

  <simpara>
   Un callable también puede ser un string que contenga el nombre de una función o
   método estático.
   Cualquier función interna o definida por el usuario puede ser usada, excepto las construcciones del lenguaje
   como: <function>array</function>, <function>echo</function>,
   <function>empty</function>, <function>eval</function>,
   <function>isset</function>,
   <function>list</function>, <function>print</function>, o
   <function>unset</function>.
  </simpara>

  <simpara>
   Un método de clase estático puede ser usado sin instanciar un
   <type>object</type> de esa clase, ya sea creando un array con
   el nombre de la clase en el índice 0 y el nombre del método en el índice 1, o usando
   la sintaxis especial con el operador de resolución de ámbito
   <literal>::</literal>, como en <literal>'ClassName::methodName'</literal>.
  </simpara>

  <simpara>
   Un método de un <type>object</type> instanciado puede ser un callable
   cuando se pasa como un array con el <type>object</type> en el índice 0
   y el nombre del método en el índice 1.
  </simpara>

  <simpara>
   La principal diferencia entre un objeto <classname>Closure</classname> y el
   tipo <type>callable</type> es que un objeto <classname>Closure</classname> es
   independiente del ámbito y siempre se puede invocar, mientras que un tipo
   callable puede depender del ámbito y puede que no se pueda invocar directamente.
   <classname>Closure</classname> es la forma preferida de crear callables.
  </simpara>

  <note>
   <simpara>
    Mientras que los objetos <classname>Closure</classname> están vinculados al ámbito
    donde se crean, los callables que hacen referencia a métodos de clase como strings
    o arrays se resuelven en el ámbito donde se llaman.
    Para crear un callable a partir de un método privado o protegido, que luego se pueda
    invocar desde fuera del ámbito de la clase, use
    <methodname>Closure::fromCallable</methodname> o la
    <link linkend="functions.first_class_callable_syntax">sintaxis callable de primera
    clase</link>.
   </simpara>
  </note>

  <simpara>
   PHP permite la creación de callables que pueden ser usados como argumento de retrollamada
   pero que no pueden ser llamados directamente.
   Estos son callables dependientes del contexto que hacen referencia a un método de clase en la
   jerarquía de herencia de una clase, por ejemplo
   <literal>'parent::method'</literal> o <literal>["static", "method"]</literal>.
  </simpara>

  <note>
   <simpara>
    A partir de PHP 8.2.0, los callables dependientes del contexto
    están obsoletos. Elimine la dependencia del contexto reemplazando
    <literal>'parent::method'</literal> con
    <literal>parent::class . '::method'</literal> o use la
    <link linkend="functions.first_class_callable_syntax">sintaxis callable de primera
    clase</link>.
   </simpara>
  </note>

  <example>
   <title>
    Invocando varios tipos de callables con <function>call_user_func</function>
   </title>
   <programlisting role="php">
<![CDATA[
<?php

// Un ejemplo de función de retrollamada
function my_callback_function() {
    echo '¡hola mundo!', PHP_EOL;
}

// Un ejemplo de método de retrollamada
class MyClass {
    static function myCallbackMethod() {
        echo '¡Hola Mundo!', PHP_EOL;
    }
}

// Tipo 1: Función de retrollamada simple
call_user_func('my_callback_function');

// Tipo 2: Llamada a un método estático de clase
call_user_func(['MyClass', 'myCallbackMethod']);

// Tipo 3: Llamada a un método de objeto
$obj = new MyClass();
call_user_func([$obj, 'myCallbackMethod']);

// Tipo 4: Llamada a un método estático de clase
call_user_func('MyClass::myCallbackMethod');

// Type 5: Llamada a un método estático de clase usando la palabla clave ::class
call_user_func([MyClass::class, 'myCallbackMethod']);

// Tipo 6: Llamada a un método estático de clase relativo
class A {
    public static function who() {
        echo 'A', PHP_EOL;
    }
}

class B extends A {
    public static function who() {
        echo 'B', PHP_EOL;
    }
}

call_user_func(['B', 'parent::who']); // obsoleto a partir de PHP 8.2.0

// Tipo 7: Los objetos que implementan __invoke pueden ser utilizados como callables
class C {
    public function __invoke($name) {
        echo 'Hola ', $name;
    }
}

$c = new C();
call_user_func($c, 'PHP!');
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
¡hola mundo!
¡Hola Mundo!
¡Hola Mundo!
¡Hola Mundo!
¡Hola Mundo!

Deprecated: Callables of the form ["B", "parent::who"] are deprecated in script on line 41
A
Hola PHP!
]]>
   </screen>
  </example>

  &note.func-callback-exceptions;
 </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
