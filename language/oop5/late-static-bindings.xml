<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 009f215fc983eeded6161676bcffdd8cf3b6b080 Maintainer: PhilDaiguille Status: ready -->
<!-- Reviewed: no -->
<sect1 xml:id="language.oop5.late-static-bindings" xmlns="http://docbook.org/ns/docbook">
  <title>Late Static Bindings (Resolución estática en tiempo de ejecución)</title>
  <para>
   PHP implementa una funcionalidad llamada
   <literal>late static binding</literal>, en español la resolución
   estática en tiempo de ejecución, que puede ser utilizada para referenciar la clase llamada
   en un contexto de herencia estática.
  </para>

  <para>
   Más precisamente, las resoluciones estáticas en tiempo de ejecución funcionan registrando
   el nombre de la clase en la última "llamada no reenviada". En el caso de las llamadas de
   métodos estáticos, se trata de la clase explícitamente nombrada (generalmente, la que está a
   la izquierda del operador
   <link linkend="language.oop5.paamayim-nekudotayim"><literal>::</literal></link>) ;
   en el caso de métodos no estáticos, se trata de la clase del objeto. Una "llamada
   reenviada" es una llamada estática introducida por <literal>self::</literal>,
   <literal>parent::</literal>, <literal>static::</literal>, o, subiendo en la
   jerarquía de clases, <function>forward_static_call</function>.
   <!-- técnicamente, static:: puede no ser de reenvío, pero es irrelevante -->

   La función <function>get_called_class</function> puede ser utilizada para recuperar
   una cadena que contiene el nombre de la clase llamada, y <literal>static::</literal>
   introduce su ámbito.
  </para>

  <para>
   Esta funcionalidad ha sido bautizada como <literal>"late static bindings"</literal>,
   con un punto de vista interno. <literal>"Late binding"</literal>, literalmente
   resolución tardía, proviene del hecho de que los elementos <literal>static::</literal>
   no serán resueltos utilizando la clase donde el método ha sido definido, sino
   que será calculada utilizando la información en tiempo de ejecución.
   También se denomina "static binding" ya que puede ser utilizado para (sin estar
   limitado a) los métodos estáticos.
  </para>

  <sect2 xml:id="language.oop5.late-static-bindings.self">
   <title>Limitaciones de <literal>self::</literal></title>
   <para>
    Las referencias estáticas a la clase actual, con <literal>self::</literal> o
    <literal>__CLASS__</literal>, son resueltas utilizando la clase a la que
    pertenecen las funciones, es decir, donde fueron definidas:
   </para>
   <example>
    <title>Uso de <literal>self::</literal></title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    public static function who()
    {
        echo __CLASS__;
    }

    public static function test()
    {
        self::who();
    }
}

class B extends A
{
    public static function who()
    {
         echo __CLASS__;
    }
}

B::test();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
A
]]>
    </screen>
   </example>

  </sect2>

  <sect2 xml:id="language.oop5.late-static-bindings.usage">
   <title>Uso de la resolución estática en tiempo de ejecución</title>

   <para>
    La resolución estática en tiempo de ejecución intenta superar esta limitación
    introduciendo una palabra clave que hace referencia a la clase
    que ha sido llamada durante la ejecución. Para simplificar, esta palabra clave
    permite la referencia a <literal>B</literal> desde
    <literal>test()</literal>, en el ejemplo anterior.
    Se decidió no introducir una nueva palabra clave, sino más bien
    utilizar la palabra <literal>static</literal> que ya estaba
    reservada.
   </para>

   <example>
    <title>Uso simple de <literal>static::</literal></title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    public static function who()
    {
        echo __CLASS__;
    }

    public static function test()
    {
        static::who(); // Aquí, resolución estática en tiempo de ejecución
    }
}

class B extends A
{
    public static function who()
    {
         echo __CLASS__;
    }
}

B::test();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
B
]]>
    </screen>
   </example>
   <note>
    <para>
     En contextos no estáticos, la clase llamada será la del objeto.
     Como <literal>$this-></literal> intentará llamar
     a métodos privados desde el mismo ámbito, utilizar <literal>static::</literal>
     podría dar resultados diferentes. Tenga en cuenta también que
     <literal>static::</literal> solo puede hacer referencia a propiedades
     estáticas.
    </para>
   </note>
   <example>
    <title>Uso de <literal>static::</literal> en un contexto no estático</title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    private function foo()
    {
        echo "Success!\n";
    }

    public function test()
    {
        $this->foo();
        static::foo();
    }
}

class B extends A
{
   /* foo() será copiada en B, por lo tanto su ámbito será siempre A
    * y la llamada se realizará sin problemas */
}

class C extends A
{
    private function foo()
    {
        /* El método original es reemplazado; el ámbito es el de C */
    }
}

$b = new B();
$b->test();

$c = new C();
try {
    $c->test();
} catch (Error $e) {
    echo $e->getMessage();
}

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Success!
Success!
Success!
Call to private method C::foo() from scope A
]]>
    </screen>
   </example>
   <note>
    <para>
     La resolución de estáticos en tiempo de ejecución se detendrá en una llamada estática
     completamente resuelta. Por otro lado, las llamadas estáticas utilizando
     una palabra clave como <literal>parent::</literal> o <literal>self::</literal>
     reenviarán la información de llamada.
    </para>
    <example>
     <title>Llamadas con o sin reenvío</title>
     <programlisting role="php">
<![CDATA[
<?php

class A
{
    public static function foo()
    {
        static::who();
    }

    public static function who()
    {
        echo __CLASS__."\n";
    }
}

class B extends A
{
    public static function test()
    {
        A::foo();
        parent::foo();
        self::foo();
    }

    public static function who()
    {
        echo __CLASS__."\n";
    }
}
class C extends B
{
    public static function who()
    {
        echo __CLASS__."\n";
    }
}

C::test();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
A
C
C
]]>
     </screen>
    </example>
   </note>
  </sect2>
</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
