<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: f6580b6a63f1a578a14de64ac6e4a34f56b7e9ec Maintainer: chuso Status: ready -->
<sect1 xml:id="language.oop5.patterns" xmlns="http://docbook.org/ns/docbook">
 <title>Patrones</title>
 <para>
  Los patrones son formas de describir las mejores prácticas y diseños correctos.
  Muestran una solución flexible a problemas de programación frecuentes.
 </para>

 <sect2 xml:id="language.oop5.patterns.factory">
  <title>Fábrica</title>
  <para>
   El patrón Fábrica permite instanciar objetos en tiempo de ejecución.
   Se le llama Patrón Fábrica porque es responsable de la
   "fabricación" de un objeto. Una Fábrica Parametrizada recibe como
   argumento el nombre de la clase a instanciar.
  </para>
  <example>
   <title>Método de Fábrica Parametrizada</title>
   <programlisting role="php">
<![CDATA[
<?php
class Ejemplo
{
    // El método de fábrica parametrizada
    public static function fabrica($tipo)
    {
        if (include_once 'Drivers/' . $tipo . '.php') {
            $nombreclase = 'Driver_' . $tipo;
            return new $nombreclase;
        } else {
            throw new Exception('Driver no encontrado');
        }
    }
}
?>
]]>
   </programlisting>
   <para>
    Al definir este método en una clase, permitimos que se puedan cargar
    al vuelo los drivers. Si la case <literal>Ejemplo</literal> fuera una
    clase de abstracción de bases de datos, se podría cargar un driver de
    <literal>MySQL</literal> y de <literal>SQLite</literal> de la siguiente forma:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Carga un driver MySQL
$mysql = Ejemplo::fabrica('MySQL');

// Carga un driver SQLite
$sqlite = Ejemplo::fabrica('SQLite');
?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.patterns.singleton">
  <title>Singleton</title>
  <para>
   Un Singleton asegura que sólo existe una instancia de una determinada Clase y ofrece
   un punto de acceso global a esa instancia. El singleton es un Patrón Creacional del "Gang of Four" (La Banda de los Cuatro).
  </para>
  <para>A menudo se utiliza el patrón singleton para implementar clases de bases de datos, registros, controladores
   frontales u objetos de petición y respuesta.
  </para>
  
  <example>
   <title xml:id="language.oop5.patterns.singleton.examples.basic">Ejemplo de Singleton</title>
   <programlisting role="php"><![CDATA[
<?php
class Ejemplo
{
    private static $instancia;
    private $count = 0;
    
    private function __construct() 
    {
    }

    public static function singleton() 
    {
        if (!isset(self::$instancia)) {
            echo 'Creando nueva instancia.';
            $nombreClase = __CLASS__;
            self::$instancia = new $nombreClase;
        }
        return self::$instancia;
    }

    public function incremento()
    {
        echo $this->count++;
    }

    public function __clone()
    {
        trigger_error('No se permite la clonación.', E_USER_ERROR);
    }

    public function __wakeup()
    {
        trigger_error('No se permite deserializar.', E_USER_ERROR);
    }
}
?>
]]>
   </programlisting>
   <para>A continuación se ilustra cómo se comporta el Singleton</para>
   <programlisting role="php"><![CDATA[
<?php
$singleton = Example::singleton(); // imprime "Creando nueva instancia."
echo $singleton->increment(); // 0
echo $singleton->increment(); // 1

$singleton = Example::singleton(); // reutiliza la instancia ya existente
echo $singleton->increment(); // 2
echo $singleton->increment(); // 3

// todos estos emitirán un Error Fatal
$singleton2 = new Example;
$singleton3 = clone $singleton;
$singleton4 = unserialize(serialize($singleton));
?>
]]>
   </programlisting>
  </example>
  <warning xml:id="warn.singleton.controversy">
   <para>
    El patrón Singleton es uno de los más controvertidos. Sus críticos argumentan que
    el Singleton introducen un Estado GLobal en una aplicación y que mantiene fuertemente
    acoplado a éste con sus clases consumidoras. Esto conlleva a ocultar dependencias y 
    efectos colaterales inesperados, que por otra parte generan código más dificil de probar y mantener.
   </para>
   <para>
    Sus críticos, además, afirman que no tiene sentido utilizar un Singleton en una Arquitectura
    en que no se comparte nada, como PHP, donde los objetos siempre son únicos en la petición. Es más fácil y limipio
    crear un grafo de objetos colaboradores usando los patrones Contructor y Factory una vez al
    principio de cada petición.
   </para>
   <para>
    Los Singletons además violan varios de los principios SOLID de diseño en POO y la Ley de Demeter.
    Los Singletons no puede serializarse. No puede heredarse de ellos (antes de PHP 5.3) y no pasarán
    por el Colector de Basuras ya que se instancia como un atributo estático en el Singleton.
   </para>   
  </warning>
 </sect2>

</sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
