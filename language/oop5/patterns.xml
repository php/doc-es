<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 0640e024d4b8a9400d457143ccd0ea66e5f98ead Maintainer: chuso Status: ready -->
<sect1 xml:id="language.oop5.patterns" xmlns="http://docbook.org/ns/docbook">
 <title>Patrones</title>
 <para>
  Los patrones son formas de describir las mejores prácticas y diseños correctos.
  Muestran una solución flexible a problemas de programación frecuentes.
 </para>

 <sect2 xml:id="language.oop5.patterns.factory">
  <title>Fábrica</title>
  <para>
   El patrón Fábrica permite instanciar objetos en tiempo de ejecución.
   Se le llama Patrón Fábrica porque es responsable de la
   "fabricación" de un objeto. Una Fábrica Parametrizada recibe como
   argumento el nombre de la clase a instanciar.
  </para>
  <example>
   <title>Método de Fábrica Parametrizada</title>
   <programlisting role="php">
<![CDATA[
<?php
class Ejemplo
{
    // El método de fábrica parametrizada
    public static function fabrica($tipo)
    {
        if (include_once 'Drivers/' . $tipo . '.php') {
            $nombreclase = 'Driver_' . $tipo;
            return new $nombreclase;
        } else {
            throw new Exception('Driver no encontrado');
        }
    }
}
?>
]]>
   </programlisting>
   <para>
    Al definir este método en una clase, permitimos que se puedan cargar
    al vuelo los drivers. Si la case <literal>Ejemplo</literal> fuera una
    clase de abstracción de bases de datos, se podría cargar un driver de
    <literal>MySQL</literal> y de <literal>SQLite</literal> de la siguiente forma:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Carga un driver MySQL
$mysql = Ejemplo::fabrica('MySQL');

// Carga un driver SQLite
$sqlite = Ejemplo::fabrica('SQLite');
?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.patterns.singleton">
  <title>Singleton</title>
  <para>
   El patrón Singleton se aplica en situaciones en las que
   se necesita que sólo haya una instancia de una clase.
   El ejemplo más común es una conexión a una base de datos.
   Al implementar este patrón, un programador puede hacer esta
   única instancia accesible a muchos otros objetos.
  </para>
  <example>
   <title>Función Singleton</title>
   <programlisting role="php">
<![CDATA[
<?php
class Ejemplo
{
    // Almacena una instancia de la clase
    private static $instancia;
    
    // Un constructor privado; previene la creación directa de objetos
    private function __construct() 
    {
        echo 'Estoy construido';
    }

    // El método singleton
    public static function singleton() 
    {
        if (!isset(self::$instancia)) {
            $c = __CLASS__;
            self::$instancia = new $c;
        }

        return self::$instancia;
    }
    
    // Método de ejemplo
    public function bark()
    {
        echo 'Woof!';
    }

    // Impide que los usuarios clonen la instancia
    public function __clone()
    {
        trigger_error('No se permite la clonación.', E_USER_ERROR);
    }

}

?>
]]>
   </programlisting>
   <para>
    Esto permite obtener una única instancia de la clase <literal>Ejemplo</literal>.
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Esto fallará dado que el constructor es privado
$test = new Ejemplo;

// Esto siempre devolverá una única instancia de la clase
$test = Ejemplo::singleton();
$test->bark();

// Esto emitirá un E_USER_ERROR.
$test_clone = clone $test;

?>
]]>
   </programlisting>
  </example>
 </sect2>

</sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
