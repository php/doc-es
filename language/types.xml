<?xml version="1.0" encoding="iso-8859-1"?>
  <chapter id="language.types">
	<title>Types</title>

   <para>
    PHP soporta los siguientes tipos:

   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">array</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.float">n&uacute;meros en punto flotante</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.integer">entero</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objeto</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.string">cadena</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>

  <simpara>
   El tipo de una variable normalmente no lo indica el programador;
   en su lugar, lo decide PHP en tiempo de ejecuci&oacute;n dependiendo del contexto
   en el que se utilice esa variable.
  </simpara>

  <simpara>
   Si se quisiese obligar a que una variable se convierta a un tipo
   concreto, se podr&iacute;a <link
   linkend="language.types.typecasting">forzar</link> la variable o
   usar la funci&oacute;n <function>settype</function> para ello.
  </simpara>

  <simpara>
   N&oacute;tese que una variable se puede comportar de formas diferentes en ciertas
   situaciones, dependiendo de qu&eacute; tipo sea en ese momento. Para m&aacute;s
   informaci&oacute;n, vea la secci&oacute;n <link
   linkend="language.types.type-juggling">Conversi&oacute;n de Tipos</link>.
  </simpara>

  <sect1 id="language.types.integer">
   <title>Enteros</title>
   <para>
    Los enteros se puede especificar usando una de las siguientes sintaxis:
    <informalexample>
     <programlisting role="php">
$a = 1234; # n&uacute;mero decimal
$a = -123; # un n&uacute;mero negativo
$a = 0123; # n&uacute;mero octal (equivalente al 83 decimal)
$a = 0x12; # n&uacute;mero hexadecimal (equivalente al 18 decimal)
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.types.float">
   <title>N&uacute;meros en punto flotante</title>
   <para>
    Los n&uacute;meros en punto flotante ("double") se pueden especificar utilizando
    cualquiera de las siguientes sintaxis: 
    <informalexample>
     <programlisting role="php"> 
$a = 1.234; $a = 1.2e3;
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.types.string">
   <title>Cadenas</title>
   <para>
    Las cadenas de caracteres se pueden especificar usando uno de dos tipos de
    delimitadores.
   </para>
   <para>
    Si la cadena est&aacute; encerrada entre dobles comillas ("), las variables que
    est&eacute;n dentro de la cadena ser&aacute;n expandidas (sujetas a ciertas limitaciones
    de interpretaci&oacute;n). Como en C y en Perl, el car&aacute;cter de barra invertida ("\") se
    puede usar para especificar caracteres especiales:
    <table>
     <title>Caracteres protegidos</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>secuencia</entry>
        <entry>significado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nueva l&iacute;nea</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retorno de carro</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulaci&oacute;n horizontal</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Barra invertida</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>Signo del d&oacute;lar</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Comillas dobles</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
         la secuencia de caracteres que coincida con la expresi&oacute;n
         regular es un car&aacute;cter en notaci&oacute;n octal
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
         la secuencia de caracteres que coincida con la expresi&oacute;n
         regular es un car&aacute;cter en notaci&oacute;n hexadecimal
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table></para>
   <para>
    Se puede proteger cualquier otro car&aacute;cter, pero se producir&aacute; una
advertencia en el nivel de depuraci&oacute;n m&aacute;s alto.
   </para>

   <para>
    La segunda forma de delimitar una cadena de caracteres usa el car&aacute;cter de 
    comilla simple ("'"). Cuando una cadena va encerrada entre comillas 
    simples, los &uacute;nicos caracteres de escape que ser&aacute;n comprendidos son "\\" y
    "\'". Esto es por convenio, as&iacute; que se pueden tener comillas simples y 
    barras invertidas en una cadena entre comillas simples. Las variables 
    <emphasis>no</emphasis> se expandir&aacute;n dentro de una cadena entre comillas
    simples.
   </para>

   <para>
    Otra forma de delimitar cadenas es usando la sintaxis de documento
incrustado ("&gt;&gt;&gt;").  Se debe proporcionar un identificador despu&eacute;s de
    <literal>&gt;&gt;&gt;</literal>, despu&eacute;s la cadena, y despu&eacute;s el
    mismo identificador para cerrar el entrecomillado.
    <example> 
     <title>He aqu&iacute; un ejemplo de entrecomillado de cadenas con sintaxis de
documento incrustado</title>
     <programlisting>
$str = &gt;&gt;&gt;EOD
Ejemplo de cadena
Expandiendo m&uacute;ltiples l&iacute;neas
usando sintaxis de documento incrustado.
EOD;
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     La sintaxis de documento incristado fue a&ntilde;adida en PHP 4.
    </para>
   </note>

   <para>
    Las cadenas se pueden concatenar usando el operador '.' (punto). N&oacute;tese
    que el operador '+' (suma) no sirve para esto. Por favor
    mire <link linkend="language.operators.string">Operadores
    de cadena</link> para m&aacute;s informaci&oacute;n.
   </para>

   <para>
    Se puede acceder a los caracteres dentro de una cadena trat&aacute;ndola
    como un array de caracteres indexado num&eacute;ricamente, usando una sintaxis
    similar a la de C. Vea un ejemplo m&aacute;s abajo.
   </para>

   <para>
    <example>
     <title>Algumos ejemplos de cadenas</title>
     <programlisting role="php">
&lt;?php
/* Asignando una cadena. */
$str = "Esto es una cadena";

/* A&ntilde;adiendo a la cadena. */
$str = $str . " con algo m&aacute;s de texto";

/* Otra forma de a&ntilde;adir, incluye un car&aacute;cter de nueva l&iacute;nea protegido. */
$str .= " Y un car&aacute;cter de nueva l&iacute;nea al final.\n";

/* Esta cadena terminar&aacute; siendo '&lt;p&gt;N&uacute;mero: 9&lt;/p&gt;' */
$num = 9;
$str = "&lt;p&gt;N&uacute;mero: $num&lt;/p&gt;";

/* Esta ser&aacute; '&lt;p&gt;N&uacute;mero: $num&lt;/p&gt;' */
$num = 9;
$str = '&lt;p&gt;N&uacute;mero: $num&lt;/p&gt;';

/* Obtener el primer car&aacute;cter de una cadena  */
$str = 'Esto es una prueba.';
$first = $str[0];

/* Obtener el &uacute;ltimo car&aacute;cter de una cadena. */
$str = 'Esto es a&uacute;n una prueba.';
$last = $str[strlen($str)-1];
?&gt;	  
     </programlisting>
    </example>
   </para>

   <sect2 id="language.types.string.conversion">
    <title>Conversi&oacute;n de cadenas</title>

    <simpara>
     Cuando una cadena se eval&uacute;a como un valor num&eacute;rico, el valor
     resultante y el tipo se determinan como sigue.</simpara>

    <simpara>
     La cadena se evaluar&aacute; como un doble si contiene cualquiera de los
     caracteres '.', 'e', o 'E'. En caso contrario, se evaluar&aacute; como un
     entero.</simpara>
     
    <para>
     El valor viene dado por la porci&oacute;n inicial de la cadena. Si la
     cadena comienza con datos de valor num&eacute;rico, este ser&aacute; el valor
     usado. En caso contrario, el valor ser&aacute; 0 (cero). Los datos 
     num&eacute;ricos v&aacute;lidos son un signo opcional, seguido por uno o m&aacute;s 
     d&iacute;gitos (que opcionalmente contengan un punto decimal), seguidos 
     por un exponente opcional. El exponente es una 'e' o una 'E' 
     seguidos por uno o m&aacute;s d&iacute;gitos.</para>

    <simpara>
     Cuando la primera expresi&oacute;n es una cadena, el tipo de la variable
     depender&aacute; de la segunda expresi&oacute;n.
    </simpara>

    <informalexample>
     <programlisting role="php">
$foo = 1 + "10.5";              // $foo es doble (11.5)
$foo = 1 + "-1.3e3";            // $foo es doble (-1299)
$foo = 1 + "bob-1.3e3";         // $foo es entero (1)
$foo = 1 + "bob3";              // $foo es entero (1)
$foo = 1 + "10 Cerditos";     // $foo es entero (11)
$foo = 1 + "10 Cerditos"; // $foo es entero (11)
$foo = "10.0 cerdos " + 1;        // $foo es entero (11)
$foo = "10.0 cerdos " + 1.0;      // $foo es double (11)     
     </programlisting>
    </informalexample>

    <simpara>
     Para m&aacute;s informaci&oacute;n sobre esta conversi&oacute;n, mire en la p&aacute;gina del 
     manual de Unix strtod(3).
    </simpara>

    <para>
     Si quisiera probar cualquiera de los ejemplos de esta secci&oacute;n,
     puede cortar y pegar los ejemplos e insertar la siguiente l&iacute;nea
     para ver por s&iacute; mismo lo que va ocurriendo:
     <informalexample>
      <programlisting role="php">
echo "\$foo==$foo; el tipo es " . gettype( $foo ) . "&lt;br&gt;\n";
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    Los arrays actualmente act&uacute;an tanto como tablas hash (arrays 
    asociativos) como arrays indexados (vectores).</para>

   <sect2 id="language.types.array.single-dim">
    <title>Arrays unidimensionales</title>

    <para>
     PHP soporta tanto arrays escalares como asociativos. De hecho, no hay
     diferencias entre los dos.  Se puede crear una array usando
     las funciones <function>list</function> o <function>array</function>,
     o se puede asignar el valor de cada elemento del array de manera expl&iacute;cita.

     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>

    <para>
     Tambi&eacute;n se puede crear un array simplemente a&ntilde;adiendo valores al
     array. Cuando se asigna un valor a una variable array usando corchetes
     vac&iacute;os, el valor se a&ntilde;adir&aacute; al final del array.

     <informalexample>
      <programlisting role="php"> 
$a[] = "hola"; // $a[2] == "hola"
$a[] = "mundo"; // $a[3] == "mundo" 
      </programlisting>
     </informalexample></para>
    
    <para>
     Los arrays se pueden ordenar usando las funciones 
     <function>asort</function>, <function>arsort</function>, 
     <function>ksort</function>, <function>rsort</function>, 
     <function>sort</function>, <function>uasort</function>, 
     <function>usort</function>, y <function>uksort</function> 
     dependiendo del tipo de ordenaci&oacute;n que se desee.</para>

    <para>
     Se puede contar el n&uacute;mero de elementos de un array usando la funci&oacute;n
     <function>count</function>.</para>

    <para>
      Se puede recorrer un array usando las funciones  <function>next</function>
      y <function>prev</function>.  Otra forma habitual de
      recorrer un array es usando la funci&oacute;n <function>each</function>.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Arrays Multidimensionales</title>

    <para>
     Los arrays multidimensionales son bastante simples actualmente.  Para cada
     dimensi&oacute;n del array, se puede a&ntilde;adir otro valor [clave] al final:

     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;           # ejemplos de una sola dimensi&oacute;n
$a["foo"]  = $f;   

$a[1][0]     = $f;         # bidimensional
$a["foo"][2] = $f;         # (se pueden mezclar &iacute;ndices num&eacute;ricos y asociativos)
$a[3]["bar"] = $f;         # (se pueden mezclar &iacute;ndices num&eacute;ricos y asociativos)

$a["foo"][4]["bar"][0] = $f;   # tetradimensional!
      </programlisting>
     </informalexample></para>

    <para>
     En PHP3 no es posible referirse a arrays multidimensionales
     directamente dentro de cadenas. Por ejemplo, lo siguiente no
     tendr&aacute; el resultado deseado:
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "Esto no va a funcionar: $a[3][bar]";
      </programlisting>
     </informalexample>

     En PHP3, lo anterior tendr&aacute; la salida <computeroutput>Esto no va a
     funcionar: Array[bar]</computeroutput>. De todas formas, el operador de
     concatenaci&oacute;n de cadenas se puede usar para solucionar esto:
	 
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Esto no va a funcionar: " . $a[3][bar];
      </programlisting>
     </informalexample>
	  
    </para>

    <para>
     En PHP4, sin embargo, todo el problema se puede circunvenir
     encerrando la referencia al array (dentro de la cadena) entre
     llaves:

     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Esto va a funcionar: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>

    <para>
     Se pueden "rellenar" arrays multidimensionales de muchas formas, pero la
     m&aacute;s dif&iacute;cil de comprender es c&oacute;mo usar el comando 
     <function>array</function> para arrays asociativos.  Estos
     dos trozos de c&oacute;digo rellenar&aacute;n el array unidimensional de la
     misma manera:

     <informalexample>
      <programlisting role="php"> 
# Ejemplo 1:

$a["color"]	= "rojo";
$a["sabor"]	= "dulce";
$a["forma"]	= "redondeada";
$a["nombre"]	= "manzana";
$a[3]		= 4;

# Example 2:
$a = array(
     "color" => "rojo",
     "sabor" => "dulce",
     "forma" => "redondeada",
     "nombre"  => "manzana",
     3       => 4
);
      </programlisting>
     </informalexample></para>

    <para>
     La funci&oacute;n <function>array</function> se puede anidar para
     arrays multidimensionales:

     <informalexample>
      <programlisting role="php"> 
&lt;?
$a = array(
     "manzana"  => array(
          "color"  => "rojo",
          "sabor"  => "dulce",
          "forma"  => "redondeada"
     ),
     "naranja"  => array(
          "color"  => "naranja",
          "sabor"  => "&aacute;cido",
          "forma"  => "redondeada"
     ),
     "pl&aacute;tano"  => array(
          "color"  => "amarillo",
          "sabor"  => "paste-y",
          "forma"  => "aplatanada"
     )
);

echo $a["manzana"]["sabor"];    # devolver&aacute; "dulce"
?>
      </programlisting>
     </informalexample></para></sect2></sect1>

  <sect1 id="language.types.object">
   <title>Objetos</title>

   <sect2 id="language.types.object.init">
    <title>Inicializaci&oacute;n de Objetos</title>

    <para>
     Para inicializar un objeto, se usa la sentencia new para instanciar
     el objeto a una variable.

     <informalexample>
       <programlisting role="php">
class foo {
    function do_foo () { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Type juggling</title>
   <simpara>
    PHP no requiere (o soporta) la declaraci&oacute;n expl&iacute;cita del tipo en
    la declaraci&oacute;n de variables; el tipo de una variable se determina por el
    contexto en el que se usa esa variable. Esto quiere decir que si se
    asigna un valor de cadena a la variable <parameter>var</parameter>,
    <parameter>var</parameter> se convierte en una cadena. Si despu&eacute;s se asigna
    un valor entero a la variable <parameter>var</parameter>, se convierte en
    una variable entera.
   </simpara>

   <para>
    Un ejemplo de conversi&oacute;n de tipo autom&aacute;tica en PHP3 es el operador
    suma '+'. Si cualquiera de los operandos es un doble, entonces todos
    los operandos se eval&uacute;an como dobles, y el resultado ser&aacute; un
    doble. En caso contrario, los operandos se interpretar&aacute;n como enteros,
    y el resultado ser&aacute; tambi&eacute;n un entero. N&oacute;tese que esto NO
    cambia los tipos de los operandos propiamente dichos; el &uacute;nico cambio
    est&aacute; en c&oacute;mo se eval&uacute;an los operandos.

    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo es una cadena (ASCII 48)
$foo++;      // $foo es la cadena "1" (ASCII 49)
$foo += 1;   // $foo ahora es un entero (2)
$foo = $foo + 1.3;  // $foo ahora es un doble (3.3)
$foo = 5 + "10 Cerditos Peque&ntilde;itos"; // $foo es entero (15)
$foo = 5 + "10 Cerditos";     // $foo es entero (15)
     </programlisting>
    </informalexample>
   </para>

   <simpara>
    Si los &uacute;ltimos dos ejemplos anteriores parecen confusos, vea <link
    linkend="language.types.string.conversion">Conversi&oacute;n
    de cadenas</link>.
   </simpara>

   <simpara>
    Si se desea obligar a que una variable sea evaluada con un tipo concreto,
    mire la secci&oacute;n <link linkend="language.types.typecasting">Forzado
    de tipos</link>. Si se desea cambiar el tipo de una variable, vea la
    funci&oacute;n <function>settype</function>.
   </simpara>

   <para>
    Si quisiese probar cualquiera de los ejemplos de esta secci&oacute;n,
    puede cortar y pegar los ejemplos e insertar la siguiente l&iacute;nea para
    ver por s&iacute; mismo lo que va ocurriendo:
    <informalexample>
     <programlisting role="php">
echo "\$foo==$foo; el tipo es " . gettype( $foo ) . "&lt;br&gt;\n";
     </programlisting>
    </informalexample>
   </para>


   <note>
    <para>
     La posibilidad de una conversi&oacute;n autom&aacute;tica a array no est&aacute; definida
     actualmente.
	 
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a es un entero
$a[0] = "f";  // $a se convierte en un array, en el que $a[0] vale "f"
      </programlisting>
     </informalexample>
    </para>

    <para>
     Aunque el ejemplo anterior puede parecer que claramente deber&iacute;a resultar
     en que $a se convierta en un array, el primer elemento del cual es 'f', 
     consideremos esto:

     <informalexample>
      <programlisting role="php">
$a = "1";     // $a es una cadena
$a[0] = "f";  // ¿Qu&eacute; pasa con los &iacute;ndices de las cadenas? ¿Qu&eacute; ocurre?
      </programlisting>
     </informalexample>
    </para>

    <para>
     Dado que PHP soporta indexaci&oacute;n en las cadenas v&iacute;a offsets usando la
     misma sintaxis que la indexaci&oacute;n de arrays, el ejemplo anterior nos 
     conduce a un problema: ¿deber&iacute;a convertirse $a en un array cuyo primer
     elemento sea "f", o deber&iacute;a convertirse "f" en el primer car&aacute;cter de la
     cadena $a?
    </para>

    <para>
     Por esta raz&oacute;n, tanto en PHP 3.0.12 como en PHP 4.0b3-RC4, el resultado
     de esta conversi&oacute;n autom&aacute;tica se considera que no est&aacute; definido. Los
     parches se est&aacute;n discutiendo, de todas formas.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Forzado de tipos</title>

    <para>
     El forzado de tipos en PHP funciona como en C: el nombre del tipo
     deseado se escribe entre par&eacute;ntesis antes de la variable a la que
     se pretende forzar.

     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo es un entero
$bar = (double) $foo;   // $bar es un doble
      </programlisting>
     </informalexample></para>
    
    <para>
     Los forzados de tipo permitidos son:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - fuerza a entero (integer)</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - fuerza a doble (double)</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - fuerza a cadena (string)</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - fuerza a array (array)</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - fuerza a objeto (object)</simpara>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     N&oacute;tese que las tabulaciones y espacios se permiten dentro de los
     par&eacute;ntesis, as&iacute; que los siguientes ejemplos son funcionalmente
     equivalentes:

     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>

    <para>
     Puede no ser obvio que ocurrir&aacute; cuando se fuerce entre
     ciertos tipos. Por ejemplo, lo siguiente deber&iacute;a ser tenido
     en cuenta.
    </para>

    <para>
     Cuando se fuerza el cambio de un escalar o una variable de cadena
     a un array, la variable se convertir&aacute; en el primer elemento del
     array:
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // produce la salida 'ciao'  
      </programlisting>
     </informalexample>
    </para>

    <para>
     Cuando se fuerza el tipo de una variable escalar o de una cadena
     a un objeto, la variable se convertir&aacute; en un atributo del objeto;
     el nombre del atributo ser&aacute; 'scalar':
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // produce la salida 'ciao'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
