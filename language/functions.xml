<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 4f04bd50ed71039b89e2b9a5aba7e53e74cac4c6 Maintainer: seros Status: ready -->
<!-- Reviewed: no Maintainer: andresdzphp -->
<chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
 <title>Funciones</title>

 <sect1 xml:id="functions.user-defined">
  <title>Funciones definidas por el usuario</title>

  <para>
   Una función puede ser definida empleando una sintaxis como la siguiente:
  </para>
  <para>
   <example>
    <title>Seudocódigo para demostrar el uso de funciones</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Función de ejemplo.\n";
    return $valor_devuelto;
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <simpara>
   Cualquier código PHP válido puede aparecer dentro de una función, incluso otras
   funciones y definiciones de
   <link linkend="language.oop5.basic.class">clases</link>.
  </simpara>
  <para>
   Los nombres de las funciones siguen las mismas reglas que las demás etiquetas de PHP. Un
   nombre de función válido comienza con una letra o guión bajo, seguido de
   cualquier número de letras, números o guiones bajos. Como expresión regular
   se expresaría así:
   <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>.
  </para>
  &tip.userlandnaming;
  <simpara>
   No es necesario definir una función antes de que sea referenciada,
   <emphasis>excepto</emphasis> cuando esta esté condicionalmente definida como
   se muestra en los dos ejemplos de abajo.
  </simpara>
  <para>
   Cuando una función está definida de una forma condicional como en los dos
   ejemplos siguientes, sus definiciones deben ser procesadas <emphasis>antes</emphasis>
   de ser llamadas.
  </para>
  <para>
   <example>
    <title>Funciones condicionales</title>
    <programlisting role="php">
<![CDATA[
<?php

$hacer_algo = true;

/* No podemos llamar a foo() desde aquí
   ya que no existe aún,
   pero podemos llamar a bar() */

bar();

if ($hacer_algo) {
  function foo()
  {
    echo "No existo hasta que la ejecución del programa llegue hasta mí.\n";
  }
}

/* Ahora podemos llamar de forma segura a foo()
   ya que $hacer_algo se evaluó como verdadero */

if ($hacer_algo) foo();

function bar()
{
  echo "Existo desde el momento inmediato que comenzó el programa.\n";
}

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Funciones dentro de funciones</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "No existo hasta que se llame a foo().\n";
  }
}

/* No podemos llamar aún a bar()
   ya que no existe. */

foo();

/* Ahora podemos llamar a bar(),
   el procesamiento de foo()
   la ha hecho accesible. */

bar();

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Todas las funciones y clases de PHP tienen ámbito global. Se pueden
   llamar desde fuera de una función incluso si fueron definidas dentro, y viceversa.
  </para>
  <simpara>
   PHP no admite la sobrecarga de funciones, ni es posible
   'desdefinir' ni redefinir funciones previamente declaradas.
  </simpara>
  <note>
   <simpara>
    Los nombres de las fuciones son insensibles a mayúsculas-minúsculas, aunque es una buena
    idea llamar a las funciones tal y como aparecen en sus declaraciones.
   </simpara>
  </note>
  <simpara>
   Las funciones admiten un <link linkend="functions.variable-arg-list">número variable de
   argumentos</link> y <link linkend="functions.arguments.default">argumentos
   predeterminados</link>. Véanse también las referencias
   de funciones para
   <function>func_num_args</function>,
   <function>func_get_arg</function>, y
   <function>func_get_args</function> para más información.
  </simpara>

  <para>
   En PHP es posible llamar a funciones recursivas.
   <example>
    <title>Funciones recursivas</title>
    <programlisting role="php">
<![CDATA[
<?php
function recursividad($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursividad($a + 1);
    }
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Las llamadas a funciones/métodos recursivos con más de 100-200 niveles de recursividad pueden
     agotar la pila y ocasionar la finalización del script en curso. Especialmente,
     las recurisvidades infinitas están consideradas un error de programación.
    </simpara>
   </note>
  </para>

 </sect1>

 <sect1 xml:id="functions.arguments">
  <title>Argumentos de funciones</title>

  <simpara>
   Cualquier información puede ser pasada a las funciones mediante la lista de argumentos,
   la cual es una lista de expresiones delimitadas por comas. Los argumentos son
   evaluados de izquierda a derecha.
  </simpara>

  <para>
   PHP admite el paso de argumentos por valor (lo predeterminado), <link
   linkend="functions.arguments.by-reference">el paso por
   referencia</link>, y <link
   linkend="functions.arguments.default">valores de argumentos
   predeterminados</link>. Las <link linkend="functions.variable-arg-list">Listas de argumentos
   de longitud variable</link> también están soportadas.
  </para>
  <para>
   <example>
    <title>Pasar arrays a funciones</title>
    <programlisting role="php">
<![CDATA[
<?php
function tomar_array($entrada)
{
    echo "$entrada[0] + $entrada[1] = ".$entrada[0]+$entrada[1];
}
?>
]]>
    </programlisting>
    </example>
   </para>
   <para>
    A partir de PHP 8.0.0, la lista de argumentos de una función puede incluir una coma final, la cual
    será ignorada. Esto es particularmente útil en casos donde la lista de argumentos es
    larga o contiene nombres de variables extensos, lo que facilita listar los argumentos de forma vertical.
   </para>
   <example>
    <title>Lista de argumentos de función con coma final</title>
    <programlisting role="php">
<![CDATA[
<?php
function recibe_muchos_args(
    $primer_arg,
    $segundo_arg,
    $un_nombre_de_argumento_muy_largo,
    $arg_con_valor_por_defecto = 5,
    $otra_vez = 'un string por defecto', // Esta coma final no era permitida antes de PHP 8.0.0.
)
{
    // ...
}
?>
]]>
    </programlisting>
   </example>

   <sect2 xml:id="functions.arguments.by-reference">
   <title>Paso de argumentos por referencia</title>

   <simpara>
    Por defecto, los argumentos de las funciones son pasados por valor (así, si
    el valor del argumento dentro de la función cambia, este no
    cambia fuera de la función). Para permitir a una función modificar sus
    argumentos, éstos deben pasarse por referencia.
   </simpara>
   <para>
    Para hacer que un argumento a una función sea siempre pasado por referencia hay que anteponer
    al nombre del argumento el signo 'et' (&amp;) en la definición de la función:
   </para>
   <para>
    <example>
     <title>Paso de parámetros de una función por referencia</title>
     <programlisting role="php">
<![CDATA[
<?php
function añadir_algo(&$cadena)
{
    $cadena .= 'y algo más.';
}
$cad = 'Esto es un string, ';
añadir_algo($cad);
echo $cad;    // imprime 'Esto es un string, y algo más.'
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="functions.arguments.default">
   <title>Valores de argumentos predeterminados</title>

   <para>
    Una función puede definir valores predeterminados al estilo de C++ para argumentos
    escalares como sigue:
   </para>
   <para>
    <example>
     <title>Uso de parámetros predeterminados en funciones</title>
     <programlisting role="php">
<![CDATA[
<?php
function hacer_café($tipo = "capuchino")
{
    return "Hacer una taza de $tipo.\n";
}
echo hacer_café();
echo hacer_café(null);
echo hacer_café("espresso");
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Hacer una taza de capuchino.
Hacer una taza de .
Hacer una taza de espresso.
]]>
     </screen>
    </example>
   </para>
   <para>
    PHP también permite el uso de <type>array</type>s y del tipo especial &null;
    como valores predeterminados, por ejemplo:
   </para>
   <para>
    <example>
     <title>Usar tipos no escalares como valores predeterminados</title>
     <programlisting role="php">
<![CDATA[
<?php
function hacer_café($tipos = array("capuchino"), $fabricanteCafé = NULL)
{
    $aparato = is_null($fabricanteCafé) ? "las manos" : $fabricanteCafé;
    return "Hacer una taza de ".join(", ", $tipos)." con $aparato.\n";
}
echo hacer_café();
echo hacer_café(array("capuchino", "lavazza"), "una tetera");
?>
]]>
     </programlisting>
    </example>

   </para>
   <simpara>
    El valor predeterminado debe ser una expresión constante, no (por
    ejemplo) una variable, un miembro de una clase o una llamada a una función.
   </simpara>
   <para>
    Obsérvese que cuando se emplean argumentos predeterminados, cualquiera de ellos debería estar a
    la derecha de los argumentos no predeterminados; si no, las cosas
    no funcionarán como se esperaba. Considérese el siguiente trozo de código:
   </para>
   <para>
    <example>
     <title>Uso incorrecto de argumentos predeterminados en una función</title>
     <programlisting role="php">
<![CDATA[
<?php
function hacer_yogur($tipo = "acidófilo", $sabor)
{
    return "Hacer un tazón de yogur $tipo de $sabor.\n";
}

echo hacer_yogur("frambuesa");   // no funcionará como se esperaba
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Warning: Missing argument 2 in call to hacer_yogur() in
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Hacer un tazón de yogur frambuesa de .
]]>
     </screen>
    </example>
   </para>
   <para>
    Ahora, compare el ejemplo de arriba con este:
   </para>
   <para>
    <example>
     <title>Uso correcto de argumentos predeterminados en una función</title>
     <programlisting role="php">
<![CDATA[
<?php
function hacer_yogur($sabor, $tipo = "acidófilo")
{
    return "Hacer un tazón de yogur $tipo de $sabor.\n";
}

echo hacer_yogur("frambuesa");   // funciona como se esperaba
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Hacer un tazón de yogur acidófilo de frambuensa.
]]>
     </screen>
    </example>
   </para>
   <note>
    <simpara>
     A partir de PHP 5, los argumentos pasados por referencia pueden tener un valor predeterminado.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="functions.arguments.type-declaration">
   <title>Declaraciones de tipo</title>

   <note>
    <para>
     La declaración de tipos también se conoce como 'Determinación de tipos' en PHP 5.
    </para>
   </note>

   <para>
    Las declaraciones de tipo permiten a las funciones requerir que los parámetros sean de cierto tipo durante una llamada.
    Si el valor dado es de un tipo incorrecto,
    se generará un error: en PHP 5, este error es un error fatal
    recuperable, mientras que PHP 7 lanzará una excepción
    <classname>TypeError</classname>.
   </para>

   <para>
    Para especificar una declaración de tipo, debe anteponerse el nombre del tipo al
    nombre del parámetro. Se puede hacer que una declaración acepte valores &null; si
    el valor predeterminado del parámetro se establece a &null;.
   </para>

   <sect3 xml:id="functions.arguments.type-declaration.types">
    <title>Tipos válidos</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Tipo</entry>
        <entry>Descripción</entry>
        <entry>Versión de PHP mínima</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>nombre de clase/interfaz</entry>
        <entry>
         El parámetro debe ser una &instanceof; del nombre de la clase o interfaz
         dada.
        </entry>
        <entry>PHP 5.0.0</entry>
       </row>
       <row>
        <entry><literal>self</literal></entry>
        <entry>
         El parámetro debe ser una &instanceof; de la misma clase donde
         está definido el método. Esto solamente se puede utilizar en clases
         y métodos de instancia.
        </entry>
        <entry>PHP 5.0.0</entry>
       </row>
       <row>
        <entry><type>array</type></entry>
        <entry>
         El parámetro debe ser un <type>array</type>.
        </entry>
        <entry>PHP 5.1.0</entry>
       </row>
       <row>
        <entry><type>callable</type></entry>
        <entry>
         El parámetro debe ser un <type>callable</type> válido.
        </entry>
        <entry>PHP 5.4.0</entry>
       </row>
       <row>
        <entry><type>bool</type></entry>
        <entry>
         El parámetro debe ser un valor de tipo <type>boolean</type>.
        </entry>
        <entry>PHP 7.0.0</entry>
       </row>
       <row>
        <entry><type>float</type></entry>
        <entry>
         El parámetro debe ser un número de tipo <type>float</type>.
        </entry>
        <entry>PHP 7.0.0</entry>
       </row>
       <row>
        <entry><type>int</type></entry>
        <entry>
         El parámetro debe ser un valor de tipo <type>integer</type>.
        </entry>
        <entry>PHP 7.0.0</entry>
       </row>
       <row>
        <entry><type>string</type></entry>
        <entry>
         El parámetro debe ser un <type>string</type>.
        </entry>
        <entry>PHP 7.0.0</entry>
       </row>
        <row>
         <entry><literal>iterable</literal></entry>
         <entry>
          El parámetro debe ser un <type>array</type> o una &instanceof; <classname>Traversable</classname>.
         </entry>
         <entry>PHP 7.1.0</entry>
        </row>
        <row>
         <entry><literal>object</literal></entry>
         <entry>
          El parámetro debe ser un <type>object</type>.
         </entry>
         <entry>PHP 7.2.0</entry>
        </row>
      </tbody>
     </tgroup>
    </informaltable>

    <warning>
     <para>
      Los alias de los tipos escalares anteriores no están admitidos. En su lugar, son
      tratados como nombres de clases o de interfaces. Por ejemplo, el empleo de
      <literal>boolean</literal> como parámetro o como tipo devuelto requerirá
      un argumento o un valor devuelto que sea unaan &instanceof; de la clase o
      interfaz <literal>boolean</literal>, más que el tipo
      <type>bool</type>:
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
 <?php
 function prueba(boolean $param) {}
 prueba(true);
 ?>
 ]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
 Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1
 ]]>
       </screen>
      </informalexample>
     </para>
    </warning>
   </sect3>

   <sect3 xml:id="functions.arguments.type-declaration.examples">
    &reftitle.examples;
    <example>
     <title>Declaración básica de tipo clase</title>
     <programlisting role="php">
<![CDATA[
<?php
class C {}
class D extends C {}

// Esta no extiende a C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
C
D

Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
     </screen>
    </example>

    <example>
     <title>Declaración básica de tipo interfaz</title>
     <programlisting role="php">
<![CDATA[
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// Esta no implementa I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
C

Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
     </screen>
    </example>

     <example>
      <title>Tipos de parámetros pasados por referencia</title>
      <simpara>
       Los tipos declarados de parámetros de referencia se comprueban en la entrada de la función, pero
       no cuando la función vuelve, así que después de que la función haya vuelto, el
       el tipo de argumento puede haber cambiado.
      </simpara>
      <programlisting role="php">
<![CDATA[
<?php
function array_baz(array &$param)
{
    $param = 1;
}
$var = [];
array_baz($var);
var_dump($var);
array_baz($var);
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
int(1)

Fatal error: Uncaught TypeError: Argument 1 passed to array_baz() must be of the type array, int given, called in %s on line %d
]]>
      </screen>
     </example>
     <example>
      <title>Declaración de tipo nulo</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
      </screen>
     </example>
    </sect3>

   <sect3 xml:id="functions.arguments.type-declaration.strict">
    <title>Tipificación estricta</title>

    <para>
     Por defecto, PHP fuerza a los valores de un tipo erróneo a ser del tipo
     escalar esperado si es posible. Por ejemplo, una función a la que se le pasa un
     <type>integer</type> para un parámetro que se prevé sea un <type>string</type>
     obtendrá una variable de tipo <type>string</type>.
    </para>

    <para>
     Es posible habilitar el modo estricto en función de cada fichero. El el modo
     estricto solamente será aceptada una variable del tipo exacto de la declaración
     de tipo, o será lanzada una <classname>TypeError</classname>. La
     única excepción a esta regla es que se podría proporcionar un <type>integer</type>
     a una función que espere un <type>float</type>. Las llamadas a funciones desde dentro
     de funciones internas no se verán afectadas por la declaración
     <literal>strict_types</literal>.
    </para>

    <para>
     Para habilitar el modo escricto se emplea la sentencia &declare; con la
     declaración <literal>strict_types</literal>:
    </para>

    <caution>
     <para>
      Habilitar el modo esctricto también afectará a las
      <link linkend="functions.returning-values.type-declaration">declaraciones de tipo de devolución</link>.
     </para>
    </caution>

    <note>
     <para>
      La tipificación estricta se aplica a las llamadas a funciones hechas desde
      <emphasis>dentro</emphasis> del fichero con la tipificación estricta habilitada, no a
      las funciones declaradas dentro del fichero. Si un fichero sin la tipificación estricta
      habilitada realiza una llamada a una función definida en un fichero
      con tipificación estricta, será respetada la preferencia del llamador
      (tipificación débil), y se forzará el valor.
     </para>
    </note>

    <note>
     <para>
      La tipificación estricta solamente se define para declaraciones de tipos escalares, y como
      tal, requiere PHP 7.0.0 o posterior, ya que las declaraciones de tipo escalar fueron
      añadidas en esta versión.
     </para>
    </note>

    <example>
     <title>Tipificación estricta</title>
     <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
]]>
     </screen>
    </example>

    <example>
     <title>Tipificación débil</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// Estos números serán forzados a ser enteros: ¡observe la salida de abajo!
var_dump(sum(1.5, 2.5));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
int(3)
int(3)
]]>
     </screen>
    </example>

    <example>
     <title>Capturar la excepción <classname>TypeError</classname></title>
     <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Error: '.$e->getMessage();
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
int(3)
Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10
]]>
     </screen>
    </example>
   </sect3>
  </sect2>
  <sect2 xml:id="functions.variable-arg-list">
   <title>Listas de argumentos de longitud variable</title>

   <simpara>
    PHP tiene soporte para listas de argumentos de longitud variable en
    funciones definidas por el usuario. Esto se implementa utilizando el
    token <literal>...</literal> en PHP 5.6 y posteriores, y utilizando las funciones
    <function>func_num_args</function>,
    <function>func_get_arg</function>, y
    <function>func_get_args</function> en PHP 5.5 y anteriores.
   </simpara>

   <sect3 xml:id="functions.variable-arg-list.new">
    <title><literal>...</literal> en PHP 5.6+</title>

    <para>
     En PHP 5.6 y posteriores, las listas de argumentos pueden incluir el
     token <literal>...</literal> para denotar que la función acepta un
     número variable de argumentos. Los argumentos serán pasados a la
     variable dada como un aryay, por ejemplo:

     <example>
      <title>Usando <literal>...</literal> para acceder a argumentos variables</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(...$números) {
    $acc = 0;
    foreach ($números as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
10
]]>
      </screen>
     </example>
    </para>

    <para>
     También se puede emplear <literal>...</literal> al llamar a funciones para convertir
     un <type>array</type> o variable <classname>Traversable</classname> o
     literal en una lista de argumentos:

     <example>
      <title>Usar <literal>...</literal> para proporcionar argumentos</title>
      <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
3
3
]]>
      </screen>
     </example>
    </para>

    <para>
     Se puede especifcar argumentos posicionales normales antes del
     token <literal>...</literal>. En este caso, solamente los argumentos al final
     que no coincidan con un argumento posicional serán añadidos al array
     generado por <literal>...</literal>.
    </para>

    <para>
     También es posible añadir una
     <link linkend="language.types.declarations">declaración de tipo</link> antes del
     símbolo <literal>...</literal>. Si está presente, todos los argumentos
     capturados por <literal>...</literal> deben ser objetos de la clase implicada.

     <example>
      <title>Argumentos variables de declaración de tipo</title>
      <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Esto fallará, debido a que  null no es un objeto de DateInterval.
echo total_intervals('d', null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
      </screen>
     </example>
    </para>

    <para>
     Por último, también es pueden pasar argumentos variables
     <link linkend="functions.arguments.by-reference">por referencia</link>
     prefijando <literal>...</literal> con el signo
     (<literal>&amp;</literal>).
    </para>
   </sect3>

   <sect3 xml:id="functions.variable-arg-list.old">
    <title>Versiones antiguas de PHP</title>

    <para>
     No se requiere una sintaxis especial para señalar que una función es varíadica;
     sin embargo, para acceder a los argumentos de la función se debe usar
     <function>func_num_args</function>, <function>func_get_arg</function>
     y <function>func_get_args</function>.
    </para>

    <para>
     El primer ejemplo de antes se implementaría en PHP 5.5 y anteriores
     como sigue:

     <example>
      <title>Acceder a argumentos variables en PHP 5.5 y anteriores</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
10
]]>
      </screen>
     </example>
    </para>
   </sect3>

  </sect2>

  <sect2 xml:id="functions.named-arguments">
    <title>Named Arguments</title>

    <para>
     PHP 8.0.0 introduced named arguments as an extension of the existing
     positional parameters. Named arguments allow passing arguments to a
     function based on the parameter name, rather than the parameter position.
     This makes the meaning of the argument self-documenting, makes the
     arguments order-independent and allows skipping default values arbitrarily.
    </para>

    <para>
     Named arguments are passed by prefixing the value with the parameter name
     followed by a colon. Using reserved keywords as parameter names is allowed.
     The parameter name must be an identifier, specifying dynamically
     is not allowed.
    </para>

    <example>
     <title>Named argument syntax</title>
     <programlisting role="php">
      <![CDATA[
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// NOT supported.
function_name($variableStoringParamName: $value);
?>
]]>
     </programlisting>
    </example>

    <example>
     <title>Positional arguments versus named arguments</title>
     <programlisting role="php">
      <![CDATA[
<?php
// Using positional arguments:
array_fill(0, 100, 50);

// Using named arguments:
array_fill(start_index: 0, count: 100, value: 50);
?>
]]>
     </programlisting>
    </example>

    <para>
     The order in which the named arguments are passed does not matter.
    </para>

    <example>
     <title>Same example as above with a different order of parameters</title>
     <programlisting role="php">
      <![CDATA[
<?php
array_fill(value: 50, num: 100, start_index: 0);
?>
]]>
     </programlisting>
    </example>

    <para>
     Named arguments can be combined with positional arguments. In this case,
     the named arguments must come after the positional arguments.
     It is also possible to specify only some of the optional arguments of a
     function, regardless of their order.
    </para>

    <example>
     <title>Combining named arguments with positional arguments</title>
     <programlisting role="php">
      <![CDATA[
<?php
htmlspecialchars($string, double_encode: false);
// Same as
htmlspecialchars($string, ENT_COMPAT | ENT_HTML401, 'UTF-8', false);
?>
]]>
     </programlisting>
    </example>

    <para>
     Passing the same parameter multiple times results in an Error exception.
    </para>

    <example>
     <title>Error exception when passing the same parameter multiple times</title>
     <programlisting role="php">
      <![CDATA[
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument
foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument
?>
]]>
     </programlisting>
    </example>

   </sect2>
  </sect1>

 <sect1 xml:id="functions.returning-values">
  <title>Devolver valores</title>

  <para>
   Los valores son devueltos usando la sentencia opcional return. Se
   puede devolver cualquier tipo, incluidos arrays y objetos. Esto causa que la
   función finalice su ejecución inmediatamente y pase el control de nuevo a
   la línea desde la que fue llamada. Véase <function>return</function>
   para más información.
  </para>

  <note>
   <para>
    Si se omite <function>return</function>, el valor devuelto será
    &null;.
   </para>
  </note>

  <sect2>
   <title>Empleo de return</title>
   <para>
    <example>
     <title>Empleo de <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function cuadrado($núm)
{
    return $núm * $núm;
}
echo cuadrado(4);   // imprime '16'.
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Una función no puede devolver múltiples valores, pero se pueden obtener resultados
    similares devolviendo un array.
   </para>
   <para>
    <example>
     <title>Devolver un array para obtener múltiples valores</title>
     <programlisting role="php">
<![CDATA[
<?php
function números_pequeños()
{
    return array (0, 1, 2);
}
list ($cero, $uno, $dos) = números_pequeños();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Para devolver una referencia desde una función use el operador de referencia &amp;, en
    la declaración de la función y cuando se asigne el valor devuelto a una
    variable:
   </para>
   <para>
    <example>
     <title>Devolver una referencia desde una función</title>
     <programlisting role="php">
<![CDATA[
<?php
function &devolver_referencia()
{
    return $algunaref;
}

$nuevaref =& devolver_referencia();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Para más información sobre referencias, por favor, lea las <link
    linkend="language.references">Referencias explicadas</link>.
   </simpara>
  </sect2>

  <sect2 xml:id="functions.returning-values.type-declaration">
   <title>Declaraciones de tipo de devolución</title>

   <para>
    PHP 7 añade soporte para las declaraciones de tipo de devolución. De forma similar a las
    <link linkend="functions.arguments.type-declaration">declaraciones de tipo de argumento</link>,
    las declaraciones de tipo de devolución especifican el tipo del valor que serán
    devuelto desde una función. Están disponibles los mismos
    <link linkend="functions.arguments.type-declaration.types">tipos</link>
    para las declaraciones de tipo de devolución que para las declaraciones
    de tipo de argumento.
   </para>

   <para>
    La <link linkend="functions.arguments.type-declaration.strict">tipificación estricta</link>
    también tiene efecto sobre las declaraciones de tipo de devolución. En el modo predeterminado de tipificacón débil,
    los valores devueltos serán forzados al tipo correcto si no son ya
    de ese tipo. En el modo fuerte, el valor devuelto debe ser del
    tipo correcto, o de lo contrario se lanzará una excepción <classname>TypeError</classname>.
   </para>

    <para>
    A partir de PHP 7.1.0, los valores de retorno pueden ser marcados como anulables anteponiendo el prefijo
    nombre de tipo con un signo de interrogación (<literal>?</literal>). Esto significa que
    la función devuelve el tipo especificado o &null;.
   </para>

   <note>
    <para>
     Al sobrescribir un método padre, el método hijo debe hacer coincidir cualquier
     declaración de tipo de devolución del padre. Si el padre no define un tipo de
     devolución, el método hijo puede hacerlo.
    </para>
   </note>

   <sect3 xml:id="functions.returning-values.type-declaration.examples">
    &reftitle.examples;

    <example>
     <title>Declaración básica de tipo de devolución</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Observe que será devuelto un float.
var_dump(sum(1, 2));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
float(3)
]]>
     </screen>
    </example>

    <example>
     <title>El modo estricto en acción</title>
     <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
]]>
     </screen>
    </example>

    <example>
     <title>Devolver un objeto</title>
     <programlisting role="php">
<![CDATA[
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
object(C)#1 (0) {
}
]]>
     </screen>
    </example>

    <example>
      <title>Declaración de tipo de retorno anulable (a partir de PHP 7.1.0)</title>
      <programlisting role="php">
<![CDATA[
<?php
function get_item(): ?string {
    if (isset($_GET['item'])) {
        return $_GET['item'];
    } else {
        return null;
    }
}
?>
]]>
      </programlisting>
     </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.variable-functions">
  <title>Funciones variables</title>

  <para>
   PHP admite el concepto de funciones variables. Esto significa que si
   un nombre de variable tiene paréntesis anexos a él, PHP buscará
   una función con el mismo nombre que lo evaluado por la variable,
   e intentará ejecutarla. Entre otras cosas, esto se puede
   usar para implementar llamadas de retorno, tablas de funciones, y así sucesivamente.
  </para>
  <para>
   Las funciones variables no funcionarán con constructores de lenguaje como
   <function>echo</function>, <function>print</function>,
   <function>unset</function>, <function>isset</function>,
   <function>empty</function>, <function>include</function>,
   <function>require</function> y similares. Utilice funciones de envoltura para hacer
   uso de cualquiera de estos constructores como funciones variables.
  </para>
  <para>
   <example>
    <title>Ejemplo de función variable</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "En foo()<br />\n";
}

function bar($arg = '')
{
    echo "En bar(); el argumento era '$arg'.<br />\n";
}

// Esta es una función de envoltura alrededor de echo
function hacerecho($cadena)
{
    echo $cadena;
}

$func = 'foo';
$func();        // Esto llama a foo()

$func = 'bar';
$func('prueba');  // Esto llama a bar()

$func = 'hacerecho';
$func('prueba');  // Esto llama a hacerecho()
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Los métodos de objetos también puede ser llamados con la sintaxis de funciones variables.
   <example>
    <title>Ejemplo de método variable</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $nombre = 'Bar';
        $this->$nombre(); // Esto llama al método Bar()
    }

    function Bar()
    {
        echo "Esto es Bar";
    }
}

$foo = new Foo();
$nombrefunc = "Variable";
$foo->$nombrefunc();  // Esto llama a $foo->Variable()

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Cuando se llaman a métodos estáticos, la llamada a la función es más fuerte que el operador de propiedad estática:
   <example>
    <title>Ejemplo de método variable con propiedades estáticas</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'propiedad estática';
    static function Variable()
    {
        echo 'Método Variable llamado';
    }
}

echo Foo::$variable; // Esto imprime 'propiedad estática'. No necesita una $variable en este ámbito.
$variable = "Variable";
Foo::$variable();  // Esto llama a $foo->Variable() leyendo $variable en este ámbito.

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   A partir de PHP 5.4.0, se puede llamar a cualquier <type>callable</type> almacenado en una variable.
   <example>
    <title>Llamables complejos</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // imprime "bar"
$func = array(new Foo, "baz");
$func(); // imprime "baz"
$func = "Foo::bar";
$func(); // imprime "bar" a partrid de PHP 7.0.0; antes, emitía un error fatal
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   Véase también <function>is_callable</function>, <function>call_user_func</function>,
   <link linkend="language.variables.variable">
    variables variables</link> y <function>function_exists</function>.
  </para>

  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.0.0</entry>
        <entry>
         'NombreDeClase::NombreDeMétodo' se permite como función variable.
        </entry>
       </row>
       <row>
        <entry>5.4.0</entry>
        <entry>
         Los arrays, que son llamables válidos, están permitidos como funciones variables.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.internal">
  <title>Funciones internas (incluidas)</title>

  <para>
   PHP se estandariza con muchas funciones y construcciones. También existen
   funciones que necesitan extensiones específicas de PHP compiladas, si no,
   aparecerán errores fatales "undefined function" ("función no definida"). Por ejemplo,
   para usar las funciones de <link linkend="ref.image">image</link> tales como
   <function>imagecreatetruecolor</function>, PHP debe ser compilado con
   soporte para <productname>GD</productname>. O para usar
   <function>mysql_connect</function>, PHP debe ser compilado con
   soporte para <link linkend="book.mysqli">MySQLi</link>. Hay muchas funciones de núcleo
   que está incluidas en cada versión de PHP, tales como las
   funciones de <link linkend="ref.strings">string</link> y de
   <link linkend="ref.var">variable</link>. Una llamada
   a <function>phpinfo</function> o
   <function>get_loaded_extensions</function> mostrará las extensiones que están
   cargadas en PHP. Observe también que muchas extensiones están habilitadas por defecto y
   que el manual de PHP está dividido por extensiones. Véase
   <link linkend="configuration">configuración</link>,
   <link linkend="install">instalación</link>, y capítulos individuales
   de extensiones para más información sobre cómo configurar PHP.
  </para>
  <para>
   Interpretar y comprender un prototipo de una función está explicado dentro de
   la sección del manual titulada <link linkend="about.prototypes">cómo interpretar
   la definición de una función</link>. Es importante comprender lo que devuelve una
   función o si una función funciona directamente con un valor pasado. Por ejemplo,
   <function>str_replace</function> devolverá la cadena modificada mientras que
   <function>usort</function> funciona con la variable actual pasada.
   Cada página del manual también tiene información específica para cada
   función, como información sobre parámetros de funciones, cambios de comportamiento,
   valores devueltos en caso de éxito o fallo, e información de disponibilidad.
   Conocer estas importantes diferencias (a menudo imperceptibles) es crucial para
   escribir código de PHP correcto.
  </para>
  <note>
   <simpara>
    Si los parámetros dados a una función no son los que se esperaban, como
    pasar un <type>array</type> donde se esperaba un <type>string</type>,
    el valor devuelto de la función será indefinido. En este caso lo más probable
    es que devuelva &null; pero esto es sólo una convención, y no se puede confiar
    en ello.
   </simpara>
  </note>
  <para>
   Véase también <function>function_exists</function>,
   <link linkend="funcref">la referencia de funciones</link>,
   <function>get_extension_funcs</function>, y
   <function>dl</function>.
  </para>
 </sect1>

 <sect1 xml:id="functions.anonymous">
  <title>Funciones anónimas</title>

  <simpara>
   Las funciones anónimas, también conocidas como <literal>cierres</literal> (closures), permiten
   la creación de funciones que no tienen un nombre especificado. Son más útiles como
   valor de los parámetros de <literal>llamadas de retorno</literal>,
   pero tienen muchos otros usos.
  </simpara>
  <simpara>
   Las funciones anónimas están implementadas utilizando la clase <link linkend="class.closure">
   <classname>Closure</classname></link>.
  </simpara>

  <example>
   <title>Ejemplo de función anónima</title>
   <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($coincidencia) {
    return strtoupper($coincidencia[1]);
}, 'hola-mundo');
// imprime holaMundo
?>
]]>
   </programlisting>
  </example>

  <simpara>
   Los cierres también se pueden usar como valores de variables; PHP automáticamente
   convierte tales expresiones en instancias de la
   clase interna <classname>Closure</classname>. La asignación de un cierre a una
   variable emplea la misma sintaxis que cualquier otra asignación, incluido el
   punto y coma final:
  </simpara>

  <example>
   <title>Ejemplo de asignación de variable de una función anónima</title>
   <programlisting role="php">
<![CDATA[
<?php
$saludo = function($nombre)
{
    printf("Hola %s\r\n", $nombre);
};

$saludo('Mundo');
$saludo('PHP');
?>
]]>
   </programlisting>
  </example>

  <simpara>
   Los cierres también pueden heredar variables del ámbito padre. Cualquier
   variable debe ser pasada al constructor de lenguaje <literal>use</literal>.
   Desde PHP 7.1, estas variables no deben incluir &link.superglobals;,
   <varname>$this</varname>, o variables con el mismo nombre que un parámetro.
  </simpara>

  <example>
   <title>Heredar variables de un ámbito padre</title>
   <programlisting role="php">
<![CDATA[
<?php
$mensaje = 'hola';

// Sin "use"
$ejemplo = function () {
    var_dump($mensaje);
};
$ejemplo();

// Heredar $mensaje
$ejemplo = function () use ($mensaje) {
    var_dump($mensaje);
};
$ejemplo();

// El valor de la variable heredada está cuando la función
// está definida, no cuando se le invoca
$mensaje = 'mundo';
$ejemplo();

// Reiniciar el mensaje
$mensaje = 'hola';

// Heredar por referencia
$ejemplo = function () use (&$mensaje) {
    var_dump($mensaje);
};
$ejemplo();

// El valor cambiado en el ámbito padre
// se refleja dentro de la llamada a la función
$mensaje = 'mundo';
$ejemplo();

// Los cierres también aceptan argumentos normales
$ejemplo = function ($arg) use ($mensaje) {
    var_dump($arg . ' ' . $mensaje);
};
$ejemplo("hola");
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(4) "hola"
string(4) "hola"
string(4) "hola"
string(5) "mundo"
string(10) "hola mundo"
]]>
   </screen>
  </example>

  <simpara>
   Heredar variables del ámbito padre <emphasis>no</emphasis>
   es lo mismo que usar variables globales.
   Las variables globales existen en el ámbito global, lo que implica que no
   importa qué función se esté ejecutando. El ámbito padre de un cierre es la
   función en la que dicho cierre fue declarado (no necesariamente la función
   desde la que se llamó). Vea el siguiente ejemplo:
  </simpara>

  <example>
   <title>Cierres y ámbito</title>
   <programlisting role="php">
<![CDATA[
<?php
// Un carro de compras básico que contiene una lista de productos añadidos
// y la cantidad de cada producto. Incluye un método que
// calcula el precio total de los artículos del carro usando un
// cierre como llamada de retorno.
class Carro
{
    const PRECIO_MANTEQUILLA = 1.00;
    const PRECIO_LECHE       = 3.00;
    const PRECIO_HUEVOS      = 6.95;

    protected $productos = array();

    public function añadir($producto, $cantidad)
    {
        $this->productos[$producto] = $cantidad;
    }

    public function obtenerCantidad($producto)
    {
        return isset($this->productos[$producto]) ? $this->productos[$producto] :
               FALSE;
    }

    public function obtenerTotal($impuesto)
    {
        $total = 0.00;

        $llamadaDeRetorno =
            function ($cantidad, $producto) use ($impuesto, &$total)
            {
                $precioUnidad = constant(__CLASS__ . "::PRECIO_" .
                    strtoupper($producto));
                $total += ($precioUnidad * $cantidad) * ($impuesto + 1.0);
            };

        array_walk($this->productos, $llamadaDeRetorno);
        return round($total, 2);
    }
}

$mi_carro = new Carro;

// Añadir algunos artículos al carro
$mi_carro->añadir('mantequilla', 1);
$mi_carro->añadir('leche', 3);
$mi_carro->añadir('huevos', 6);

// Imprimir el total con un impuesto de venta del 5%.
print $mi_carro->obtenerTotal(0.05) . "\n";
// El resultado es 54.29
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Vinculación automática de <literal>$this</literal></title>
   <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
   </screen>
   &example.outputs.53;
   <screen>
<![CDATA[
Notice: Undefined variable: this in script.php on line 8
NULL]]>
   </screen>
  </example>

  <para>
   A partir de PHP 5.4.0, cuando se declara en el contexto de una clase, la clase actual está
   vinculada a ella automáticamente, haciendo que <literal>$this</literal> esté disponible
   dentro del ámbito de la función. Si no se desea esta vinculación automática
   de la clase actual, se deberían usar
   <link linkend="functions.anonymous-functions.static">funcions anónimas
    estáticas</link> en su lugar.
  </para>

  <sect2 xml:id="functions.anonymous-functions.static">
   <title>Static anonymous functions</title>
   <para>
    A partir de PHP 5.4, las funciones anónimas pueden ser declaradas estáticamente. Esto
    evita tener la clase actual vinculada automáticamente a
    ellas. Los objetos tampoco podrían vincularse a ellas durante la ejecución.
   </para>
   <para>
    <example>
     <title>Intentar usar <literal>$this</literal> dentro de una función anónima estática</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
     </screen>
    </example>
   </para>

   <para>
    <example>
     <title>Intentar vincular un objeto a una función anónima estática</title>
     <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // cuerpo de la función
};
$func = $func->bindTo(new StdClass);
$func();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
     </screen>
    </example>
   </para>
  </sect2>

  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.1.0</entry>
        <entry>
         Las funciones anónimas no pueden tener un cierre sobre &link.superglobals;,
         <varname>$this</varname>, o cualquier variable con el mismo nombre que un
         parámetro.
        </entry>
       </row>
       <row>
        <entry>5.4.0</entry>
        <entry>
         Las funciones anónimas pueden usar <varname>$this</varname>, así como ser
         declaradas státicamente.
        </entry>
       </row>
       <row>
        <entry>5.3.0</entry>
        <entry>
         Las funciones anónimas se encuentran disponibles.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>

<sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Es posible utilizar <function>func_num_args</function>,
      <function>func_get_arg</function>, y <function>func_get_args</function>
      desde dentro de un cierre.
     </simpara>
    </note>
   </sect2>

  </sect1>
  <sect1 xml:id="functions.arrow">
   <title>Funciones de flecha</title>

   <simpara>
    Las funciones de flecha fueron introducidas en PHP 7.4 como una sintaxis más concisa para
    <link linkend="functions.anonymous">las funciones anónimas</link>.
   </simpara>
   <simpara>
    Tanto las funciones anónimas como las funciones de flecha se implementan utilizando la
    clase <link linkend="class.closure"><classname>Closure</classname></link>.
   </simpara>

   <simpara>
    Las funciones de las flechas tienen la forma básica
    <code>fn (argument_list) =&gt; expr</code>.
   </simpara>

   <simpara>
    Las funciones de las flechas soportan las mismas características que
    <link linkend="functions.anonymous">las funciones anónimas</link>,
    excepto que el uso de variables del ámbito padre siempre es automático.
   </simpara>

   <simpara>
    Cuando una variable utilizada en la expresión se define en el ámbito padre
    será implícitamente capturada por valor.
    En el siguiente ejemplo, las funciones <varname>$fn1</varname> y
    <varname>$fn2</varname> se comportan de la misma manera.
   </simpara>

   <para>
    <example>
     <title>Las funciones de flecha capturan las variables por valor automáticamente</title>
     <programlisting role="php">
<![CDATA[
<?php

$y = 1;

$fn1 = fn($x) => $x + $y;
// equivalent to using $y by value:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
4
]]>
      </screen>
    </example>
   </para>
   <simpara>
    Esto también funciona si las funciones de la flecha están anidadas:
   </simpara>
   <para>
    <example>
     <title>Las funciones de flecha capturan variables por valor automáticamente, incluso cuando están anidadas</title>
     <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// Outputs 51
var_export($fn(5)(10));
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    De manera similar a las funciones anónimas,
    la sintaxis de la función de la flecha permite firmas de funciones arbitrarias,
    incluyendo los tipos de parámetros y de retorno, valores por defecto, variadades,
    así como por referencia al pasar y al regresar.
    Todos los siguientes son ejemplos válidos de las funciones de las flechas:
   </simpara>
   <para>
    <example>
     <title>Ejemplos de funciones de flecha</title>
     <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Las funciones de flecha utilizan la unión variable por valor.
    Esto es aproximadamente equivalente a realizar un <code>use($x)</code> para cada
    variable  <varname>$x</varname> usada dentro de la función de la flecha.
    Una unión por valores significa que no es posible modificar ningún valor
    desde el ámbito exterior.
    <link linkend="functions.anonymous">Funciones anónimas</link>
    se pueden utilizar en su lugar para las asignaciones por referencia.
   </simpara>
   <para>
    <example>
     <title>Los valores del alcance exterior no pueden ser modificados por las funciones de flecha</title>
     <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // No tiene ningún efecto
$fn();
var_export($x);  // Salida 1

?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.4.0</entry>
         <entry>
          Las funciones de flecha se hicieron disponibles.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Es posible utilizar <function>func_num_args</function>,
      <function>func_get_arg</function>, y <function>func_get_args</function>
      desde dentro de una función de flecha.
     </simpara>
    </note>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.first_class_callable_syntax">
   <title>First class callable syntax</title>

   <para>
    The first class callable syntax is introduced as of PHP 8.1.0, as a way of creating <link linkend="functions.anonymous">anonymous functions</link> from <link linkend="language.types.callable">callable</link>.
    It supersedes existing callable syntax using strings and arrays.
    The advantage of this syntax is that it is accessible to static analysis, and uses the scope at the point where the callable is acquired.
   </para>

   <para>
    <code>CallableExpr(...)</code> syntax is used to create a <classname>Closure</classname> object from callable. <code>CallableExpr</code> accepts any expression that can be directly called in the PHP grammar:
    <example>
     <title>Simple first class callable syntax</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo {
   public function method() {}
   public static function staticmethod() {}
   public function __invoke() {}
}

$obj = new Foo();
$classStr = 'Foo';
$methodStr = 'method';
$staticmethodStr = 'staticmethod';


$f1 = strlen(...);
$f2 = $obj(...);  // invokable object
$f3 = $obj->method(...);
$f4 = $obj->$methodStr(...);
$f5 = Foo::staticmethod(...);
$f6 = $classStr::$staticmethodStr(...);

// traditional callable using string, array
$f7 = 'strlen'(...);
$f8 = [$obj, 'method'](...);
$f9 = [Foo::class, 'staticmethod'](...);
?>
]]>
     </programlisting>
    </example>
   </para>

   <note>
    <para>
      The <code>...</code> is part of the syntax, and not an omission.
    </para>
   </note>

   <para>
    <code>CallableExpr(...)</code> has the same semantics as <methodname>Closure::fromCallable</methodname>.
    That is, unlike callable using strings and arrays, <code>CallableExpr(...)</code> respects the scope at the point where it is created:
    <example>
     <title>Scope comparison of <code>CallableExpr(...)</code> and traditional callable</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo {
    public function getPrivateMethod() {
        return [$this, 'privateMethod'];
    }

    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}

$foo = new Foo;
$privateMethod = $foo->getPrivateMethod();
$privateMethod();
// Fatal error: Call to private method Foo::privateMethod() from global scope
// This is because call is performed outside from Foo and visibility will be checked from this point.

class Foo1 {
    public function getPrivateMethod() {
        // Uses the scope where the callable is acquired.
        return $this->privateMethod(...); // identical to Closure::fromCallable([$this, 'privateMethod']);
    }

    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}

$foo1 = new Foo1;
$privateMethod = $foo1->getPrivateMethod();
$privateMethod();  // Foo1::privateMethod
?>
]]>
     </programlisting>
    </example>

   </para>

   <note>
    <para>
     La creación de objetos mediante esta sintaxis (por ejemplo, <code>new Foo(...)</code>) no está soportada, porque la sintaxis <code>new Foo()</code> no se considera una llamada.
    </para>
   </note>

   <note>
    <para>
     La sintaxis de llamada de primera clase no se puede combinar con el <link linkend="language.oop5.basic.nullsafe">operador nullsafe</link>. Ambos de los siguientes resultan en un error en tiempo de compilación:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj?->method(...);
$obj?->prop->method(...);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </note>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
