<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: bafb2042b6c75f62f2678e55265b1918f280f8f3 Maintainer: yago Status: ready -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operadores</title>
  <simpara>
   Un operador es algo a lo que usted entrega uno o más valores (o
   expresiones, en jerga de programación) y produce otro valor (de modo que
   la construcción misma se convierte en una expresión). Así que puede
   pensar sobre las funciones o construcciones que devuelven un valor (como
   print) como operadores, y en aquellas que no devuelven nada (como echo)
   como cualquier otra cosa.
  </simpara>
  <para>
   Existen tres tipos de operadores. En primer lugar se encuentra el
   operador unario, el cual opera sobre un único valor, por ejemplo !  (el
   operador de negación) o ++ (el operador de incremento). El segundo grupo
   se conoce como operadores binarios; este grupo contiene la mayoría de
   operadores que soporta PHP, y una lista se encuentra disponible más
   adelante en la sección <link linkend="language.operators.precedence">Precedencia de Operadores</link>.
  </para>
  <para>
   El tercer grupo consiste del operador ternario: ?:. Éste debe ser usado
   para seleccionar entre dos expresiones, en base a una tercera, en lugar
   de seleccionar dos sentencias o rutas de ejecución. Rodear las
   expresiones ternarias con paréntesis es una muy buena idea.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Precedencia de Operadores</title>
   <para>
    La precedencia de un operador indica qué tan "cerca" se agrupan dos
    expresiones. Por ejemplo, en la expresión <literal>1 + 5 * 3</literal>,
    la respuesta es <literal>16</literal> y no <literal>18</literal>, ya que
    el operador de multiplicación ("*") tiene una mayor precedencia que el
    operador de adición ("+"). Los paréntesis pueden ser usados para marcar
    la precedencia, si resulta necesario. Por ejemplo: <literal>(1 + 5) *
    3</literal> evalúa a <literal>18</literal>. Si la precedencia de los
    operadores es la misma, se utiliza una asociación de izquierda a
    derecha.
   </para>
   <para>
    La siguiente tabla lista la precedencia de los operadores, con aquellos
    de mayor precedencia listados al comienzo de la tabla. Los operadores en
    la misma línea tienen la misma precedencia, en cuyo caso su
    asociatividad decide el orden para evaluarlos.
    <table>
     <title>Precedencia de Operadores</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Asociatividad</entry>
        <entry>Operadores</entry>
        <entry>Información Adicional</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>no-asociativo</entry>
        <entry>clone new</entry>
        <entry><link linkend="language.oop5.cloning">clone</link> y <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>++ --</entry>
        <entry>
         <link
         linkend="language.operators.increment">incremento/decremento</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>~ - (int) (float) (string) (array) (object) (bool) @</entry>
        <entry>
         <link linkend="language.types">tipos</link>
        </entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>instanceof</entry>
        <entry>
         <link linkend="language.types">tipos</link>
        </entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>!</entry>
        <entry>
         <link linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>* / %</entry>
        <entry>
         <link
         linkend="language.operators.arithmetic">aritmética</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>+ - .</entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmética</link>&listendand;
         <link linkend="language.operators.string">cadena</link></entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">manejo de bits</link>
        </entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>&lt; &lt;= &gt; &gt;= &lt;&gt;</entry>
        <entry>
         <link
         linkend="language.operators.comparison">comparación</link>
        </entry>
       </row>
       <row>
        <entry>no-asociativos</entry>
        <entry>== != === !==</entry>
        <entry>
         <link
         linkend="language.operators.comparison">comparación</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">manejo de bits</link>&listendand; 
         <link linkend="language.references">referencias</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">manejo de
         bits</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">manejo de
         bits</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>||</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>? :</entry>
        <entry>
         <link
         linkend="language.operators.comparison.ternary">ternario</link>
        </entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= =&gt;
        </entry>
        <entry>
         <link
         linkend="language.operators.assignment">asignación</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>and</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>xor</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>or</entry>
        <entry>
         <link
         linkend="language.operators.logical">lógicos</link>
        </entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>,</entry>
        <entry>varios usos</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    La asociatividad de izquierda quiere decir que la expresión es evaluada
    desde la izquierda a la derecha, la asociatividad de derecha quiere
    decir lo contrario.
    <example>
     <title>Asociatividad</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    Use paréntesis para incrementar la legibilidad del código.
   </para>
   <note>
    <para>
     Aunque <literal>=</literal> tiene una menor precedencia que la mayoría
     de los demás operadores, PHP aun permite expresiones similares a la
     siguiente: <literal>if (!$a = foo())</literal>, en cuyo caso el valor
     de retorno de <literal>foo()</literal> va a dar a
     <varname>$a</varname>.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Operadores de Aritmética</title>
   <simpara>
    ¿Recuerda la aritmética básica del colegio?  Éstos operadores funcionan
    tal como aquéllos.
   </simpara>
   <table>
    <title>Operadores de Aritmética</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>Negación</entry>
       <entry>El opuesto de <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Adición</entry>
       <entry>Suma de <varname>$a</varname> y <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Substracción</entry>
       <entry>Diferencia entre <varname>$a</varname> y <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Multiplicación</entry>
       <entry>Producto de <varname>$a</varname> y <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>División</entry>
       <entry>Cociente de <varname>$a</varname> y <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Módulo</entry>
       <entry>Resto de <varname>$a</varname> dividido por <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    El operador de división ("/") devuelve un valor flotante a menos que los
    dos operandos sean enteros (o cadenas que son convertidas a enteros) y
    los números sean divisibles sin residuos, en cuyo caso se devuelve un
    valor entero.
   </simpara>
   <simpara>
    Los operandos del módulo son convertidos a enteros (removiendo la parte
    decimal) antes de ser procesados.
   </simpara>
   <note>
    <simpara>
     El resto de <literal>$a % $b</literal> es negativo para valores
     negativos de <literal>$a</literal>.
    </simpara>
   </note>
   <simpara>
    Vea también la página del manual sobre 
    <link linkend="ref.math">Funciones mateméticas</link>.
   </simpara>

  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Operadores de Asignación</title>
   <simpara>
    El operador básico de asignación es "=". A primera vista, usted podría
    pensar en él como "es igual a". No lo haga. Lo que quiere decir en
    realidad es que el operando de la izquierda recibe el valor de la
    expresión a la derecha (es decir, "se define a").
   </simpara>
   <para>
    El valor de una expresión de asignación es el valor que se asigna. Es
    decir, el valor de "<literal>$a = 3</literal>" es 3. Esto le permite hacer una que otra
    cosa curiosa:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a es igual a 9 ahora, y $b ha sido definido a 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    En <type>arrays</type>, para asignar el valor a una clave determinada se realiza utilizando el
    operador "=&gt;". La <link linkend="language.operators.precedence">precedencia</link>
    de este operador es la misma que otros operadores de asignación.
   </para>   
   <para>
    En conjunto con el operador básico de asignación, existen "operadores
    combinados" para todos los operadores de <link
    linkend="language.operators">aritmética binaria</link>, unión de
    matrices y de cadenas, que le permiten usar un valor en una expresión y
    luego definir su valor como el resultado de esa expresión. Por ejemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // define $a como 8, como si hubiésemos dicho: $a = $a + 5;
$b = "¡Hola ";
$b .= "a todos!"; // define $b como "¡Hola a todos!", tal como $b = $b . "a todos!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Note que la asignación copia la variable original en la nueva
    (asignación por valor), de modo que cualquier cambio a una no afecta a
    la otra. Esto puede resultar de importancia si necesita copiar algo como
    una matriz de gran tamaño al interior de un ciclo reducido. También es
    soportada la asignación por referencia, usando la sintaxis
    <computeroutput>$var = &amp;$otra_var;</computeroutput>.  'Asignación
    por referencia' quiere decir que ambas variables terminan apuntando a
    los mismos datos y que nada es realmente copiado. Para aprender más
    sobre las referencias, por favor refiérase a <link
    linkend="language.references">las Referencias explicadas</link>. A
    partir de PHP 5 los objetos son asignados por referencia a menos que
    explícitamente se diga lo contrario con la nueva palabra clave <link
    linkend="language.oop5.cloning">clone</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Operadores Bit a Bit</title>
   <simpara>
    Los operadores bit a bit le permiten activar o desactivar bits
    individuales de un entero.
   </simpara>
   <table>
    <title>Operadores Bit a Bit</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
        <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>Y</entry>
       <entry>Los bits que están activos tanto en  <varname>$a</varname> como en  <varname>$b</varname> son
       activados.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>O</entry>
       <entry>Los bits que están activos ya sea en <varname>$a</varname> o en <varname>$b</varname> son
       activados.</entry>
      </row>
      <row>
      <entry><userinput>$a ^ $b</userinput></entry>
       <entry>O exclusivo (Xor)</entry>
       <entry>
        Los bits que estén activos en <varname>$a</varname> o <varname>$b</varname>, pero no en ambos, son
        activados.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>No</entry>
       <entry>
        Los bits que estén activos en <varname>$a</varname> son desactivados, y
        vice-versa.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Desplazamiento a izquierda</entry>
       <entry>
        Desplaza los bits de <varname>$a</varname>, <varname>$a</varname> pasos a la izquierda (cada paso
        quiere decir "multiplicar por dos")
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Desplazamiento a derecha</entry>
       <entry>
        Desplaza los bits de <varname>$a</varname>,  <varname>$b</varname> pasos a la derecha (cada paso
        quiere decir "dividir por dos")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Bit shifting in PHP is arithmetic.
    Bits shifted off either end are discarded.
    Left shifts have zeros shifted in on the right while the sign
    bit is shifted out on the left, meaning the sign of an operand
    is not preserved.
    Right shifts have copies of the sign bit shifted in on the left,
    meaning the sign of an operand is preserved.
   </para>
   <para>
    Use parentheses to ensure the desired
    <link linkend="language.operators.precedence">precedence</link>.
    For example, <literal>$a &amp; $b == true</literal> evaluates
    the equivalency then the bitwise and; while
    <literal>($a &amp; $b) == true</literal> evaluates the bitwise and
    then the equivalency.
   </para>
   <para>
    Be aware of data type conversions. If both the left-hand and
    right-hand parameters are strings, the bitwise operator will
    operate on the characters' ASCII values.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
PHP's error_reporting ini setting uses bitwise values,
providing a real-world demonstration of turning
bits off. To show all errors, except for notices,
the php.ini file instructions say to use:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
This works by starting with E_ALL:
<computeroutput>00000000000000000111011111111111</computeroutput>
Then taking the value of E_NOTICE...
<computeroutput>00000000000000000000000000001000</computeroutput>
... and inverting it via <literal>~</literal>:
<computeroutput>11111111111111111111111111110111</computeroutput>
Finally, it uses AND (&amp;) to find the bits turned
on in both values:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Another way to accomplish that is using XOR (<literal>^</literal>)
to find bits that are on in only one value or the other:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting can also be used to demonstrate turning bits on.
The way to show just errors and recoverable errors is:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
This process combines E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
and
<computeroutput>00000000000000000001000000000000</computeroutput>
using the OR (<literal>|</literal>) operator
to get the bits turned on in either value:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Bitwise AND, OR and XOR operations on integers</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ignore the top section,
 * it is just formatting to make output clearer.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
EOH;


/*
 * Here are the examples.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Bitwise XOR operations on strings</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Outputs '5'

echo "12" ^ "9"; // Outputs the Backspace character (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Outputs the ascii values #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Outputs 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Outputs 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Bit shifting on integers</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Here are the examples.
 */

echo "\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond 0');


echo "\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond -1');


echo "\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'sign bits get shifted out');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side');


echo "\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side, including sign bit');


/*
 * Ignore this bottom section,
 * it is just formatting to make output clearer.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Expression: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimal:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binary:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTE: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 1073741824 = 4 << 28
 Decimal:
  val=4
  res=1073741824
 Binary:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Expression: -2147483648 = 4 << 29
 Decimal:
  val=4
  res=-2147483648
 Binary:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 30
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -2147483648 = -4 << 29
 Decimal:
  val=-4
  res=-2147483648
 Binary:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Expression: 0 = -4 << 30
 Decimal:
  val=-4
  res=0
 Binary:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 4611686018427387904 = 4 << 60
 Decimal:
  val=4
  res=4611686018427387904
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Expression: -9223372036854775808 = 4 << 61
 Decimal:
  val=4
  res=-9223372036854775808
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 62
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -9223372036854775808 = -4 << 61
 Decimal:
  val=-4
  res=-9223372036854775808
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Expression: 0 = -4 << 62
 Decimal:
  val=-4
  res=0
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     No realice desplazamientos a derecha para más de 32 bits en sistemas de
     32 bits. No realice desplazamientos a izquierda en caso de que resulte
     en un número de más de 32 bits.
    </para>
   </warning>
   <para>
    See also
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
   </para>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Operadores de Comparación</title>
   <simpara>
    Los operadores de comparación, como su nombre indica, le permiten
    comparar dos valores. Puede que también se encuentre interesado en
    consultar las <link linkend="types.comparisons">tablas de comparación de
    tipos</link>, ya que éstas muestran ejemplos de varios tipos de
    comparaciones relacionadas con tipos.
   </simpara>
   <table>
    <title>Operadores de Comparación</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Igual</entry>
       <entry>&true; si <varname>$a</varname> es igual a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Idéntico</entry>
       <entry>
        &true; si <varname>$a</varname> es igual a <varname>$b</varname>, y son del mismo tipo. (A partir de PHP
        4)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diferente</entry>
       <entry>&true; si <varname>$a</varname> no es igual a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diferente</entry>
       <entry>&true; si <varname>$a</varname> no es igual a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>No idénticos</entry>
       <entry>
        &true; si <varname>$a</varname> no es igual a <varname>$b</varname>, o si no son del mismo
        tipo. (A partir de PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Menor que</entry>
       <entry>&true; si <varname>$a</varname> es escrictamente menor que <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Mayor que</entry>
       <entry>&true; si <varname>$a</varname> es estrictamente mayor que <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Menor o igual que</entry>
       <entry>&true; si <varname>$a</varname> es menor o igual que <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Mayor o igual que</entry>
       <entry>&true; si <varname>$a</varname> es mayor o igual que <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Si se compara un número con una cadena o la comparación implica cadenas
    numéricas, entonces cada cadeba es
    <link linkend="language.types.string.conversion">convertida a número</link>
    y la conversión se realiza numéricamente. Estas reglas también se aplican
    a la sentencia <link linkend="control-structures.switch">switch</link>. El
    tipo de conversión no tiene lugar cuando la comparación es === o !=== ya
    que se trata de comparar el tipo así como el valor.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // nunca se ejecuta ya que "a" ya ha coincidido con 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Para varios tipos, la comparación se realiza de acuerdo con la siguient
    tabla (en orden).
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Comparaci&oacute;n con Varios Tipos</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Tipo del Operando 1</entry>
       <entry>Tipo del Operando 2</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> o <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>Convertir &null; a "", comparación numérica o de
       léxico</entry>
      </row>
      <row>
       <entry><type>bool</type> o <type>null</type></entry>
       <entry>cualquiera</entry>
       <entry>Convertir a <type>bool</type>, &false; &lt;
       &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>
        Las clases internas pueden definir su propia comparación, clases
        diferentes son incomparables, la misma clase - comparan propiedades
        en la misma forma que las matrices (PHP 4), PHP 5 tiene su propia
        <link linkend="language.oop5.object-comparison">explicación</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> o <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> o <type>number</type></entry>
       <entry>Traducir las cadenas y recursos a números, matemática
       usual</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>
        Una matriz con menos elementos es menor, si una clave del operando 1
        no se encuentra en el operando 2 entonces las matrices son
        incomparables, de otra forma - comparar valor por valor (vea el
        siguiente ejemplo)
       </entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>cualquiera</entry>
       <entry><type>array</type> es siempre mayor</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>cualquiera</entry>
       <entry><type>object</type> es siempre mayor</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>Transcripción de la comparación de matrices
     estándar</title>
     <programlisting role="php">
<![CDATA[
<?php
// Las matrices son comparadas de esta forma con los operadores de comparación estándar
function comparacion_matrices_estandar($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $clave => $val) {
        if (!array_key_exists($clave, $op2)) {
            return null; // incomparable
        } elseif ($val < $op2[$clave]) {
            return -1;
        } elseif ($val > $op2[$clave]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Vea también <function>strcasecmp</function>,
    <function>strcmp</function>, <link linkend="language.operators.array">Operadores de matriz</link>, y la
    sección del manual sobre <link linkend="language.types">Tipos</link>.
   </para>

   <warning>
    <title>Comparación de números con coma flotante</title>

    <para>
     Debido a la forma en que los <type>float</type>s son representados internamente, no se
     debería comprobar la igualdad de dos <type>float</type>s.
    </para>

    <para>
     Ver la documentación de <type>float</type>  para más información.
    </para>
   </warning>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Operador Ternario</title>
    <para>
     Otro operador condicional es el operador "?:" (o ternario).
     <example>
      <title>Asignación de un valor predeterminado</title>
      <programlisting role="php">
<![CDATA[
<?php
// Ejemplo de uso de: el Operador Ternario
$accion = (empty($_POST['accion'])) ? 'predeterminada' : $_POST['accion'];

// La línea anterior es idéntica a esta sentencia if/else
if (empty($_POST['accion'])) {
    $accion = 'predeterminada';
} else {
    $accion = $_POST['accion'];
}

?>
]]>
      </programlisting>
     </example>
     La expresión <literal>(expr1) ? (expr2) : (expr3)</literal> evalúa a
     <replaceable>expr2</replaceable> si <replaceable>expr1</replaceable>
     evalúa a &true;, y <replaceable>expr3</replaceable> si
     <replaceable>expr1</replaceable> evalúa a &false;.
    </para>
    <para>
     Desde PHP 5.3, es posible dejar en blanco la parte media del operador
     ternario. La expresión <literal>expr1 ?: expr3</literal> devuelve
     <replaceable>expr1</replaceable> si <replaceable>expr1</replaceable>
     evalúa a &true;, y <replaceable>expr3</replaceable> de lo contrario.
    </para>
    <note>
     <simpara>
      Por favor note que el operador ternario es una sentencia, y que no
      evalúa a una variable, sino al resultado de una sentencia. Es
      importante saber esto si se desea devolver una variable por
      referencia. La sentencia <literal>return $var == 42 ? $a :
      $b;</literal> en una función con retorno-por-referencia no funcionará
      por lo que se ha mencionado y una advertencia es generada en versiones
      posteriores de PHP.
     </simpara>
    </note>
    <note>
     <para>
      Es recomendable que evite "apilar" las expresiones ternarias. El
      comportamiente de PHP cuando se usa más de un operador ternario al
      interior de una sentencia no es obvio:
      <example>
       <title>Comportamiento Ternario No-Obvio</title>
       <programlisting role="php">
<![CDATA[
<?php
// a primera vista, lo siguiente parece imprimir 'true'
echo (true?'true':false?'t':'f');

// sin embargo, la salida real de la línea anterior es 't'
// esto se debe a que las expresiones ternarias son evaluadas de izquierda a
// derecha

// la siguiente es una versión más obvia del código presentado anteriormente
echo ((true ? 'true' : false) ? 't' : 'f');

// aquí puede ver que la primera expresión es evaluada como 'true', la cual
// en su lugar evalúa a (bool)true, devolviendo por lo tanto la rama de
// verdad de la segunda expresión ternaria.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Operadores de Control de Errores</title>
   <simpara>
    PHP ofrece soporte para un operador de control de errores: el signo de
    arroba (@). Cuando es colocado al comienzo de una expresión en PHP,
    cualquier mensaje de error que pudiera generarse a causa de esa
    expresión será ignorado.
   </simpara>
   <simpara>
    Si la característica <link
    linkend="ini.track-errors"><option>track_errors</option></link> está
    habilitada, cualquier mensaje de error generado por la expresión será
    almacenado en la variable <varname>$php_errormsg</varname>.  La variable
    será sobrescrita en cada instancia de error, así que realice sus
    chequeos de forma temprana si quiere usarla.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Error intencional de archivo */
$mi_archivo = @file ('archivo_que_no_existe') or
    die ("La apertura de archivo ha fallado: el error fue '$php_errormsg'");

// esto funciona con cualquier expresión, no solo con funciones:
$valor = @$cache[$llave];
// no producirá una anotación si el índice $llave no existe.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     El operador @ trabaja sólo sobre <link
     linkend="language.expressions">expresiones</link>. Una simple regla de
     oro es: si usted puede tomar el valor de algo, entonces puede usar el
     operador @ sobre ese algo. Por ejemplo, puede usarlo al inicio de
     variables, llamadas a funciones y sencencias
     <function>include</function>, constantes, y así sucesivamente. No puede
     usarlo sobre definiciones de función o clase, ni sobre estructuras
     condicionales como <literal>if</literal> y <literal>foreach</literal>,
     y así sucesivamente.
    </simpara>
   </note>
   <simpara>
    Vea también <function>error_reporting</function> y la sección del manual
    sobre <link linkend="ref.errorfunc">funciones de Gestión de Errores y
    Registros</link>.
   </simpara>
   <warning>
    <para>
     En la actualidad, el operador de prefijo "@" para control de errores
     deshabilitará incluso el reporte de errores en casos de fallos críticos
     que terminarán la ejecución del script. Entre otras cosas, esto quiere
     decir que si usa "@" para eliminar los errores de una cierta función, y
     ésta no se encuentra disponible o ha sido escrita de forma incorrecta,
     el script se detendrá en ese punto sin dar indicación alguna del
     motivo.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operadores de ejecución</title>
   <para>
    PHP soporta un operador de ejecución: las comillas invertidas (``).
    ¡Note que no se trata de comillas sencillas! PHP intentará ejecutar el
    contenido entre las comillas como si se tratara de un comando del
    intérprete de comandos; su salida será devuelta (es decir, no será
    simplemente volcada como salida; puede ser asignada a una variable). El
    uso del operador de comillas invertidas es idéntico al de
    <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$salida = `ls -al`;
echo "<pre>$salida</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     El operador de comillas invertidas es deshabilitado cuando se encuentra
     activo &safemode; o cuando se deshabilita
     <function>shell_exec</function>.
    </para>
   </note>
   <para>
    Vea también la sección del manual sobre <link
    linkend="ref.exec">funciones de Ejecución de Programas</link>,
    <function>popen</function> <function>proc_open</function>, y <link
    linkend="features.commandline">Uso de PHP desde la línea de
    comandos</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Operadores de Incremento/Decremento</title>
   <para>
    PHP ofrece soporte de operadores de pre- y post-incremento y decremento,
    estilo-C.
   </para>
   <note>
    <simpara>
     Los operadores de incremento/decremento no afectan a los valores
     booleanos. Decrementar valores &null; tampoco tiene efecto, aunque
     incrementarlos resulta en <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Operadores de Incremento/decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Efecto</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-incremento</entry>
       <entry>Incrementa <varname>$a</varname> en uno, y luego devuelve <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-incremento</entry>
       <entry>Devuelve <varname>$a</varname>, y luego incrementa <varname>$a</varname> en uno.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decremento</entry>
       <entry>Decrementa <varname>$a</varname> en uno, luego devuelve <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decremento</entry>
       <entry>Devuelve <varname>$a</varname>, luego decrementa <varname>$a</varname> en uno.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Aquí hay un script sencillo de ejemplo:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincremento</h3>";
$a = 5;
echo "Debe ser 5: " . $a++ . "<br />\n";
echo "Debe ser 6: " . $a . "<br />\n";

echo "<h3>Preincremento</h3>";
$a = 5;
echo "Debe ser 6: " . ++$a . "<br />\n";
echo "Debe ser 6: " . $a . "<br />\n";

echo "<h3>Postdecremento</h3>";
$a = 5;
echo "Debe ser 5: " . $a-- . "<br />\n";
echo "Debe ser 4: " . $a . "<br />\n";

echo "<h3>Predecremento</h3>";
$a = 5;
echo "Debe ser 4: " . --$a . "<br />\n";
echo "Debe ser 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP sigue la convención de Perl cuando trabaja con operaciones
    aritméticas sobre variables de caracter, y no la convención de C. Por
    ejemplo, en Perl 'Z'+1 se convierte en 'AA', mientras que en C 'Z'+1 se
    convierte en '[' ( ord('Z') == 90, ord('[') == 91). Note que las
    variables de caracter pueden ser incrementadas pero no decrementadas, y
    aun así solo son soportados los caracteres ASCII planos (a-z y A-Z).
    <example>
     <title>Operaciones Aritméticas sobre Variables de Caracter</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
    <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    Incrementar o decrementar valores booleanos no tiene efecto.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Operadores de Lógica</title>

   <table>
    <title>Operadores de Lógica</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>Y</entry>
       <entry>&true; si tanto <varname>$a</varname> como <varname>$b</varname> son &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>O</entry>
       <entry>&true; si cualquiera de <varname>$a</varname> o <varname>$b</varname> es &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>O exclusivo (Xor)</entry>
       <entry>&true; si <varname>$a</varname> o <varname>$b</varname> es &true;, pero no ambos.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>No</entry>
       <entry>&true; si <varname>$a</varname> no es &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>Y</entry>
       <entry>&true; si tanto <varname>$a</varname> como <varname>$b</varname> son &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>O</entry>
       <entry>&true; si cualquiera de <varname>$a</varname> o <varname>$b</varname> es &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    La razón para tener las dos variaciones diferentes de los operadores
    "and" y "or" es que ellos operan con precedencias diferentes. (Vea <link
    linkend="language.operators.precedence">Precedencia de
    Operadores</link>.)
   </simpara>
   <example>
    <title>Ilustración de los operadores lógicos</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() nunca será llamada ya que esos operadores trabajan en modo corto-circuito

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" tiene una precedencia mayor que "or"

// El resultado de la expresión (false || true) es asignado a $e
// Actua como: ($e = (false || true))
$e = false || true;

// La constante false es asignada a $f y luego true es ignorado
// Actua como: (($e = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" tiene una precedencia mayor que "and"

// El resultado de la expresión (true && false) es asignado a $g
// Actua como: ($g = (true && false))
$g = true && false;

// La constante true es asiganda a $h y luego false es ignorado
// Actua como: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Operadores de Cadena</title>
   <simpara>
    Existen dos operadores para datos tipo <type>string</type>. El primero
    es el operador de concatenación ('.'), el cual devuelve el resultado de
    concatenar sus argumentas a lado derecho e izquierdo. El segundo es el
    operador de asignación sobre concatenación ('.='), el cual adiciona el
    argumento del lado derecho al argumento en el lado izquierdo. Por favor
    consulte <link linkend="language.operators.assignment">Operadores de
    Asignación</link> para más información.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "¡Hola ";
$b = $a . "Mundo!"; // ahora $b contiene "¡Hola Mundo!"

$a = "¡Hola ";
$a .= "Mundo!";     // ahora $a contiene "¡Hola Mundo!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Vea también las secciones del manual sobre <link
    linkend="language.types.string">el tipo String</link> y las <link
    linkend="ref.strings">funciones de strings</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Operadores de Matrices</title>
   <table>
    <title>Operadores de Matrices</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Ejemplo</entry>
       <entry>Nombre</entry>
       <entry>Resultado</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Unión</entry>
       <entry>Unión de <varname>$a</varname> y <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Igualdad</entry>
       <entry>&true; si <varname>$a</varname> y <varname>$b</varname> tienen las mismas parejas
       llave/valor.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identidad</entry>
       <entry>&true; si <varname>$a</varname> y <varname>$b</varname> tienen las mismas parejas llave/valor
       en el mismo orden y de los mismos tipos.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>No-igualdad</entry>
       <entry>&true; si <varname>$a</varname> no es igual a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>No-igualdad</entry>
       <entry>&true; si <varname>$a</varname> no es igual a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>No-identidad</entry>
       <entry>&true; si <varname>$a</varname> no es idéntico a <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    El operador <literal>+</literal> adiciona elementos de las claves
    restantes de la matriz del lado derecho a aquella al lado izquierdo, al
    mismo tiempo que cualquier llave duplicada NO es sobrescrita.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "manzana", "b" => "banano");
$b = array("a" => "pera", "b" => "fresa", "c" => "cereza");

$c = $a + $b; // Unión de $a y $b
echo "Unión de \$a y \$b: \n";
var_dump($c);

$c = $b + $a; // Unión de $b y $a
echo "Unión de \$b y \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    Cuando sea ejecutado, este script producirá la siguiente salida:
    <screen role="php">
<![CDATA[
Unión de $a y $b:
array(3) {
  ["a"]=>
  string(7) "manzana"
  ["b"]=>
  string(6) "banano"
  ["c"]=>
  string(6) "cereza"
}
Unión de $b y $a:
array(3) {
  ["a"]=>
  string(4) "pera"
  ["b"]=>
  string(5) "fresa"
  ["c"]=>
  string(6) "cereza"
}
]]>
    </screen>
   </para>
   <para>
    Los elementos de las matrices son considerados equivalentes en la
    comparación si éstos tienen la misma clave y valor.
   </para>
   <para>
    <example>
     <title>Comparación de matrices</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("manzana", "banano");
$b = array(1 => "banano", "0" => "manzana");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vea también las secciones del manual sobre <link
    linkend="language.types.array">el tipo Array</link> y <link
    linkend="ref.array">funciones de Matrices</link>.
   </para>
  </sect1>
  <sect1 xml:id="language.operators.type">
   <title>Operadores de Tipo</title>
   <para>
    <literal>instanceof</literal> es usado para determinar si una variable
    PHP es una instancia de objeto de cierta <link
    linkend="language.oop5.basic.class">clase</link>:
    <example>
     <title>Uso de instanceof con clases</title>
     <programlisting role="php">
<![CDATA[
<?php
class MiClase
{
}

class NoMiClase
{
}
$a = new MiClase;

var_dump($a instanceof MiClase);
var_dump($a instanceof NoMiClase);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> puede ser usado también para determinar si
    una variable es una instancia de objeto de una clase que hereda de una
    clase padre:
    <example>
     <title>Uso de instanceof con clases heredadas</title>
     <programlisting role="php">
<![CDATA[
<?php
class ClasePadre
{
}

class MiClase extends ClasePadre
{
}

$a = new MiClase;

var_dump($a instanceof MiClase);
var_dump($a instanceof ClasePadre);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Para chequear si un objeto <emphasis>no</emphasis> es una instancia de
    una clase, el <link linkend="language.operators.logical">operador lógico
    <literal>not</literal></link> puede ser usado.
    <example>
     <title>Uso de instanceof para chequear si un objeto
     <emphasis>no</emphasis> es instancia de una clase</title>
     <programlisting role="php">
<![CDATA[
<?php
class MiClase
{
}

$a = new MiClase;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Por último, <literal>instanceof</literal> puede ser usado también para
    determinar si una variable es una instancia de objeto de una clase que
    implementa una <link linkend="language.oop5.interfaces">interfaz</link>:
    <example>
     <title>Uso de instanceof para una clase</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MiInterfaz
{
}

class MiClase implements MiInterfaz
{
}

$a = new MiClase;

var_dump($a instanceof MiClase);
var_dump($a instanceof MiInterfaz);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Aunque <literal>instanceof</literal> es usado por lo general con un
    nombre de clase literal, también puede usarse con otro objeto o una
    variable tipo cadena:
    <example>
     <title>Uso de instanceof con otras variables</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MiInterfaz
{
}

class MiClase implements MiInterfaz
{
}

$a = new MiClase;
$b = new MiClase;
$c = 'MiClase';
$d = 'NoMiClase';

var_dump($a instanceof $b); // $b es un objeto de la clase MiClase
var_dump($a instanceof $c); // $c es una cadena 'MiClase'
var_dump($a instanceof $d); // $d es una cadena 'NoMiClase'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Hay algunas trampas comunes de las que hay que tener cuidado. En
    versiones anteriores a PHP 5.1.0,
    <literal>instanceof</literal> llamaría <link
    linkend="language.oop5.autoload">__autoload()</link> si el nombre de
    clase no existía. Adicionalmente, si la clase no estaba cargada,
    ocurriría un error fatal. Esto puede ser evitado usando una
    <literal>referencia dinámica de clase</literal>, o una variable tipo
    cadena que contenga el nombre de clase:
    <example>
     <title>Evitar búsquedas de nombres de clase y errores fatales con
     instanceof en PHP 5.0</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NoMiClase';
var_dump($a instanceof $d); // no acurre un error fatal aquí
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    El operador <literal>instanceof</literal> fue introducido en PHP 5.
    Anteriormente <function>is_a</function> era usado, pero desde entonces
    <function>is_a</function> ha sido marcada como función obsoleta,
    prefiriéndose el uso de <literal>instanceof</literal>. Note que a partir
    de PHP 5.3.0, <function>is_a</function> ya no es considerada una función
    obsoleta.
   </simpara>
   <para>
    Vea también <function>get_class</function> e <function>is_a</function>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

