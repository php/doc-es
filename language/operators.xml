  <chapter id="language.operators">
   <title>Operadores</title>
   <simpara>
   </simpara>

   <sect1 id="language.operators.arithmetic">
    <title>Operadores Aritméticos</title>
    <simpara>
     ¿Recuerdas la aritmética básica del colegio? Pues estos operadores
     funcionan exactamente igual.
    </simpara>

    <table>
     <title>Operadores Aritméticos</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>ejemplo</entry>
        <entry>nombre</entry>
        <entry>resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a + $b</entry>
        <entry>Adición</entry>
        <entry>Suma de $a y $b.</entry>
       </row>
       <row>
        <entry>$a - $b</entry>
        <entry>Substracción</entry>
        <entry>Diferencia entre $a y $b.</entry>
       </row>
       <row>
        <entry>$a * $b</entry>
        <entry>Multiplicación</entry>
        <entry>Producto de $a and $b.</entry>
       </row>
       <row>
        <entry>$a / $b</entry>
        <entry>División</entry>
        <entry>Cociente de $a entre $b.</entry>
       </row>
       <row>
        <entry>$a % $b</entry>
        <entry>Módulo</entry>
        <entry>Resto de $a dividido entre $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!-- Esto parece no ajustarse a la realidad. La división siempre devuelve un valor en punto flotante.
    <simpara>
     El operador de división ("/") devuelve un entero (el resultado de la
     división entera) si los dos operandos son enteros (o cadenas que se 
     han convertido a enteros). Si alguno de los operandos es un valor
     en punto flotante, se realiza la división en punto flotante.
    </simpara>
--></sect1>

   <sect1 id="language.operators.assignment">
    <title>Operadores de Asignación</title>
    <simpara>
     El operador básico de asignación es "=". A primera vista podrías 
     pensar que es el operador de comparación "igual que". Pero no. Realmente
     significa que el operando de la izquierda toma el valor de la expresión a la derecha,
     (esto es, "toma el valor de").
    </simpara>
    <para>
     El valor de una expresión de asignación es el propio valor asignado.
     Esto es, el valor de "$a = 3" es 3. Esto permite hacer cosas curiosas como
     <informalexample><programlisting>
$a = ($b = 4) + 5; // ahora $a es igual a 9, y $b vale 4.
</programlisting></informalexample>
    </para>
    <para>
     Además del operador básico de asignación, existen los "operadores combinados"
     para todas las operaciones aritméticas y de cadenas que sean binarias. Este
     operador combinado te permite, de una sola vez, usar una variable 
     en una expresión y luego establecer el valor de esa variable al 
     resultado de la expresión. Por ejemplo: <informalexample><programlisting>
$a = 3;
$a += 5; // establece $a a 8, como si hubiésemos escrito: $a = $a + 5;
$b = "Hola ";
$b .= "Ahí!"; // establece $b a "Hola Ahí!", igual que si hiciésemos $b = $b . "Ahí!";
</programlisting></informalexample>
    </para>

   <para>
        Fíjate en que la asignación realiza una nueva copia de la variable original
        (asignación por valor), por lo que cambios a la variable original no afectan a la copia.
        Esto puede tener interés si necesitas copiar algo como un array con muchos elementos
        dentro de un bucle que se repita muchas veces (cada vez se realizará una nueva copia del array). 
        PHP4 soporta asignación por referencia, usando 
        la sintaxis <computeroutput>$var = &amp;$othervar;</computeroutput>,
        pero esto no es posible en PHP3. 'Asignación por referencia' 
        quiere decir que ambas variables acabarán apuntando al mismo dato y 
        que nada es realmente copiado.
   </para>

  </sect1>

   <sect1 id="language.operators.bitwise">
    <title>Operadores Bit a bit</title>
    <simpara>
     Los operadores bit a bit te permiten activar o desactivar bits 
     individuales de un entero.
    </simpara>

    <table>
     <title>Operadores Bit a bit</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>ejemplo</entry>
        <entry>nombre</entry>
        <entry>resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a & $b</entry>
        <entry>Y</entry>
        <entry>Se activan los bits que están activos tanto en $a como $b.</entry>
       </row>
       <row>
        <entry>$a | $b</entry>
        <entry>O</entry>
        <entry>Se activan los bits que están activos en $a o que lo están en $b.</entry>
       </row>
       <row>
        <entry>$a ^ $b</entry>
        <entry>Xor ("o exclusiva")</entry>
        <entry>Se activan los bits que están activos en $a o en $b pero no en ambos a la vez.</entry>
       </row>
       <row>
        <entry>~ $a</entry>
        <entry>No</entry>
        <entry>Se activan los bits que no están activos en $a.</entry>
       </row>
       <row>
        <entry>$a &lt;&lt; $b</entry>
        <entry>Desplazamiento a la izquierda</entry>
        <entry>Desplaza los bits de $a, $b posiciones hacia la izquierda (por aritmética binaria, cada posición
          desplazada equivale a multiplicar por dos el valor de $a)</entry>
       </row>
       <row>
        <entry>$a &gt;&gt; $b</entry>
        <entry>Desplazamiento a la derecha</entry>
        <entry>Desplaza los bits de $a, $b posiciones hacia la derecha (por aritmética binaria, cada posición
          desplazada equivale a dividir entre dos el valor de $a)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>



   <sect1 id="language.operators.comparison">
    <title>Operadores de Comparación</title>
    <simpara>
     Los operadores de comparación, como su nombre indica, permiten comparar dos valores.
    </simpara>

    <table>
     <title>Operadores de Comparación</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>ejemplo</entry>
        <entry>nombre</entry>
        <entry>resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a == $b</entry>
        <entry>Igualdad</entry>
        <entry>Cierto si $a es igual a $b.</entry>
       </row>
       <row>
        <entry>$a === $b</entry>
        <entry>Identidad</entry>
        <entry>Cierto si $a es igual a $b y si son del mismo tipo (sólo PHP4)</entry>
       </row>
       <row>
        <entry>$a != $b</entry>
        <entry>Desigualdad</entry>
        <entry>Cierto si $a no es igual a $b.</entry>
       </row>
       <row>
        <entry>$a &lt; $b</entry>
        <entry>Menor que</entry>
        <entry>Cierto si $a es estrictamente menor que $b.</entry>
       </row>
       <row>
        <entry>$a &gt; $b</entry>
        <entry>Mayor que</entry>
        <entry>Cierto si $a es estrictamente mayor que $b.</entry>
       </row>
       <row>
        <entry>$a &lt;= $b</entry>
        <entry>Menor o igual que</entry>
        <entry>Cierto si $a es menor o igual que $b.</entry>
       </row>
       <row>
        <entry>$a &gt;= $b</entry>
        <entry>Mayor o igual que</entry>
        <entry>Cierto si $a es mayor o igual que $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
     Otro operador condicional es el operador "?:" (o ternario),
     que funciona como en C y otros muchos lenguajes.
	
	<informalexample>
	 <programlisting>
(expr1) ? (expr2) : (expr3);
	 </programlisting>
	</informalexample> 

	La expresión toma el valor <replaceable>expr2</replaceable> si
	<replaceable>expr1</replaceable> se evalúa a cierto, y
	<replaceable>expr3</replaceable> si
	<replaceable>expr1</replaceable> se evalúa a falso.
   </para>
  </sect1>


  <sect1 id="language.operators.execution">
   <title>Operador de ejecución</title>
   
   <para>
	PHP soporta un operador de ejecución: el apóstrofe invertido (``). ¡Fíjate
        que no son apostrofes normales! 
        PHP intentará ejecutar la instrucción contenida dentro de los apóstrofes
        invertidos como si fuera un comando del shell; y su salida devuelta como
        el valor de esta expresión (i.e., no tiene por qué ser simplemente volcada
        como salida; puede asignarse a una variable).

	<informalexample>
	 <programlisting role="php">
$output = `ls -al`;
echo "&lt;pre&gt;$output&lt;/pre&gt;";
	 </programlisting>
	</informalexample>

   </para>

   <para>
	Ver también <function>system</function>,
	<function>passthru</function>, <function>exec</function>,
	<function>popen</function>, y
	<function>escapeshellcmd</function>.
   </para>

  </sect1>

  
  <sect1 id="language.operators.increment">
   <title>Operadores de Incremento/decremento</title>

   <para>
        PHP soporta los operadores de predecremento y post incremento
        al estilo de C.
   </para>

    <table>
     <title>Operadores de Incremento/decremento</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>ejemplo</entry>
        <entry>nombre</entry>
        <entry>efecto</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>++$a</entry>
        <entry>Preincremento</entry>
        <entry>Incrementa $a en uno y después devuelve $a.</entry>
       </row>
       <row>
        <entry>$a++</entry>
        <entry>Postincremento</entry>
        <entry>Devuelve $a y después incrementa $a en uno.</entry>
       </row>
       <row>
        <entry>--$a</entry>
        <entry>Predecremento</entry>
        <entry>Decrementa $a en uno y después devuelve $a.</entry>
       </row>
       <row>
        <entry>$a--</entry>
        <entry>Postdecremento</entry>
        <entry>Devuelve $a y después decrementa $a en uno.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
	He aquí un listado de ejemplo:
	<informalexample>
	 <programlisting>
&lt;?php
echo "&lt;h3&gt;Postincremento&lt;/h3&gt;";
$a = 5;
echo "Debería ser 5: " . $a++ . "&lt;br&gt;\n";
echo "Debería ser 6: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Preincremento&lt;/h3&gt;";
$a = 5;
echo "Debería ser 6: " . ++$a . "&lt;br&gt;\n";
echo "Debería ser 6: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Postdecremento&lt;/h3&gt;";
$a = 5;
echo "Debería ser 5: " . $a-- . "&lt;br&gt;\n";
echo "Debería ser 4: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Predecremento&lt;/h3&gt;";
$a = 5;
echo "Debería ser 4: " . --$a . "&lt;br&gt;\n";
echo "Debería ser 4: " . $a . "&lt;br&gt;\n";
?&gt;	  
	 </programlisting>
	</informalexample>
   </para>

  </sect1>


  <sect1 id="language.operators.logical">
    <title>Operadores Lógicos</title>

    <table>
     <title>Operadores Lógicos</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>ejemplo</entry>
        <entry>nombre</entry>
        <entry>resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a and $b</entry>
        <entry>Y</entry>
        <entry>Cierto si tanto $a como $b son ciertos.</entry>
       </row>
       <row>
        <entry>$a or $b</entry>
        <entry>O</entry>
        <entry>Cierto si $a o $b son ciertos.</entry>
       </row>
       <row>
        <entry>$a xor $b</entry>
        <entry>O exclusiva</entry>
        <entry>Cierto si $a es cierto o $b es cierto, pero no ambos a la vez.</entry>
       </row>
       <row>
        <entry>! $a</entry>
        <entry>Negación</entry>
        <entry>Cierto si $a no es cierto.</entry>
       </row>
       <row>
        <entry>$a &amp;&amp; $b</entry>
        <entry>Y</entry>
        <entry>Cierto si tanto $a como $b son ciertos.</entry>
       </row>
       <row>
        <entry>$a || $b</entry>
        <entry>O</entry>
        <entry>Cierto si $a o $b son ciertos.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <simpara>
        La razón de las dos variaciones de "y" y "o" es que operan con
        distinta precedencia (ver <link linkend="language.operators.precedence">Precedencia
	de Operadores</link>.)
   </simpara>
  </sect1>

   <sect1 id="language.operators.precedence">
    <title>Precedencia de Operadores</title>
    <para>
     La precedencia de operadores especifica cómo se agrupan las expresiones.
     Por ejemplo, en la expresión
     <literal>1 + 5 * 3</literal>, la respuesta es 16 y no 18 porque el
     operador de multiplicación ("*") tiene una mayor precedencia 
     que el de adición ("+").</para>
    <para>
     La siguiente tabla lista la precedencia de operadores, indicándose
     primero los de menor precedencia.

    <table>
     <title>Precedencia de Operadores</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Asociatividad</entry>
        <entry>Operadores</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>izquierda</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>= += -= *= /= .= %= &= |= ^= ~= &lt;&lt;= &gt;&gt;=</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>no asociativo</entry>
        <entry>== != ===</entry>
       </row>
       <row>
        <entry>no asociativo</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>izquierda</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>derecha</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>no asociativo</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table></para></sect1>

  <sect1 id="language.operators.string">
   <title>Operadores de Cadenas</title>
   <simpara>
        Hay dos operadores de cadenas. El primero es el operador de 
        concatenación ('.'), que devuelve el resultado de concatenar sus
        operandos izquierdo y derecho. El segundo es el operador de concatenación
        y asignación ('.='). Consulta <link
	linkend="language.operators.assignment">Operadores de 
	Asignación</link> para más información.
   </simpara>
   <para>
	<informalexample>
	 <programlisting>
$a = "Hola ";
$b = $a . "Mundo!"; // ahora $b contiene "Hola Mundo!"

$a = "Hola ";
$a .= "Mundo!"; // ahora $a contiene "Hola Mundo!"
     </programlisting>
	</informalexample>
   </para>
  </sect1>


  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
