<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.14 $ -->
<!-- EN-Revision: 1.81 Maintainer: rafael Status: ready -->

  <chapter id="control-structures">
 <title>Estructuras de Control</title>
 
 <simpara>
  Todo script PHP se compone de una serie de sentencias. Una sentencia
  puede ser una asignaci&oacute;n, una llamada a funci&oacute;n, un
  bucle, una sentencia condicional e incluso una sentencia que no haga
  nada (una sentencia vac&iacute;a). Las sentencias normalmente acaban
  con punto y coma. Adem&aacute;s, las sentencias se pueden agrupar en
  grupos de sentencias encapsulando un grupo de sentencias con
  llaves. Un grupo de sentencias es tambi&eacute;n una sentencia. En
  este cap&iacute;tulo se describen los diferentes tipos de
  sentencias.
 </simpara>
 
 <sect1 id="control-structures.if">
  <title><literal>if</literal></title>
  <para>
   La construcci&oacute;n <literal>if</literal> es una de las
   m&aacute;s importantes caracter&iacute;sticas de muchos lenguajes,
   incluido PHP. Permite la ejecuci&oacute;n condicional de fragmentos
   de c&oacute;digo. PHP caracteriza una estructura
   <literal>if</literal> que es similar a la de C:
   <informalexample>
    <programlisting>
<![CDATA[
<?php
if (expr)
    sentencia
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   Como se describe en la <link
   linkend="language.expressions">secci&oacute;n sobre
   expresiones</link>, <replaceable>expr</replaceable> se
   eval&uacute;a a su valor condicional (boolean). Si
   <replaceable>expr</replaceable> se eval&uacute;a como &true;, PHP
   ejecutar&aacute; la <replaceable>sentencia</replaceable>, y si se
   eval&uacute;a como &false; - la ignorar&aacute;. Se puede encontrar
   m&aacute;s informaci&oacute;n sobre los valores evaluados como
   &false; en la secci&oacute;n <link
   linkend="language.types.boolean.casting">Convirtiendo a un valor
    condicional (boolean)'</link>.
  </simpara>
  <para>
   El siguiente ejemplo mostrar&iacute;a <computeroutput>a es mayor
    que b</computeroutput> si <replaceable>$a</replaceable> fuera mayor
   que <replaceable>$b</replaceable>:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) 
   print "a es mayor que b";
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
     A menudo, se desea tener m&aacute;s de una sentencia ejecutada de
     forma condicional. Por supuesto, no hay necesidad de encerrar
     cada sentencia con una cl&aacute;usula <literal>if</literal>. En
     vez de eso, se pueden agrupar varias sentencias en un grupo de
     sentencias.  Por ejemplo, este c&oacute;digo mostrar&iacute;a
     <computeroutput>a es mayor que b</computeroutput> si
     <replaceable>$a</replaceable> fuera mayor que
     <replaceable>$b</replaceable>, y entonces asignar&iacute;a el
     valor de <replaceable>$a</replaceable> a
     <replaceable>$b</replaceable>:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
 if ($a > $b) {
     print "a es mayor que b";
     $b = $a;
 }
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   Las sentencias <literal>if</literal> se pueden anidar
   indefinidamente dentro de otras sentencias <literal>if</literal>,
   lo cual proporciona una flexibilidad completa para ejecuciones
   condicionales en las diferentes partes de tu programa.
  </simpara>
 </sect1>
 
 <sect1 id="control-structures.else">
  <title><literal>else</literal></title>
  <para>
   A menudo queremos ejecutar una sentencia si se cumple una cierta
   condicion, y una sentencia distinta si la condici&oacute;n no se
   cumple.  Esto es para lo que sirve <literal>else</literal>.
   <literal>else</literal> extiende una sentencia
   <literal>if</literal> para ejecutar una sentencia en caso de que la
   expresi&oacute;n en la sentencia <literal>if</literal> se
   eval&uacute;e como &false;.  Por ejemplo, el siguiente
   c&oacute;digo mostrar&iacute;a <computeroutput>a es mayor que
    b</computeroutput> si <replaceable>$a</replaceable> fuera mayor que
   <replaceable>$b</replaceable>, y <computeroutput>a NO es mayor que
    b </computeroutput> en cualquier otro caso:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
 if ($a > $b) {
     print "a es mayor que b";
 } else {
     print "a NO es mayor que b";
 }
?>
]]>
    </programlisting>
   </informalexample>
   
   La sentencia <literal>else</literal> se ejecuta solamente si la
   expresi&oacute;n <literal>if</literal> se eval&uacute;a como
   &false;, y si hubiera alguna expresi&oacute;n
   <literal>elseif</literal> - s&oacute;lo si se evaluaron
   tambi&eacute;n a &false; (Ver <link
    linkend="control-structures.elseif">elseif</link>).
  </para>
 </sect1>
 
 <sect1 id="control-structures.elseif">
  <title><literal>elseif</literal></title>
  
  <para>
   <literal>elseif</literal>, como su nombre sugiere, es una
   combinaci&oacute;n de <literal>if</literal> y
   <literal>else</literal>.  Como <literal>else</literal>, extiende
   una sentencia <literal>if</literal> para ejecutar una sentencia
   diferente en caso de que la expresi&oacute;n <literal>if</literal>
   original se eval&uacute;a como &false;.  No obstante, a diferencia
   de <literal>else</literal>, ejecutar&aacute; esa expresi&oacute;n
   alternativa solamente si la expresi&oacute;n condicional
   <literal>elseif</literal> se eval&uacute;a como &true;.  Por
   ejemplo, el siguiente c&oacute;digo mostrar&iacute;a
   <computeroutput>a es mayor que b</computeroutput>,
   <computeroutput>a es igual a b </computeroutput> o
   <computeroutput>a es menor que b</computeroutput>:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
 if ($a > $b) {
     print "a es mayor que b";
 } elseif ($a == $b) {
     print "a es igual que b";
 } else {
     print "a es mayor que b";
 }
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   Puede haber varios <literal>elseif</literal>s dentro de la misma
   sentencia <literal>if</literal>.  La primera expresi&oacute;n
   <literal>elseif</literal> (si hay alguna) que se eval&uacute;e como
   &true; se ejecutar&iacute;a.  En PHP, tambi&eacute;n se puede
   escribir 'else if' (con dos palabras) y el comportamiento
   ser&iacute;a id&eacute;ntico al de un 'elseif' (una sola
   palabra). El significado sint&aacute;ctico es ligeramente distinto
   (si estas familiarizado con C, es el mismo comportamiento) pero la
   l&iacute;nea b&aacute;sica es que ambos resultar&iacute;an tener
   exactamente el mismo comportamiento.  
  </simpara>
  <simpara>
   La sentencia <literal>elseif</literal> se ejecuta s&oacute;lo si la
   expresi&oacute;n <literal>if</literal> precedente y cualquier
   expresi&oacute;n <literal>elseif</literal> precedente se
   eval&uacute;an como &false;, y la expresi&oacute;n
   <literal>elseif</literal> actual se eval&uacute;a como &true;.
  </simpara>
 </sect1>
 
 <sect1 id="control-structures.alternative-syntax">
  <title>Sintaxis Alternativa de Estructuras de Control</title>
  <para>
   PHP ofrece una sintaxis altenativa para alguna de sus estructuras
   de control; a saber, <literal>if</literal>,
   <literal>while</literal>, <literal>for</literal>, y
   <literal>switch</literal>.  En cada caso, la forma b&aacute;sica de
   la sintaxis alternativa es cambiar abrir-llave por dos puntos (:) y
   cerrar-llave por <literal>endif;</literal>,
   <literal>endwhile;</literal>, <literal>endfor;</literal>, or
   <literal>endswitch;</literal>, respectivamente.
   <informalexample>
    <programlisting role="php">
<![CDATA[
 <?php if ($a==5): ?>
 A es igual a 5
 <?php endif; ?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   En el ejemplo de arriba, el bloque HTML "A es igual 5" se anida
   dentro de una sentencia <literal>if</literal> escrita en la
   sintaxis alternativa.  El bloque HTML se mostrar&iacute;a solamente
   si $a fuera igual a 5.
  </simpara>
  <para>
   La sintaxis alternativa se aplica a <literal>else</literal> y
   tambi&eacute;n a <literal>elseif</literal>.  La siguiente es una
   estructura <literal>if</literal> con <literal>elseif</literal> y
   <literal>else</literal> en el formato alternativo:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
 if ($a == 5):
     print "a es igual a 5";
     print "...";
 elseif ($a == 6):
     print "a es igual a 6";
     print "!!!";
 else:
     print "a no es ni 5 ni 6";
 endif;
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Mirar tambi&eacute;n <link
    linkend="control-structures.while">while</link>, <link
    linkend="control-structures.for">for</link>, e <link
    linkend="control-structures.if">if</link> para m&aacute;s ejemplos.
  </para>
 </sect1>
 
 <sect1 id="control-structures.while">
  <title><literal>while</literal></title>
  <para>
   Los bucles <literal>while</literal> son los tipos de bucle
   m&aacute;s simples en PHP. Se comportan como su contrapartida en C.
   La forma b&aacute;sica de una sentencia <literal>while</literal>
   es:
   <informalexample>
    <programlisting>
<![CDATA[
while (expr) sentencia
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   El significado de una sentencia <literal>while</literal> es simple.
   Le dice a PHP que ejecute la(s) sentencia(s) anidada(s)
   repetidamente, mientras la expresi&oacute;n
   <literal>while</literal> se eval&uacute;e como &true;.  El valor de
   la expresi&oacute;n es comprobado cada vez al principio del bucle,
   as&iacute; que incluso si este valor cambia durante la
   ejecuci&oacute;n de la(s) sentencia(s) anidada(s), la
   ejecuci&oacute;n no parar&aacute; hasta el fin de la
   iteraci&oacute;n (cada vez que PHP ejecuta las sentencias en el
   bucle es una iteraci&oacute;n).  A veces, si la expresi&oacute;n
   <literal>while</literal> se eval&uacute;a como &false; desde el
   principio de todo, la(s) sentencia(s) anidada(s) no se
   ejecutar&aacute;n ni siquiera una vez.
  </simpara>
  <para>
   Como con la sentencia <literal>if</literal>, se pueden agrupar
   multiples sentencias dentro del mismo bucle
   <literal>while</literal> encerrando un grupo de sentencias con
   llaves, o usando la sintaxis alternativa:
   <informalexample>
    <programlisting>
<![CDATA[
 while (expr): sentencia ... endwhile;
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Los siguientes ejemplos son id&eacute;nticos, y ambos imprimen n&uacute;meros del
   1 al 10:
   <informalexample>
    <programlisting>
 <![CDATA[
<?php
/* ejemplo 1 */
 
 $i = 1;
 while ($i <= 10) {
     print $i++;  /* el valor impreso ser&iacute;a
                     $i antes del incremento
                     (post-incremento) */
 }
 
 /* ejemplo 2 */
 
 $i = 1;
 while ($i <= 10):
     print $i;
     $i++;
 endwhile;
?>
]]>
    </programlisting>
   </informalexample>
  </para>
 </sect1>
 
 
 <sect1 id="control-structures.do.while">
  <title><literal>do..while</literal></title>
  
  <simpara>
   Los bucles <literal>do..while</literal> son muy similares a los
   bucles <literal>while</literal>, excepto que las condiciones se
   comprueban al final de cada iteraci&oacute;n en vez de al
   principio.  La principal diferencia frente a los bucles regulares
   <literal>while</literal> es que se garantiza la ejecuci&oacute;n de
   la primera iteraci&oacute;n de un bucle
   <literal>do..while</literal> (la condici&oacute;n se comprueba
   s&oacute;lo al final de la iteraci&oacute;n), mientras que puede no
   ser necesariamente ejecutada con un bucle <literal>while</literal>
   regular (la condici&oacute;n se comprueba al principio de cada
   iteraci&oacute;n, si esta se eval&uacute;a como &false; desde el
   principio la ejecuci&oacute;n del bucle finalizar&aacute;
   inmediatamente).
  </simpara>
  <para>
   Hay una sola sintaxis para los bucles <literal>do..while</literal>:
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
 $i = 0;
 do {
     print $i;
 } while ($i>0);
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   El bucle de arriba se ejecutar&iacute;a exactamente una sola vez,
   despu&eacute;s de la primera iteraci&oacute;n, cuando la
   condici&oacute;n se comprueba, se eval&uacute;a como &false; ($i no
   es m&aacute;s grande que 0) y la ejecuci&oacute;n del bucle
   finaliza.
  </simpara>
  <para>
   Los usuarios avanzados de C pueden estar familiarizados con un uso
   distinto del bucle <literal>do..while</literal>, para permitir
   parar la ejecuci&oacute;n en medio de los bloques de c&oacute;digo,
   encapsulandolos con <literal>do..while</literal>(0), y usando la
   sentencia <link
    linkend="control-structures.break"><literal>break</literal></link>.
   El siguiente fragmento de c&oacute;digo demuestra esto:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
do {
     if ($i < 5) {
         print "i no es lo suficientemente grande";
         break;
     }
     $i *= $factor;
     if ($i < $minimum_limit) {
         break;
     }
     print "i es correcto";
     /* procesa i */
 } while(0);
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   No se preocupes si no entiende esto completamente o en absoluto.
   Se pueden codificar archivos de comandos e incluso archivos de
   comandos potentes sin usar esta 'propiedad'.
  </simpara>
 </sect1>
 
 <sect1 id="control-structures.for">
  <title><literal>for</literal></title>
  <para>
   Los bucles <literal>for</literal> son los bucles m&aacute;s
   complejos en PHP.  Se comportan como su contrapartida en C.  La
   sintaxis de un bucle <literal>for</literal> es:
   <informalexample>
    <programlisting>
<![CDATA[
for (expr1; expr2; expr3) sentencia
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   La primera expresi&oacute;n (<replaceable>expr1</replaceable>) se
   eval&uacute;a (ejecuta) incondicionalmente una vez al principio del
   bucle.
  </simpara>
  <simpara>
   Al comienzo de cada iteraci&oacute;n, se eval&uacute;a
   <replaceable>expr2 </replaceable>.  Si se eval&uacute;a como
   &true;, el bucle contin&uacute;a y las sentencias anidadas se
   ejecutan. Si se eval&uacute;a como &false;, la ejecuci&oacute;n del
   bucle finaliza.
  </simpara>
  <simpara>
   Al final de cada iteraci&oacute;n, se eval&uacute;a (ejecuta)
   <replaceable>expr3</replaceable>.
   </simpara>
  <simpara>
   Cada una de las expresiones puede estar vac&iacute;a.  Que
   <replaceable>expr2</replaceable> est&eacute; vac&iacute;a significa
   que el bucle deber&iacute;a correr indefinidamente (PHP
   implicitamente lo considera como &true;, al igual que C).  Esto
   puede que no sea tan in&uacute;til como se podr&iacute;a pensar,
   puesto que a menudo se quiere salir de un bucle usando una
   sentencia <link
    linkend="control-structures.break"><literal>break</literal></link>
   condicional en vez de usar la condici&oacute;n de
   <literal>for</literal>.
  </simpara>
  <para>
   Considera los siguientes ejemplos.  Todos ellos muestran n&uacute;meros del
   1 al 10:
  
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
 /* ejemplo 1 */
 
 for ($i = 1; $i <= 10; $i++) {
     print $i;
 }
 
 /* ejemplo 2 */
 
 for ($i = 1; ;$i++) {
     if ($i > 10) {
         break;
     }
     print $i;
 }
 
 /* ejemplo 3 */
 
 $i = 1;
 for (;;) {
     if ($i > 10) {
         break;
     }
     print $i;
     $i++;
 }
 
 /* ejemplo 4 */
 
 for ($i = 1; $i <= 10; print $i, $i++) ;
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   Por supuesto, el primer ejemplo parece ser el mas elegante (o
   quiz&aacute;s el cuarto), pero uno puede descubrir que ser capaz de
   usar expresiones vac&iacute;as en bucles <literal>for</literal>
   resulta &uacute;til en muchas ocasiones.
  </simpara>
  <para>
   PHP tambi&eacute;n soporta la "sintaxis de dos puntos" alternativa
   para bucles <literal>for</literal>.
   <informalexample>
    <programlisting>
<![CDATA[
for (expr1; expr2; expr3): sentencia; ...; endfor;
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Otros lenguajes poseen una sentencia <literal>foreach</literal>
   para traducir un array o una tabla hash. PHP3 no posee tal
   construcci&oacute;n; PHP4 s&iacute; (ver <link
    linkend="control-structures.foreach">foreach</link>).  En PHP3, se
   puede combinar <link
    linkend="control-structures.while">while</link> con las funciones
   <function>list</function> y <function>each</function> para
   conseguir el mismo efecto. Mirar la documentaci&oacute;n de estas
   funciones para ver un ejemplo.
  </para>
 </sect1>
 
 <sect1 id="control-structures.foreach">
  <title><literal>foreach</literal></title>
  <para>
   PHP 4 (PHP3 no) incluye una construcci&oacute;n
   <literal>foreach</literal>, tal como perl y algunos otros
   lenguajes. Esto simplemente da un modo f&aacute;cil de iterar sobre
   matrices. <literal>foreach</literal> funciona solamente con
   matrices y devolver&aacute; un error si se intenta utilizar con
   otro tipo de datos &oacute; variables no inicializadas. Hay dos
   sintaxis; la segunda es una extensi&oacute;n menor, pero
   &uacute;til de la primera:
   <informalexample>
     <programlisting>
<![CDATA[
foreach(expresion_array as $value) sentencia
foreach(expresion_array as $key => $value) sentencia
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   La primera forma recorre el array dado por
   <literal>expresion_array</literal>. En cada iteraci&oacute;n, el
   valor del elemento actual se asigna a <literal>$value</literal> y
   el puntero interno del array se avanza en una unidad (as&iacute; en
   el siguiente paso, se estar&aacute; mirando el elemento siguiente).
  </simpara>
  <simpara>
   La segunda manera hace lo mismo, salvo que la clave del elemento
   actual ser&aacute; asignada a la variable <literal>$key</literal>
   en cada iteraci&oacute;n.
  </simpara>
  <para>
   <note>
    <para>
     Cuando <literal>foreach</literal> comienza su primera
     ejecuci&oacute;n, el puntero interno a la matriz se reinicia
     autom&aacute;ticamente al primer elemento de la matriz. Esto
     significa que no se necesita llamar a <function>reset</function>
     antes de un bucle <literal>foreach</literal>.
    </para>
   </note>
  </para>
  <para>
   <note>
    <para>
     Hay que tener en cuenta que<literal>foreach</literal> trabaja con
     una copia de la matriz especificada y no la lista en si, por ello
     el puntero de la lista no es modificado como en la funci&oacute;n
     <function>each</function>, y los cambios en el elemento de la
     matriz retornado no afectan a la matriz original. De todas
     maneras el puntero interno a la matriz original
     <emphasis>avanza</emphasis> al procesar la matriz. suponiendo que
     bucle foreach se ejecuta hasta el final, el puntero interno a la
     matriz estar/aacute; al final de la matriz.
    </para>
   </note>
  </para>
  <para>
   <note>
    <para>
     <literal>foreach</literal> no soporta la caracteristica de
     suprimir mensajes de error con '@'.
    </para>
   </note>
  </para>
  <para>
   Puede haber observado que las siguientes son funcionalidades id&eacute;nticas:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$arr = array("one", "two", "three");
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Value: $value<br>\n";
}

foreach ($arr as $value) {
    echo "Value: $value<br>\n";
}
?>
]]>
    </programlisting>
   </informalexample>
   Las siguientes tambi&eacute;n son funcionalidades id&eacute;nticas:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
reset( $arr );
while( list( $key, $value ) = each( $arr ) ) {
   echo "Key: $key; Valor: $value&lt;br&gt;\n";
}

foreach( $arr as $key => $value ) {
   echo "Key: $key; Valor: $value&lt;br&gt;\n";
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Algunos ejemplos m&aacute;s para demostrar su uso:
    <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
/* foreach ejemplo 1: s&oacute;lo valor*/
$a = array(1, 2, 3, 17);

foreach($a as $v) {
   print "Valor actual de \$a: $v.\n";
}

/* foreach ejemplo 2: valor (con clave impresa para ilustrar) */
$a = array(1, 2, 3, 17);

$i = 0; /* s&oacute;lo para prop&oacute;sitos demostrativos */

foreach($a as $v) {
   print "\$a[$i] => $v.\n";
   $i++;
}

/* foreach ejemplo 3: clave y valor */
$a = array(
   "uno" => 1,
   "dos" => 2,
   "tres" => 3,
   "diecisiete" => 17
);

foreach($a as $k => $v) {
   print "\$a[$k] => $v.\n";
}

/* foreach ejemplo 4: matriz multi-dimensional */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* foreach ejemplo 5: matriz din&aacute;mica */
     
foreach(array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
 </sect1>
 
  <sect1 id="control-structures.break">
  <title><literal>break</literal></title> 
  <simpara>
   <literal>break</literal> escapa de la estructuras de control
   iterante (bucle) actuales <literal>for</literal>,
   <literal>while</literal>, o <literal>switch</literal>.
  </simpara>
  <simpara>
   <literal>break</literal> accepta un par&aacute;metro opcional, el cual determina 
   cuantas estructuras de control hay que escapar.
  </simpara>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$arr = array ('one', 'two', 'three', 'four', 'stop', 'five');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* You could also write 'break 1;' here. */
    }
    echo "$val<br>\n";
}

/* Using the optional argument. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5<br>\n";
        break 1;  /* Exit only the switch. */
    case 10:
        echo "Al 10; saliendo<br>\n";
        break 2;  /* Exit the switch and the while. */
    default:
        break;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
 </sect1>
 
 <sect1 id="control-structures.continue">
  <title><literal>continue</literal></title>
  
  <simpara>
   <literal>continue</literal> se usa dentro de la estructura del
   bucle para saltar el resto de la iteraci&oacute;n actual del bucle
   y continuar la ejecuci&oacute;n al comienzo de la siguiente
   iteraci&oacute;n.
  </simpara>
  
  <note>
   <simpara>
    Tener en cuenta que en PHP la declaraci&oacute;n <link
    linkend="control-structures.switch">switch</link> es considerada
    una estructura de bucle por <literal>continue</literal>.
   </simpara>
  </note>
  
  <simpara>
   <literal>continue</literal> accepta un par&aacute;metro opcional,
   el cual determina cuantos niveles (bluces) hay que saltar antes de
   continuar con la ejecuci&oacute;n.
  </simpara>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
while (list ($key, $value) = each ($arr)) {
    if (!($key % 2)) { // skip odd members
        continue;
    }
    do_something_odd ($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Outer<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;Middle<br>\n";
        while (1) {
            echo "&nbsp;&nbsp;Inner<br>\n";
            continue 3;
        }
        echo "Esto nunca se imprime.<br>\n";
    }
    echo "Y esto tampoco.<br>\n";
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
 </sect1>
 
 <sect1 id="control-structures.switch">
  <title><literal>switch</literal></title>
  
  <simpara>
   La sentencia <literal>switch</literal> es similar a una serie de
   sentencias IF en la misma expresi&oacute;n.  En muchas ocasiones,
   se quiere comparar la misma variable (o expresi&oacute;n) con
   nuchos valores diferentes, y ejecutar una parte de c&oacute;digo
   distinta dependiendo de a qu&eacute; valor es igual.  Para ello
   sirve la sentencia <literal>switch</literal>.
  </simpara>
  
   <note>
   <simpara>
    Tener en cuenta que al contrario que otros lenguajes de
    programaci&oacute;n, <link
    linkend="control-structures.continue">continue</link> se aplica a
    switch y funciona de manera similar a <literal>break</literal>. Si
    teneis un switch dentro de un bucle y deseais continuar con el
    paso siguiente en el bucle externo, usar <literal>continue
    2</literal>.
   </simpara>
  </note>
  
  <para>
   Los siguientes dos ejemplos son dos modos distintos de escribir la
   misma cosa, uno usa una serie de sentencias <literal>if</literal>,
   y el otro usa la sentencia <literal>switch</literal>:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    print "i equals 0";
} elseif ($i == 1) {
    print "i equals 1";
} elseif ($i == 2) {
    print "i equals 2";
}

switch ($i) {
    case 0:
        print "i equals 0";
        break;
    case 1:
        print "i equals 1";
        break;
    case 2:
        print "i equals 2";
        break;
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Es importante entender c&oacute;mo se ejecuta la sentencia
   <literal>switch</literal> para evitar errores. La sentencia
   <literal>switch</literal> ejecuta l&iacute;nea por l&iacute;nea
   (realmente, sentencia a sentencia).  Al comienzo, no se ejecuta
   c&oacute;digo.  S&oacute;lo cuando se encuentra una sentencia
   <literal>case</literal> con un valor que coincide con el valor de
   la expresi&oacute;n <literal>switch</literal> PHP comienza a
   ejecutar las sentencias.  PHP contin&uacute;a ejecutando las
   sentencias hasta el final del bloque <literal>switch</literal>, o
   la primera vez que vea una sentencia <literal>break</literal>.  Si
   no se escribe una sentencia <literal>break</literal> al final de
   una lista de sentencias case, PHP seguir&aacute; ejecutando las
   sentencias del siguiente case.  Por ejemplo:
     <informalexample>
      <programlisting role="php">
<![CDATA[
 <?php
 switch ($i) {
     case 0:
         print "i es igual a 0";
     case 1:
         print "i es igual a 1";
     case 2:
         print "i es igual a 2";
 }
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   Aqu&iacute;, si $i es igual a 0, ¡PHP ejecutar&iacute;a todas las
   sentecias print!  Si $i es igual a 1, PHP ejecutar&iacute;a las
   &uacute;ltimas dos sentencias print y s&oacute;lo si $i es igual a
   2, se obtendr&iacute;a la conducta 'esperada' y solamente se
   mostrar&iacute;a 'i es igual a 2'.  As&iacute;, es importante no
   olvidar las sentencias <literal>break</literal> (incluso aunque
   pueda querer evitar escribirlas intencionadamente en ciertas
   circunstancias).
   </simpara>
   <simpara>
   En una sentencia <literal>switch</literal>, la condici&oacute;n se
   eval&uacute;a s&oacute;lo una vez y el resultado se compara a cada
   sentencia <literal>case</literal>.  En una sentencia
   <literal>elseif</literal>, la condici&oacute;n se eval&uacute;a
   otra vez.  Si tu condici&oacute;n es m&aacute;s complicada que una
   comparaci&oacute;n simple y/o est&aacute; en un bucle estrecho, un
   <literal>switch</literal> puede ser m&aacute;s r&aacute;pido.
  </simpara>
  <para>
   La lista de sentencias de un case puede tambi&eacute;n estar
   vac&iacute;a, lo cual simplemente pasa el control a la lista de
   sentencias del siguiente case.
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
     case 0:
     case 1:
     case 2:
         print "i es menor que 3, pero no negativo";
         break;
     case 3:
         print "i es 3";
 }
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Un caso especial es el <literal>default</literal> case".  Este
     "case" coincide con todo lo que no coincidan los otros case. Por
     ejemplo:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
 switch ($i) {
     case 0:
         print "i es igual a 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
     default:
         print "i no es igual a 0, 1 o 2";
 }
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   La expresi&oacute;n <literal>case</literal> puede ser cualquier
   expresi&oacute;n que se eval&uacute;e a un tipo simple, es decir,
   n&uacute;meros enteros o de punto flotante y cadenas de texto.  No
   se pueden usar aqu&iacute; ni arrays ni objetos a menos que se
   conviertan a un tipo simple.
  </para>
  <para>
   La sintaxis alternativa para las estructuras de control est&aacute;
   tambi&eacute;n soportada con switch. Para m&aacute;s
   informaci&oacute;n, ver <link
   linkend="control-structures.alternative-syntax">Sintaxis
   alternativa para estructuras de control</link>.
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
switch ($i):
     case 0:
         print "i es igual 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
     default:
         print "i no es igual a 0, 1 o 2";
 endswitch;
?>
]]>
    </programlisting>
   </informalexample>
  </para>
 </sect1>

<sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
   La construcci&oacute;n <literal>declare</literal> es usada para definir
   directivas de ejecuci&oacute;n para un bloque de c&oacute;digo. La sintaxis de
   <literal>declare</literal> es similar a la de las otras estructuras
   de control:
   <informalexample>
    <programlisting>
<![CDATA[
declare (directiva) sentencia
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   <literal>Directiva</literal> permite asignar el comportamiento del
   bloque <literal>declare</literal>. Actualmente una sola directiva
   es reconocida: la directiva <literal>ticks</literal> (Consultar m&aacute;s
   abajo la informaci&oacute;n sobre la directiva <link
    linkend="control-structures.declare.ticks">ticks</link>)
  </para>
  <para>
   La <literal>sentencia</literal> es lo que se ejecuta -- Como se
   ejecuta y que efectos secundarios tiene depende de la directiva
   definida en la <literal>directiva</literal>.
  </para>
   <para>
   El constructor <literal>declare</literal> se puede usar tambien
   globalmente, afectando a todo el c&oacute;digo que le sigue.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Estos son lo mismo:

// se puede usar este:
declare(ticks=1) {
    // script completo aqui
}

// o este:
declare(ticks=1);
// script completo aqui
?>
]]>
     </programlisting>
    </informalexample>
   </para>


  <sect2 id="control-structures.declare.ticks">
   <title>Ticks</title>
   <para>
    Un "tick" es un evento que ocurre por cada
    <replaceable>N</replaceable> sentencias de bajo nivel ejecutadas
    dentro del bloque <literal>declare</literal>. El valor de
    <replaceable>N</replaceable> es especificado por
    <literal>ticks=<replaceable>N</replaceable></literal> como
    <literal>directiva</literal> dentro de <literal>declare</literal>.
   </para>
   <para>
    El evento que ocurre en cada "tick" es especificado usando la
    funci&oacute;n <function>register_tick_function</function>. Ver el
    ejemplo m&aacute;s abajo para m&aacute;s detalles. Tener en cuenta que mas de un
    evento puede ocurrir por cada "tick"
   </para>
   <para>
    <example>
     <title>Perfilar una secci&oacute;n de c&oacute;digo PHP</title>
     <programlisting role="php">
<![CDATA[
<?php
// A function that records the time when it is called
function profile ($dump = FALSE)
{
    static $profile;

    // Return the times stored in profile, then erase it
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }

    $profile[] = microtime ();
}

// Set up a tick handler
register_tick_function("profile");

// Initialize the function before the declare block
profile ();

// Run a block of code, throw a tick every 2nd statement
declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text (md5($x), md5($x*$x)), "<br />;";
    }
}

// Display the data stored in the profiler
print_r (profile (TRUE));
?>
]]>
     </programlisting>
    </example>
    Este ejemplo perfila el c&oacute;digo PHP dentro del bloque 'declare',
    grabando la hora, una sentencia si y otra no, cuando fue
    ejecutada. Esta informaci&oacute;n puede ser usada para encontrar areas
    en donde el codigo es lento. Este proceso se puede implementar de
    diferentes maneras: usando "ticks" es m&aacute;s conveniente y facil de
    implementar.
   </para>
   <simpara>
    "Ticks" es una manera muy buena de eliminar errores, implementando
    simples trabajos en paralelo, I/O en modo desatendido y otras
    tareas.
   </simpara>
   <simpara>
    Ver tambi&eacute;n <function>register_tick_function</function> y
    <function>unregister_tick_function</function>.
   </simpara>
  </sect2>
 </sect1>
 
 <sect1 id="function.return">
  <title>return</title>
  <simpara>
   Si se llama desde una funci&oacute;n, <function>return</function> termina
   inmediatamente la ejecuci&oacute;n de la funci&oacute;n y retorna su argumento
   como valor de la funci&oacute;n. <function>return</function> tambien
   terminar&aacute; la ejecuci&oacute;n de una sentencia <function>eval</function>&oacute;
   un script PHP.
  </simpara>
  <simpara>
   Si el script actual ha sido incluido &oacute; requerido con
   <function>include</function> &oacute; <function>require</function>, el
   control es transferido al script que llamo al script
   incluido. Adem&aacute;s, si el script actual fue incluido, el valor dado a
   <function>return</function> ser&aacute; retornado como el valor de la
   llamada <function>include</function>. Si
   <function>return</function> es invocado desde el script principal,
   la ejecuci&oacute;n terminara inmediatamente. Si el script actual fue
   incluido con las opciones de configuraci&oacute;n <link
   linkend="ini.auto-prepend-file">auto_prepend_file</link> &oacute; <link
   linkend="ini.auto-append-file">auto_append_file</link>, la
   ejecuci&oacute;n terminara inmediatamente.
   </simpara>
   <simpara>Para m&aacute;s informaci&oacute;n, consultar <link
   linkend="functions.returning-values">Retornando valores</link>.
   </simpara>
  <para>
   <note>
    <simpara>
    Tener en cuenta que ya que <function>return</function> es un
    constructor del lenguaje y no una funci&oacute;n, los par&eacute;ntesis
    alrededor de sus argumentos, son <emphasis>solo</emphasis>
    necesarios si el argumento contiene una expresion, no se suelen
    utilizar tan a menudo, cuando retornan una variable.
    </simpara>
   </note>
  </para>
  </sect1>
 
 <sect1 id="function.require">
  <title><function>require</function></title>
  
  <simpara>La sentencia <function>require</function> incluye y evalua
   el archivo especificado.
  </simpara>
  <simpara>
   <function>require</function> incluye y evalua el archivo
   especificado. Informaci&oacute;n detallada de como esta inclusi&oacute;n funciona
   se puede encontrar en la documentaci&oacute;n de la funci&oacute;n
   <function>include</function>.
  </simpara>
  <simpara>
   <function>require</function> y <function>include</function> son
   id&eacute;nticas en todos los aspectos excepto en el modo de actuar ante
   un error. <function>include</function> produce un <link
   linkend="internal.e-warning">Warning</link> mientras que
   <function>require</function> produce un <link
   linkend="internal.e-error"> Error Fatal</link>. En otras palabras,
   no dude en utilizar <function>require</function> si quiere que un
   fichero no encontrado cuelgue el procesamiento de la
   p&aacute;gina. <function>include</function> no se comporta de esta manera,
   el script seguir&aacute; funcionando de todas maneras. Asegurarse que
   <link linkend="ini.include-path">include_path</link> este
   configurado bien.
  </simpara>
  <para>
   <example>
    <title>ejemplos b&aacute;sicos de <function>require</function></title>
    <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   consultar la documentaci&oacute;n de <function>include</function> para m&aacute;s
   ejemplos.
   </simpara>
  <para>
   <note>
    <simpara>
    Con anterioridad a PHP 4.0.2, se aplica lo siguiente:
    <function>require</function> siempre intentar&aacute; leer el fichero a
    incluir, incluso si la linea donde se encuentra
    <function>require</function> nunca es ejecutada. Sin embargo, si
    la linea donde se encuentra <function>require</function> no es
    ejecutada, tampoco lo har&aacute; el c&oacute;digo incluido.
   </simpara>
  </note>
  </para>

  &note.language-construct;

  &warn.no-win32-fopen-wrapper;

  <simpara>
   Ver tambi&eacute;n <function>include</function>,
    <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>,
    <function>file</function>, <function>readfile</function>,
    <function>virtual</function> y <link
    linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
   La sentencia <function>include</function> incluye y eval&uacute;a
   el archivo especificado.
   </simpara>
  <simpara>
   Esta documentaci&oacute;n tambi&eacute;n se aplica a la funci&oacute;n
   <function>require</function>. <function>require</function> y
   <function>include</function> son id&eacute;nticas en todos los aspectos
   excepto en el modo de actuar ante un
   error. <function>include</function> produce un <link
   linkend="internal.e-warning">Warning</link> mientras que
   <function>require</function> produce un <link
   linkend="internal.e-error"> Error Fatal</link>. En otras palabras,
   no dude en utilizar <function>require</function> si quiere que un
   fichero no encontrado cuelgue el procesamiento de la
   p&aacute;gina. <function>include</function> no se comporta de esta manera,
   el script seguir&aacute; funcionando de todas maneras. Asegurarse que
   <link linkend="ini.include-path">include_path</link> este
   configurado bien.
  </simpara>
  <simpara>
   Cuando un fichero es incluido, el c&oacute;digo que contiene hereda la
   <link linkend="language.variables.scope">variable scope</link> de
   la linea en donde el include ocurre. Cualquier variable disponible
   en esa linea en el fichero desde donde se hace la inclusi&oacute;n estar&aacute;
   disponible en el fichero incluido a partir de ese momento.
  </simpara>
  <para>
   <example>
    <title>Ejemplo b&aacute;sico de la funci&oacute;n<function>include</function></title>
    <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Si la inclusi&oacute;n ocurre dentro de una funci&oacute;n en el fichero donde se
   incluye, todo el c&oacute;digo contenido en el fichero incluido se
   comportar&aacute; como si hubiese sido definido dentro de esta funci&oacute;n.
  </simpara>
  <para>
   <example>
    <title>Incluyendo desde funciones</title>
    <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php is in the scope of foo() so     *
 * $fruit is NOT available outside of this  *
 * scope.  $color is because we declared it *
 * as global.                               */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Cuando un fichero es incluido, el int&eacute;rprete sale del modo
   PHP y entra en modo HTML al principio del archivo referenciado, y
   vuelve de nuevo al modo PHP al final. Por esta raz&oacute;n,
   cualquier c&oacute;digo dentro del archivo referenciado que debiera
   ser ejecutado como c&oacute;digo PHP debe ser encerrado dentro de
   <link linkend="language.basic-syntax.phpmode"> etiquetas
    v&aacute;lidas de comienzo y fin de PHP</link>.
  </simpara>
  <simpara>
   Si "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
    esta activada en PHP (como est&aacute; en la configuraci&oacute;n
    inicial), se puede especificar el fichero que se va a incluir
    usando una URL (via HTTP u otro mecanismo soportado, consultar
    <xref linkend="wrappers"/>) en vez de un fichero local. Si el
    servidor destino interpreta el fichero destino como c&oacute;digo PHP,
    variables pueden ser mandadas al fichero incluido usando una
    cadena URL de petici&oacute;n, tal como se hace con HTTP GET. Esto no es
    lo mismo que incluir un fichero y que este fichero herede las
    variables del fichero padre; el script es ejecutado en el servidor
    remoto y el resultado es incluido en en script local.
  </simpara>
  &warn.no-win32-fopen-wrapper;
  <para>
   <example>
    <title><function>include</function> a traves de HTTP</title>
    <programlisting role="php">
<![CDATA[
<?php

/* This example assumes that www.example.com is configured to parse .php 
 * files and not .txt files. Also, 'Works' here means that the variables 
 * $foo and $bar are available within the included file.*/

// Won't work; file.txt wasn't handled by www.example.com as PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Won't work; looks for a file named 'file.php?foo=1&bar=2' on the
// local filesystem.
include 'file.php?foo=1&bar=2';

// Works.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Works.
include 'file.php';  // Works.

?>
]]>
    </programlisting>
   </example>
     Ver tambi&eacute;n <link linkend="features.remote-files">Ficheros
     remotos</link>, <function>fopen</function> y
     <function>file</function> para obtener informaci&oacute;n adicional.
   </para>
   <para>
   Ya que <function>include</function> y <function>require</function>
   son contructores especiales del lenguaje, se deben de incluir
   dentro del bloque de una sentencia, si est&aacute;n dentro de un bloque
   condicional.
   </para>
   <para>
    <example>
    <title>include() y bloques condicionales</title>
    <programlisting role="php">
<![CDATA[
<?php

// This is WRONG and will not work as desired.
if ($condition)
    include $file;
else
    include $other;


// This is CORRECT.
if ($condition) {
    include $file;
} else {
    include $other;
}

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Es posible ejecutar una sentencia <literal>return</literal> dentro
   de un archivo incluido para terminar el procesado de ese archivo y
   volver al archivo de comandos que lo llam&oacute;. Tambien es
   posible retornar valores de ficheros incluidos. Se puede coger el
   valor de la llamada "include" como se har&iacute;a con una funci&oacute;n normal.
  </simpara>
  <para>
   <note>
    <simpara>
     En PHP3, <literal>return</literal> no puede aparecer dentro de un
     bloque a menos que sea un bloque de funci&oacute;n, en el cual
     <literal>return</literal> se aplica a esa funci&oacute;n y no al
     archivo completo.
    </simpara>
   </note>
  </para>
  <para>
   <example>
    <title><function>include</function> y <function>return</function></title>
    <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // prints 'PHP'

$bar = include 'noreturn.php';

echo $bar; // prints 1

?>
]]>
    </programlisting>
    </example>
  </para>
  <simpara>
   <literal>$bar</literal> es igual a <literal>1</literal> porque la
   inclusi&oacute;n salio bien. Notar la diferencia entre los dos ejemplos
   anteriores. el primero usa <function>return</function> dentro del
   fichero incluido y el segundo no. Otras maneras de incluir ficheros
   en variables es con <function>fopen</function>,
   <function>file</function> &oacute; usando <function>include</function>con
   <link linkend="ref.outcontrol">Funciones de control de
    salida</link>.
  </simpara>
  
  &note.language-construct;
  
  <simpara>
   Ver tambi&eacute;n <function>require</function>,
   <function>require_once</function>,
   <function>include_once</function>, <function>readfile</function>,
   <function>virtual</function>, y <link
    linkend="ini.include-path">include_path</link>.
  </simpara>
  
 </sect1>
 
 <sect1 id="function.require-once">
  <title><function>require_once</function></title>
  <para>
   La funci&oacute;n <function>require_once</function> incluye y evalua el
   fichero especificado durante la ejecuci&oacute;n del script. Se comporta
   de manera similar a <function>require</function>, con la &uacute;nica
   diferencia que si el c&oacute;digo ha sido ya incluido, no se volver&aacute; a
   incluir. Consultar la documentaci&oacute;n de la funci&oacute;n
   <function>require</function> para obtener m&aacute;s informaci&oacute;n.
  </para>
  <para>
   <function>require_once</function> deber&iacute;a de usarse en casos en los
   que un mismo fichero puede ser incluido y evaluado m&aacute;s de una vez
   durante la ejecuci&oacute;n de un script, y se quiere estar seguro que se
   incluye una sola vez para evitar problemas con redefiniciones de
   funciones, valores de funciones, etc.
   </para>
   <para>
   Para consultar ejemplos que usen <function>require_once</function>
   y <function>include_once</function>, ver el c&oacute;digo de <ulink
   url="&url.php.pear;">PEAR</ulink> incluido con las &uacute;ltimas
   versiones de PHP.
  </para>
  <para>
   <note>
    <para>
     <function>require_once</function> fue incorporado en PHP 4.0.1pl2
    </para>
   </note>
  </para>
  <para>
   <note>
    <para>
    El comportamiento de de <function>require_once</function>
     y <function>include_once</function> puede que no sea el esperado
     en sistemas operativos en los que may&uacute;sculas y min&uacute;sculas se
    traten igual (como en Windows) 
    <example>
     <title>Con <function>require_once</function> no importan las
     may&uacute;sculas y min&uacute;sculas en Windows</title>
     <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // this will include a.php
require_once("A.php"); // this will include a.php again on Windows!
?>
]]>
       </programlisting>
     </example>
    </para>
   </note>
   </para>
  
 &warn.no-win32-fopen-wrapper;
   <para>
   Ver tambi&eacute;n <function>require</function>,
   <function>include</function>, <function>include_once</function>,
   <function>get_required_files</function>,
   <function>get_included_files</function>,
   <function>readfile</function>, y <function>virtual</function>.
  </para>
 </sect1>
 
 <sect1 id="function.include-once">
  <title><function>include_once</function></title>
  <para>
    La funci&oacute;n <function>include_once</function> incluye y evalua el
   fichero especificado durante la ejecuci&oacute;n del script. Se comporta
   de manera similar a <function>include</function>, con la &uacute;nica
   diferencia que si el c&oacute;digo ha sido ya incluido, no se volver&aacute; a
   incluir.
   </para>
   <para>
   <function>include_once</function> deber&iacute;a de usarse en casos en los
   que, un mismo fichero puede ser incluido y evaluado m&aacute;s de una vez
   durante la ejecuci&oacute;n de un script, y se quiere estar seguro que se
   incluye una sola vez para evitar problemas con redefiniciones de
   funciones, valores de funciones, etc.
   </para>
   <para>
   Para consultar ejemplos que usen <function>include_once</function>
   e <function>require_once</function>, ver el c&oacute;digo de <ulink
   url="&url.php.pear;">PEAR</ulink> incluido con las &uacute;ltimas
   versiones de PHP.
  </para>
  <para>
   <note>
    <para>
     <function>include_once</function> fue incorporado en PHP 4.0.1pl2
    </para>
   </note>
   </para>
  <para>
   <note>
    <para>
     El comportamiento de de <function>include_once</function>
     y <function>require_once</function> puede que no sea el esperado
     en sistemas operativos en los que may&uacute;sculas y min&uacute;sculas se
    traten igual (como en Windows) 

     <example>
      <title>Con <function>include_once</function> no importan las
     may&uacute;sculas y min&uacute;sculas en Windows</title>
      <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // this will include a.php
include_once("A.php"); // this will include a.php again on Windows!
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
  </para>
  &warn.no-win32-fopen-wrapper;
  <para>
   Ver tambi&eacute;n <function>include</function>,
   <function>require</function>, <function>require_once</function>,
   <function>get_required_files</function>,
   <function>get_included_files</function>,
   <function>readfile</function>, y <function>virtual</function>.
  </para>
 </sect1>
  
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
