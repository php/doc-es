  <chapter id="control-structures">
   <title>Estructuras de Control</title>

   <simpara>
    Todo archivo de comandos PHP se compone de una serie de sentencias.
    Una sentencia puede ser una asignaci&oacute;n, una llamada a funci&oacute;n, un bucle,
    una sentencia condicional e incluso una sentencia que no haga nada 
    (una sentencia vac&iacute;a). Las sentencias normalmente acaban con punto y
    coma. Adem&aacute;s, las sentencias se pueden agrupar en grupos de sentencias
    encapsulando un grupo de sentencias con llaves. Un grupo de sentencias
    es tambi&eacute;n una sentencia. En este cap&iacute;tulo se describen los diferentes
    tipos de sentencias.</simpara>

   <sect1 id="control-structures.if">
    <title><literal>if</literal></title>
 
    <para>
     La construcci&oacute;n <literal>if</literal> es una de las m&aacute;s importantes
     caracter&iacute;sticas de muchos lenguajes, incluido PHP. Permite la ejecuci&oacute;n
     condicional de fragmentos de c&oacute;digo. PHP caracteriza una estructura 
     <literal>if</literal> que es similar a la de C:

     <informalexample><programlisting>
 if (expr)
     sentencia
 </programlisting></informalexample></para>
 
    <simpara>
     Como se describe en la secci&oacute;n sobre expresiones, expr se eval&uacute;a
     a su valor condicional. Si <replaceable>expr</replaceable>
     se eval&uacute;a como <literal>TRUE</literal>, PHP ejecutar&aacute; la sentencia,
     y si se eval&uacute;a como <literal>FALSE</literal> - la ignorar&aacute;.</simpara>
 
    <para>
     El siguiente ejemplo mostrar&iacute;a <computeroutput>a es mayor
     que b</computeroutput> si <replaceable>$a</replaceable> fuera mayor
     que <replaceable>$b</replaceable>:
 
     <informalexample><programlisting>
 if ($a > $b)
     print "a es mayor que b";
 </programlisting></informalexample></para>

    <para>
     A menudo, se desea tener m&aacute;s de una sentencia ejecutada de forma
     condicional. Por supuesto, no hay necesidad de encerrar cada sentencia
     con una cl&aacute;usula <literal>if</literal>. En vez de eso, se pueden agrupar
     varias sentencias en un grupo de sentencias.
     Por ejemplo, este c&oacute;digo mostrar&iacute;a <computeroutput>a es mayor que
     b</computeroutput> si <replaceable>$a</replaceable> fuera mayor que
     <replaceable>$b</replaceable>, y entonces asignar&iacute;a el valor de
     <replaceable>$a</replaceable> a <replaceable>$b</replaceable>:
 
     <informalexample><programlisting>
 if ($a > $b) {
     print "a es mayor que b";
     $b = $a;
 }
 </programlisting></informalexample></para>
 
    <simpara>
     Las sentencias if se pueden anidar indefinidamente dentro de otras
     sentencias <literal>if</literal>, lo cual proporciona una flexibilidad
     completa para ejecuciones condicionales en las diferentes partes de
     tu programa.</simpara></sect1>
 
  <sect1 id="control-structures.else">
    <title><literal>else</literal></title>

    <para>
     A menudo queremos ejecutar una sentencia si se cumple una cierta
     condicion, y una sentencia distinta si la condici&oacute;n no se cumple.
     Esto es para lo que sirve <literal>else</literal>.
     <literal>else</literal> extiende una sentencia <literal>if</literal>
     para ejecutar una sentencia en caso de que la expresi&oacute;n en la sentencia
     <literal>if</literal> se eval&uacute;e como <literal>FALSE</literal>.  Por
     ejemplo, el siguiente c&oacute;digo mostrar&iacute;a <computeroutput>a es mayor que
     b</computeroutput> si <replaceable>$a</replaceable> fuera mayor que
     <replaceable>$b</replaceable>, y <computeroutput>a NO es mayor que b
     </computeroutput> en cualquier otro caso:

     <informalexample>
      <programlisting>
 if ($a > $b) {
     print "a es mayor que b";
 } else {
     print "a NO es mayor que b";
 }
      </programlisting>
     </informalexample>
 
     La sentencia <literal>else</literal> se ejecuta solamente si la
     expresi&oacute;n <literal>if</literal> se eval&uacute;a como <literal>FALSE</literal>,
     y si hubiera alguna expresi&oacute;n <literal>elseif</literal> - s&oacute;lo si se
     evaluaron tambi&eacute;n a <literal>FALSE</literal> (ver m&aacute;s abajo).
     </para></sect1>
 
   <sect1 id="control-structures.elseif">
    <title><literal>elseif</literal></title>
 
    <para>
     <literal>elseif</literal>, como su nombre sugiere, es una combinaci&oacute;n
     de <literal>if</literal> y <literal>else</literal>.  Como
     <literal>else</literal>, extiende una sentencia <literal>if</literal>
     para ejecutar una sentencia diferente en caso de que la expresi&oacute;n
     <literal>if</literal> original se eval&uacute;a como <literal>FALSE</literal>.
     No obstante, a diferencia de <literal>else</literal>, ejecutar&aacute;
     esa expresi&oacute;n alternativa solamente si la expresi&oacute;n condicional
     <literal>elseif</literal> se eval&uacute;a como <literal>TRUE</literal>.
     Por ejemplo, el siguiente c&oacute;digo mostrar&iacute;a <computeroutput>a es
     mayor que b</computeroutput>, <computeroutput>a es igual a b
     </computeroutput> o <computeroutput>a es menor que b</computeroutput>:
 
     <informalexample>
      <programlisting>
 if ($a > $b) {
     print "a es mayor que b";
 } elseif ($a == $b) {
     print "a es igual que b";
 } else {
     print "a es mayor que b";
 }
      </programlisting>
     </informalexample></para>
 
    <simpara>
     Puede haber varios <literal>elseif</literal>s dentro de la misma
     sentencia <literal>if</literal>.  La primera expresi&oacute;n 
     <literal>elseif</literal> (si hay alguna) que se eval&uacute;e como
     <literal>true</literal> se ejecutar&iacute;a.  En PHP, tambi&eacute;n se puede
     escribir 'else if' (con dos palabras) y el comportamiento ser&iacute;a
     id&eacute;ntico al de un 'elseif' (una sola palabra). El significado
     sint&aacute;ctico es ligeramente distinto (si estas familiarizado con C,
     es el mismo comportamiento) pero la l&iacute;nea b&aacute;sica es que
     ambos resultar&iacute;an tener exactamente el mismo comportamiento.</simpara>
     
    <simpara>
     La sentencia <literal>elseif</literal> se ejecuta s&oacute;lo si la expresi&oacute;n
     <literal>if</literal> precedente y cualquier expresi&oacute;n
     <literal>elseif</literal> precedente se eval&uacute;an como
     <literal>FALSE</literal>, y la expresi&oacute;n
     <literal>elseif</literal> actual se eval&uacute;a como <literal>TRUE</literal>.
     </simpara></sect1>
 
    <sect1 id="control-structures.alternative-syntax">
     <title>Sintaxis Altenrativa de Estructuras de Control</title>
 
   <para>
	PHP ofrece una sintaxis altenativa para alguna de sus estructuras
        de control; a saber, <literal>if</literal>,
	<literal>while</literal>, <literal>for</literal>, y
	<literal>switch</literal>.  En cada caso, la forma b&aacute;sica de la
	sintaxis alternativa es cambiar abrir-llave por dos puntos (:) y
	cerrar-llave por <literal>endif;</literal>,
	<literal>endwhile;</literal>, <literal>endfor;</literal>, or
	<literal>endswitch;</literal>, respectivamente.
    
      <informalexample>
       <programlisting>
 &lt;?php if ($a==5): ?&gt;
 A es igual a 5
 &lt;?php endif; ?&gt;
       </programlisting>
      </informalexample>
     </para>
 
     <simpara>
      En el ejemplo de arriba, el bloque HTML "A = 5" se anida dentro de una
      sentencia <literal>if</literal> escrita en la sintaxis alternativa.
      El bloque HTML se mostrar&iacute;a solamente si $a fuera igual a 5.</simpara>
 
     <para>
      La sintaxis alternativa se aplica a <literal>else</literal>
      y tambi&eacute;n a <literal>elseif</literal>.  La siguiente es una
      estructura <literal>if</literal> con <literal>elseif</literal>
      y <literal>else</literal> en el formato alternativo:
      
      <informalexample>
       <programlisting>
 if ($a == 5):
     print "a es igual a 5";
     print "...";
 elseif ($a == 6):
     print "a es igual a 6";
     print "!!!";
 else:
     print "a no es ni 5 ni 6";
 endif;
       </programlisting>
      </informalexample>
   </para>

   <para>
	Mirar tambi&eacute;n <link linkend="control-structures.while">while</link>,
	<link linkend="control-structures.for">for</link>, e <link
	 linkend="control-structures.if">if</link> para m&aacute;s ejemplos.
   </para>

  </sect1>
 
   <sect1 id="control-structures.while">
    <title><literal>while</literal></title>
 
    <para>
     Los bucles <literal>while</literal> son los tipos de bucle m&aacute;s simples
     en PHP. Se comportan como su contrapartida en C.  La forma b&aacute;sica de
     una sentencia <literal>while</literal> es:
 
     <informalexample>
      <programlisting>
 while (expr) sentencia
      </programlisting>
     </informalexample></para>
 
    <simpara>
     El significado de una sentencia <literal>while</literal> es simple.
     Le dice a PHP que ejecute la(s) sentencia(s) anidada(s) repetidamente,
     mientras la expresi&oacute;n <literal>while</literal> se eval&uacute;e como
     <literal>TRUE</literal>.  El valor de la expresi&oacute;n es
     comprobado cada vez al principio del bucle, as&iacute; que incluso si este
     valor cambia durante la ejecuci&oacute;n de la(s) sentencia(s) anidada(s),
     la ejecuci&oacute;n no parar&aacute; hasta el fin de la iteraci&oacute;n (cada vez que
     PHP ejecuta las sentencias en el bucle es una iteraci&oacute;n).
     A veces, si la expresi&oacute;n <literal>while</literal> se eval&uacute;a como
     <literal>FALSE</literal> desde el principio de todo, la(s) sentencia(s)
     anidada(s) no se ejecutar&aacute;n ni siquiera una vez.</simpara>
 
    <para>
     Como con la sentencia <literal>if</literal>, se pueden agrupar
     multiples sentencias dentro del mismo bucle <literal>while</literal>
     encerrando un grupo de sentencias con llaves, o usando la sintaxis
     alternativa:
 
     <informalexample>
      <programlisting>
     while (expr): sentencia ... endwhile;
 </programlisting></informalexample></para>
 
     <para>
      Los siguientes ejemplos son id&eacute;nticos, y ambos imprimen n&uacute;meros del
      1 al 10:
 
     <informalexample>
      <programlisting>
 /* ejemplo 1 */
 
 $i = 1;
 while ($i <= 10) {
     print $i++;  /* el valor impreso ser&iacute;a
                     $i antes del incremento
                     (post-incremento) */
 }
 
 /* ejemplo 2 */
 
 $i = 1;
 while ($i <= 10):
     print $i;
     $i++;
 endwhile;
      </programlisting>
     </informalexample></para></sect1>
 
 
   <sect1 id="control-structures.do.while">
    <title><literal>do..while</literal></title>
 
    <simpara>
     Los bucles <literal>do..while</literal> son muy similares a los
     bucles <literal>while</literal>, excepto que las condiciones se
     comprueban al final de cada iteraci&oacute;n en vez de al principio.
     La principal diferencia frente a los bucles regulares 
     <literal>while</literal> es que se garantiza la ejecuci&oacute;n de la
     primera iteraci&oacute;n de un bucle <literal>do..while</literal>
     (la condici&oacute;n se comprueba s&oacute;lo al final de la iteraci&oacute;n),
     mientras que puede no ser necesariamente ejecutada con un bucle
     <literal>while</literal> regular (la condici&oacute;n se comprueba
     al principio de cada iteraci&oacute;n, si esta se eval&uacute;a como
     <literal>FALSE</literal> desde el principio la ejecuci&oacute;n del bucle
     finalizar&aacute; inmediatamente).</simpara>

    <para>
     Hay una sola sintaxis para los bucles <literal>do..while</literal>:
 
     <informalexample>
      <programlisting>
 $i = 0;
 do {
     print $i;
 } while ($i>0);
      </programlisting>
     </informalexample></para>
 
    <simpara>
     El bucle de arriba se ejecutar&iacute;a exactamente una sola vez, despu&eacute;s
     de la primera iteraci&oacute;n, cuando la condici&oacute;n se comprueba,
     se eval&uacute;a como <literal>FALSE</literal> ($i no es m&aacute;s grande que 0)
     y la ejecuci&oacute;n del bucle finaliza.</simpara>
 
    <para>
     Los usuarios avanzados de C pueden estar familiarizados con un uso
     distinto del bucle <literal>do..while</literal>, para permitir parar
     la ejecuci&oacute;n en medio de los bloques de c&oacute;digo, encapsulandolos con
     <literal>do..while</literal>(0), y usando la sentencia
     <link linkend="control-structures.break"><literal>break</literal></link>.
     El siguiente fragmento de c&oacute;digo demuestra esto:
 
     <informalexample>
      <programlisting>
 do {
     if ($i < 5) {
         print "i no es lo suficientemente grande";
         break;
     }
     $i *= $factor;
     if ($i < $minimum_limit) {
         break;
     }
     print "i es correcto";
     ...procesa i...
 } while(0);
      </programlisting>
     </informalexample></para>
 
    <simpara>
     No se preocupes si no entiende esto completamente o en absoluto.
     Se pueden codificar archivos de comandos e incluso archivos de
     comandos potentes sin usar esta 'propiedad'.</simpara></sect1>
 
   <sect1 id="control-structures.for">
    <title><literal>for</literal></title>
 
    <para>
     Los bucles <literal>for</literal> son los bucles m&aacute;s complejos en
     PHP.  Se comportan como su contrapartida en C.  La sintaxis de un
     bucle <literal>for</literal> es:
 
     <informalexample>
      <programlisting>
for (expr1; expr2; expr3) sentencia
      </programlisting>
     </informalexample>
   </para>
 
    <simpara>
     La primera expresi&oacute;n (<replaceable>expr1</replaceable>) se eval&uacute;a
     (ejecuta) incondicionalmente una vez al principio del bucle.</simpara>
 
    <simpara>
     Al comienzo de cada iteraci&oacute;n, se eval&uacute;a <replaceable>expr2
     </replaceable>.  Si se eval&uacute;a como <literal>TRUE</literal>, el
     bucle contin&uacute;a y las sentencias anidadas se ejecutan. Si se eval&uacute;a
     como <literal>FALSE</literal>, la ejecuci&oacute;n del bucle finaliza.</simpara>
 
    <simpara>
     Al final de cada iteraci&oacute;n, se eval&uacute;a (ejecuta)
     <replaceable>expr3</replaceable>.</simpara>

    <simpara>
     Cada una de las expresiones puede estar vac&iacute;a.
     Que <replaceable>expr2</replaceable> est&eacute; vac&iacute;a significa
     que el bucle deber&iacute;a correr indefinidamente (PHP implicitamente
     lo considera como <literal>TRUE</literal>, al igual que C).
     Esto puede que no sea tan in&uacute;til como se podr&iacute;a pensar, puesto
     que a menudo se quiere salir de un bucle usando una sentencia
     <link linkend="control-structures.break"><literal>break</literal></link> condicional
     en vez de usar la condici&oacute;n de <literal>for</literal>.</simpara>
 
    <para>
     Considera los siguientes ejemplos.  Todos ellos muestran n&uacute;meros del
     1 al 10:
 
     <informalexample>
      <programlisting>
 /* ejemplo 1 */
 
 for ($i = 1; $i <= 10; $i++) {
     print $i;
 }
 
 /* ejemplo 2 */
 
 for ($i = 1;;$i++) {
     if ($i > 10) {
         break;
     }
     print $i;
 }
 
 /* ejemplo 3 */
 
 $i = 1;
 for (;;) {
     if ($i > 10) {
         break;
     }
     print $i;
     $i++;
 }
 
 /* ejemplo 4 */
 
 for ($i = 1; $i <= 10; print $i, $i++) ;
      </programlisting>
     </informalexample></para>
 
    <simpara>
     Por supuesto, el primer ejemplo parece ser el mas elegante (o quiz&aacute;s
     el cuarto), pero uno puede descubrir que ser capaz de usar expresiones
     vac&iacute;as en bucles <literal>for</literal> resulta &uacute;til en muchas
     ocasiones.</simpara>
 
    <para>
     PHP tambi&eacute;n soporta la "sintaxis de dos puntos" alternativa para
     bucles <literal>for</literal>.
 
     <informalexample>
      <programlisting>
 for (expr1; expr2; expr3): sentencia; ...; endfor;
      </programlisting>
     </informalexample></para>
 
   <para>
    Otros lenguajes poseen una sentencia <literal>foreach</literal> para
    traducir un array o una tabla hash. PHP3 no posee tal construcci&oacute;n;
    PHP4 s&iacute; (ver <link linkend="control-structures.foreach">foreach</link>).
    En PHP3, se puede combinar <link linkend="control-structures.while">while</link>
    con las funciones <function>list</function> y <function>each</function>
    para conseguir el mismo efecto. Mirar la documentaci&oacute;n de estas funciones
    para ver un ejemplo.
   </para>

  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>

   <para>
    PHP4 (PHP3 no) incluye una construcci&oacute;n <literal>foreach</literal>,
    tal como perl y algunos otros lenguajes. Esto simplemente da un
    modo f&aacute;cil de iterar sobre arrays. Hay dos sintaxis; la segunda es
    una extensi&oacute;n menor, pero &uacute;til de la primera:
    <informalexample>
     <programlisting>
foreach(expresion_array as $value) sentencia
foreach(expresion_array as $key => $value) sentencia
     </programlisting>
    </informalexample>
   </para>
     
   <simpara>
    La primera forma recorre el array dado por
    <literal>expresion_array</literal>. En cada iteraci&oacute;n, el valor del
    elemento actual se asigna a <literal>$value</literal> y
    el puntero interno del array se avanza en una unidad (as&iacute; en el siguiente
    paso, se estar&aacute; mirando el elemento siguiente).
   </simpara>

   <simpara>
    La segunda manera hace lo mismo, salvo que la clave del elemento
    actual ser&aacute; asignada a la variable <literal>$key</literal> en cada
    iteraci&oacute;n.
   </simpara>

   <simpara>
    Cuando <literal>foreach</literal> comienza su primera ejecuci&oacute;n,
    el puntero interno al array se reinicia autom&aacute;ticamente al primer
    elemento del array. Esto significa que no se necesita llamar a
    <function>reset</function> antes de un bucle <literal>foreach</literal>.
   </simpara>

   <para>
    Puede haber observado que las siguientes son funcionalidades id&eacute;nticas:
    <informalexample>
     <programlisting>
reset( $arr );
while( list( , $value ) = each( $arr ) ) {
   echo "Valor: $value&lt;br&gt;\n";
}

foreach( $arr as $value ) {
   echo "Valor: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
    Las siguientes tambi&eacute;n son funcionalidades id&eacute;nticas:
    <informalexample>
     <programlisting>
reset( $arr );
while( list( $key, $value ) = each( $arr ) ) {
   echo "Key: $key; Valor: $value&lt;br&gt;\n";
}

foreach( $arr as $key => $value ) {
   echo "Key: $key; Valor: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>

   <para>
    Algunos ejemplos m&aacute;s para demostrar su uso:
    <informalexample>
     <programlisting>
/* foreach ejemplo 1: s&oacute;lo valor*/
$a = array(1, 2, 3, 17);

foreach($a as $v) {
   print "Valor actual de \$a: $v.\n";
}

/* foreach ejemplo 2: valor (con clave impresa para ilustrar) */
$a = array(1, 2, 3, 17);

$i = 0; /* s&oacute;lo para prop&oacute;sitos demostrativos */

foreach($a as $v) {
   print "\$a[$i] => $k.\n";
}

/* foreach ejemplo 3: clave y valor */
$a = array(
   "uno" => 1,
   "dos" => 2,
   "tres" => 3,
   "diecisiete" => 17
);

foreach($a as $k => $v) {
   print "\$a[$k] => $v.\n";
}
     </programlisting>
    </informalexample>

   </para>

  </sect1>
 
 
   <sect1 id="control-structures.break">
    <title><literal>break</literal></title>
 
    <para>
     <literal>break</literal> escapa de la estructura de control iterante (bucle) actual.
 
     <informalexample>
      <programlisting>
$i = 0;
while ($i < 10) {
   if ($arr[$i] == "parar") {
      break;
   }
   $i++;
}
      </programlisting>
     </informalexample></para></sect1>
 
   <sect1 id="control-structures.continue">
    <title><literal>continue</literal></title>
 
    <para>
     <literal>continue</literal> se usa dentro de la estructura del bucle
     para saltar el resto de la iteraci&oacute;n actual del bucle y continuar
     la ejecuci&oacute;n al comienzo de la siguiente iteraci&oacute;n.
 
     <informalexample>
      <programlisting>
 while (list($key,$value) = each($arr)) {
     if ($key % 2) { // salta los miembros impares
         continue;
     }
     haz_algo_par ($value);
 }
      </programlisting>
     </informalexample></para></sect1>
 
   <sect1 id="control-structures.switch">
    <title><literal>switch</literal></title>
 
    <simpara>
     La sentencia <literal>switch</literal> es similar a una serie de
     sentencias IF en la misma expresi&oacute;n.  En muchas ocasiones,
     se quiere comparar la misma variable (o expresi&oacute;n) con
     nuchos valores diferentes, y ejecutar una parte de c&oacute;digo distinta
     dependiendo de a qu&eacute; valor es igual.
     Para ello sirve la sentencia <literal>switch</literal>.</simpara>
 
    <para>
     Los siguientes dos ejemplos son dos modos distintos de escribir la
     misma cosa, uno usa una serie de sentencias <literal>if</literal>,
     y el otro usa la sentencia <literal>switch</literal>:
 
     <informalexample>
      <programlisting>
 if ($i == 0) {
     print "i es igual a 0";
 }
 if ($i == 1) {
     print "i es igual a 1";
 }
 if ($i == 2) {
     print "i es igual a 2";
 }
 
 switch ($i) {
     case 0:
         print "i es igual a 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
 }
      </programlisting>
     </informalexample></para>
 
    <para>
     Es importante entender c&oacute;mo se ejecuta la sentencia 
     <literal>switch</literal> para evitar errores. La
     sentencia <literal>switch</literal> ejecuta l&iacute;nea por l&iacute;nea (realmente,
     sentencia a sentencia).  Al comienzo, no se ejecuta c&oacute;digo.
     S&oacute;lo cuando se encuentra una sentencia <literal>case</literal> con un
     valor que coincide con el valor de la expresi&oacute;n <literal>switch</literal>
     PHP comienza a ejecutar las sentencias.  PHP contin&uacute;a ejecutando las
     sentencias hasta el final del bloque <literal>switch</literal>,
     o la primera vez que vea una sentencia <literal>break</literal>.
     Si no se escribe una sentencia <literal>break</literal> al final
     de una lista de sentencias case, PHP seguir&aacute; ejecutando las sentencias
     del siguiente case.  Por ejemplo:
 
     <informalexample>
      <programlisting>
 switch ($i) {
     case 0:
         print "i es igual a 0";
     case 1:
         print "i es igual a 1";
     case 2:
         print "i es igual a 2";
 }
      </programlisting>
     </informalexample></para>
 
    <simpara>
     Aqu&iacute;, si $i es igual a 0, ¡PHP ejecutar&iacute;a todas las sentecias print!
     Si $i es igual a 1, PHP ejecutar&iacute;a las &uacute;ltimas dos sentencias print
     y s&oacute;lo si $i es igual a 2, se obtendr&iacute;a la conducta 'esperada' 
     y solamente se mostrar&iacute;a 'i es igual a 2'.  As&iacute;, es importante no
     olvidar las sentencias <literal>break</literal>
     (incluso aunque pueda querer evitar escribirlas intencionadamente
     en ciertas circunstancias).
   </simpara>

   <simpara>
	En una sentencia <literal>switch</literal>, la condici&oacute;n se
	eval&uacute;a s&oacute;lo una vez  y el resultado se compara a cada sentencia
	<literal>case</literal>.  En una sentencia <literal>elseif</literal>,
	la condici&oacute;n se eval&uacute;a otra vez.  Si tu condici&oacute;n es m&aacute;s complicada
        que una comparaci&oacute;n simple y/o est&aacute; en un bucle estrecho,
	un <literal>switch</literal> puede ser m&aacute;s r&aacute;pido.
	</simpara>
    <para>
     La lista de sentencias de un case puede tambi&eacute;n estar vac&iacute;a, lo cual
     simplemente pasa el control a la lista de sentencias del siguiente case.
     <informalexample>
      <programlisting>
 switch ($i) {
     case 0:
     case 1:
     case 2:
         print "i es menor que 3, pero no negativo";
         break;
     case 3:
         print "i es 3";
 }
      </programlisting>
     </informalexample></para>
 
    <para>
     Un case especial es el default case.  Este case coincide con
     todo lo que no coincidan los otros case. Por ejemplo:
 
     <informalexample>
      <programlisting>
 switch ($i) {
     case 0:
         print "i es igual a 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
     default:
         print "i no es igual a 0, 1 o 2";
 }
      </programlisting>
     </informalexample>
   </para>
 
    <para>
     La expresi&oacute;n <literal>case</literal> puede ser cualquier expresi&oacute;n
     que se eval&uacute;e a un tipo simple, es decir, n&uacute;meros enteros o de punto
     flotante y cadenas de texto.  No se pueden usar aqu&iacute; ni arrays ni
     objetos a menos que se conviertan a un tipo simple.
   </para>

   <para>
	La sintaxis alternativa para las estructuras de control est&aacute; tambi&eacute;n
	soportada con switch. Para m&aacute;s informaci&oacute;n, ver <link
	 linkend="control-structures.alternative-syntax">Sintaxis alternativa
	 para estructuras de control</link> .
 
     <informalexample>
      <programlisting>
switch ($i):
     case 0:
         print "i es igual 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
     default:
         print "i no es igual a 0, 1 o 2";
 endswitch;
      </programlisting>
     </informalexample></para>

  </sect1>
 
  <sect1 id="function.require">
   <title><function>require</function></title>
   
   <simpara>
	La sentencia <function>require</function> se sustituye a s&iacute; misma con
	el archivo especificado, tal y como funciona la directiva
	<literal>#include</literal> de C.
   </simpara>

   <simpara>
	Un punto importante sobre su funcionamiento es que cuando un archivo se
	incluye con <function>include</function> o se requiere con 
	<function>require</function>), el int&eacute;rprete sale del modo PHP 
	y entra en modo HTML al principio del archivo referenciado, 
	y vuelve de nuevo al modo PHP al final. Por esta raz&oacute;n, cualquier 
	c&oacute;digo dentro del archivo referenciado que debiera ser ejecutado 
	como c&oacute;digo PHP debe ser encerrado dentro de <link
	linkend="language.basic-syntax.phpmode"> etiquetas v&aacute;lidas de 
	comienzo y fin de PHP</link>.
   </simpara>

   <simpara>
	<function>require</function> no es en realidad una funci&oacute;n de PHP;
	es m&aacute;s una construcci&oacute;n del lenguaje. Est&aacute; sujeta a algunas reglas
        distintas de las de funciones. Por ejemplo,
	<function>require</function> no esta sujeto a ninguna estructura de
        control contenedora. Por otro lado, no devuelve ning&uacute;n valor; 
	intentar leer un valor de retorno de una llamada a un
	<function>require</function> resulta en un error del int&eacute;rprete.
   </simpara>

   <simpara>
	A diferencia de <function>include</function>, <function>require</function>
	<emphasis>siempre</emphasis> leer&aacute; el archivo referenciado,
	<emphasis>incluso si la l&iacute;nea en que est&aacute; no se ejecuta
        nunca</emphasis>. Si se quiere incluir condicionalmente un archivo, se
	usa <function>include</function>. La sentencia conditional no
	afecta a <function>require</function>. No obstante, si la l&iacute;nea
	en la cual aparece el <function>require</function> no se ejecuta,
	tampoco se ejecutar&aacute; el c&oacute;digo del archivo referenciado.
   </simpara>

   <simpara>
	De forma similar, las estructuras de bucle no afectan la conducta de
	<function>require</function>. Aunque el c&oacute;digo contenido en el
	archivo referenciado est&aacute; todav&iacute;a sujeto al bucle, el propio
	<function>require</function> s&oacute;lo ocurre una vez.
   </simpara>

   <para>
	Esto significa que no se puede poner una sentencia 
	<function>require</function> dentro de una estructura de bucle y 
	esperar que incluya el contenido de un archivo distinto en cada
	iteraci&oacute;n. Para hacer esto, usa una sentencia 
	<function>include</function>.
 
     <informalexample>
      <programlisting>
require( 'cabecera.inc' );
      </programlisting>
     </informalexample>
   </para>


   <para>
	Por favor, note que ambos, <function>include</function> y
	<function>require</function>, realmente incluyen el contenido del
	archivo referenciado en el archivo de comandos que lo llama;
	no llaman al archivo referenciado v&iacute;a HTTP ni nada parecido.
	As&iacute;, cualquier variable situada en el &aacute;mbito en que ocurre la
	inclusi&oacute;n, estar&aacute; disponible autom&aacute;ticamente dentro del archivo
        incluido, puesto que &eacute;ste se ha convertido en parte efectiva
	del archivo que lo llam&oacute;. 
	<informalexample>
	 <programlisting>
require( "archivo.inc?varuno=1&amp;vardos=2" ); /* No funcionar&aacute;. */

$varuno = 1;
$vardos = 2;
require( "archivo.inc" );  /* $varuno y $vardos ser&aacute;n autom&aacute;ticamente accesibles en archivo.inc */
	 </programlisting>
	</informalexample>
   </para>

   <simpara>
	No se preocupe por el hecho de que se puedan requerir o incluir
	archivos v&iacute;a HTTP usando la propiedad
        <link linkend="features.remote-files">Remote files</link>;
        lo anterior sigue siendo cierto a pesar de todo.
   </simpara>

   <simpara>
	En PHP3, es posible ejecutar una sentencia <literal>return</literal>
	dentro de un archivo referenciado con <function>require</function>,
        en tanto en cuanto esa sentencia aparezca en el &aacute;mbito global del
	archivo requerido (<function>require</function>). No puede aparecer
        dentro de ning&uacute;n bloque (lo que siginifica dentro de llaves({})).
	En PHP4, no obstante, esta capacidad ha sido desestimada.
	Si se necesita esta funcionalidad, v&eacute;ase <function>include</function>.
   </simpara>

  </sect1>
 
  <sect1 id="function.include">
   <title><function>include</function></title>
   
   <simpara>
	La sentencia <function>include</function> incluye y eval&uacute;a 
	el archivo especificado.
   </simpara>
 
   <simpara>
	Un punto importante sobre su funcionamiento es que cuando un archivo
	se incluye con <function>include</function> o se requiere con
	<function>require</function>, el int&eacute;rprete sale del modo PHP
	y entra en modo HTML al principio del archivo referenciado, 
	y vuelve de nuevo al modo PHP al final. Por esta raz&oacute;n, cualquier 
	c&oacute;digo dentro del archivo referenciado que debiera ser ejecutado 
	como c&oacute;digo PHP debe ser encerrado dentro de <link 
	linkend="language.basic-syntax.phpmode"> etiquetas v&aacute;lidas de 
	comienzo y fin de PHP</link>.
   </simpara>

    <para>
     Esto sucede cada vez que se encuentra la sentencia
     <function>include</function>, as&iacute; que se puede usar una sentencia
     <function>include</function> dentro de una estructura de bucle para
     incluir un n&uacute;mero de archivos diferentes.
 
	<informalexample>
	 <programlisting>
$archivos = array ('primero.inc', 'segundo.inc', 'tercero.inc');
for ($i = 0; $i < count($archivos); $i++) {
    include $archivos[$i];
}
	 </programlisting>
	</informalexample>
   </para>

   <para>
	<function>include</function> difiere de
	<function>require</function> en que la sentencia include se
	re-eval&uacute;a cada vez que se encuentra (y s&oacute;lo cuando est&aacute; siendo
	ejecutada), mientras que la sentencia <function>require</function>
	se reemplaza por el archivo referenciado cuando se encuentra por
	primera vez, se vaya a evaluar el contenido del archivo o no
	(por ejemplo, si est&aacute; dentro de una sentencia <link
	linkend="control-structures.if">if</link> cuya condici&oacute;n evaluada
	es falsa).
   </para>
 
   <para>
	Debido a que <function>include</function> es una construcci&oacute;n especial
	del lenguaje, se debe encerrar dentro de un bloque de sentencias si
	est&aacute; dentro de un bloque condicional.
 
	<informalexample>
	 <programlisting>
 /* Esto es ERRÓNEO y no funcionar&aacute; como se desea. */
 
 if ($condicion)
     include($archivo);
 else
     include($otro);
 
 /* Esto es CORRECTO. */
 
 if ($condicion) {
     include($archivo);
 } else {
     include($otro);
 }
	 </programlisting>
	</informalexample>
   </para>
 
   <para>
	En ambos, PHP3 y PHP4, es posible ejecutar una sentencia
	<literal>return</literal> dentro de un archivo incluido con
	<function>include</function>, para terminar el procesado de ese
	archivo y volver al archivo de comandos que lo llam&oacute;.
	Existen algunas diferencias en el modo en que esto funciona,
	no obstante. La primera es que en PHP3, <literal>return</literal> 
	no puede aparecer dentro de un bloque a menos que sea un bloque de
	funci&oacute;n, en el cual <literal>return</literal> se aplica a esa funci&oacute;n
	y no al archivo completo. En PHP4, no obstante, esta restricci&oacute;n no
	existe. Tambi&eacute;n, PHP4 permite devolver valores desde archivos incluidos
	con <function>include</function>. Se puede capturar el valor de la
	llamada a <function>include</function> como se har&iacute;a con una
	funci&oacute;n normal. Esto genera un error de int&eacute;rprete en PHP3.

   <example>
	<title><function>include</function> en PHP3 y PHP4</title>
	<para>
	 Asumamos la existencia del siguiente archivo (llamado
	 <filename>test.inc</filename>) en el mismo directorio que el
	 archivo principal:
	 <programlisting>
&lt?php
echo "Antes del return &lt;br&gt;\n";
if ( 1 ) {
   return 27;
}
echo "Despu&eacute;s del return &lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>
	
	<para>
	 Asumamos que el archivo principal (<filename>main.html</filename>)
	 contiene lo siguiente:
	 <programlisting>
&lt?php
$retval = include( 'test.inc' );
echo "El archivo devolvi&oacute;: '$retval'&lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>
	
	<para>
	 Cuando se llama a <filename>main.html</filename> en PHP3,
	 generar&aacute; un error del int&eacute;rprete en la linea 2; no se puede
	 capturar el valor de un <function>include</function> en PHP3.
	 En PHP4, no obstante, el resultado ser&aacute;:
	 <screen>
Antes del return
El archivo devolvi&oacute;: '27'
	 </screen>
	</para>

	<para>
	 Ahora, asumamos que se ha modificado <filename>main.html</filename>
	 para que contenga lo siguiente:
	 <programlisting>
&lt?php
include( 'test.inc' );
echo "De vuelta en main.html&lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>

	<para>
	 En PHP4, la salida ser&aacute;:
	 <screen>
Antes del return
De vuelta en main.html
	 </screen>
	 No obstante, PHP3 dar&aacute; la siguiente salida:
	 <screen>
Antes del return
27De vuelta en main.html

Parse error: parse error in /home/torben/public_html/phptest/main.html on line 5
	 </screen>
	</para>

	<para>
	 El error del int&eacute;rprete es resultado del hecho de que la sentencia
	 <literal>return</literal> est&aacute; encerrada en un bloque de no-funci&oacute;n
	 dentro de <filename>test.inc</filename>. Cuando el return se mueve
	 fuera del bloque, la salida es:
	 <screen>
Antes del return
27De vuelta en main.html
	 </screen>
	</para>

	<para>
	 El '27' esp&uacute;reo se debe al hecho de que PHP3 no soporta devolver
	 valores con <literal>return</literal> desde archivos como ese. 
	</para>
   </example>
   <para>
	Por favor, note que ambos, <function>include</function> y
	<function>require</function>, realmente incluyen el contenido del
	archivo referenciado en el archivo de comandos que lo llama;
	no llaman al archivo referenciado v&iacute;a HTTP ni nada parecido.
	As&iacute;, cualquier variable situada en el &aacute;mbito en que ocurre la
	inclusi&oacute;n, estar&aacute; disponible autom&aacute;ticamente dentro del archivo
        incluido, puesto que &eacute;ste se ha convertido en parte efectiva
	del archivo que lo llam&oacute;. 
	<informalexample>
	 <programlisting>
include( "archivo.inc?varuno=1&amp;vardos=2" ); /* No funcionar&aacute;. */

$varuno = 1;
$vardos = 2;
include( "archivo.inc" );  /* $varuno y $vardos ser&aacute;n autom&aacute;ticamente accesibles en archivo.inc*/

	 </programlisting>
	</informalexample>

   </para>

   <simpara>
	No se preocupe por el hecho de que se puedan requerir o incluir
	archivos v&iacute;a HTTP usando la propiedad
        <link linkend="features.remote-files">Remote files</link>;
        lo anterior sigue siendo cierto a pesar de todo.
   </simpara>

   <simpara>
	V&eacute;ase tambi&eacute;n <function>readfile</function>,
	<function>require</function>, y <function>virtual</function>.
   </simpara>
  </sect1>
 
  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
