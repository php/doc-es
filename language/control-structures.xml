<?xml version="1.0" encoding="iso-8859-1"?>
  <chapter id="control-structures">
   <title>Estructuras de Control</title>

   <simpara>
    Todo archivo de comandos PHP se compone de una serie de sentencias.
    Una sentencia puede ser una asignaci&oacute;n, una llamada a funci&oacute;n, un bucle,
    una sentencia condicional e incluso una sentencia que no haga nada 
    (una sentencia vac&iacute;a). Las sentencias normalmente acaban con punto y
    coma. Adem&aacute;s, las sentencias se pueden agrupar en grupos de sentencias
    encapsulando un grupo de sentencias con llaves. Un grupo de sentencias
    es tambi&eacute;n una sentencia. En este cap&iacute;tulo se describen los diferentes
    tipos de sentencias.</simpara>

   <sect1 id="control-structures.if">
    <title><literal>if</literal></title>
    <para>
     La construcci&oacute;n <literal>if</literal> es una de las m&aacute;s importantes
     caracter&iacute;sticas de muchos lenguajes, incluido PHP. Permite la ejecuci&oacute;n
     condicional de fragmentos de c&oacute;digo. PHP caracteriza una estructura 
     <literal>if</literal> que es similar a la de C:
     <informalexample>
      <programlisting>
 if (expr)
     sentencia
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Como se describe en la secci&oacute;n sobre expresiones, expr se eval&uacute;a
     a su valor condicional. Si <replaceable>expr</replaceable>
     se eval&uacute;a como &true;, PHP ejecutar&aacute; la sentencia,
     y si se eval&uacute;a como &false; - la ignorar&aacute;.
    </simpara>
    <para>
     El siguiente ejemplo mostrar&iacute;a <computeroutput>a es mayor
     que b</computeroutput> si <replaceable>$a</replaceable> fuera mayor
     que <replaceable>$b</replaceable>:
     <informalexample>
      <programlisting role="php">
 if ($a > $b)
     print "a es mayor que b";
      </programlisting>
     </informalexample>
    </para>
    <para>
     A menudo, se desea tener m&aacute;s de una sentencia ejecutada de forma
     condicional. Por supuesto, no hay necesidad de encerrar cada sentencia
     con una cl&aacute;usula <literal>if</literal>. En vez de eso, se pueden agrupar
     varias sentencias en un grupo de sentencias.
     Por ejemplo, este c&oacute;digo mostrar&iacute;a <computeroutput>a es mayor que
     b</computeroutput> si <replaceable>$a</replaceable> fuera mayor que
     <replaceable>$b</replaceable>, y entonces asignar&iacute;a el valor de
     <replaceable>$a</replaceable> a <replaceable>$b</replaceable>:
     <informalexample>
      <programlisting role="php">
 if ($a > $b) {
     print "a es mayor que b";
     $b = $a;
 }
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Las sentencias if se pueden anidar indefinidamente dentro de otras
     sentencias <literal>if</literal>, lo cual proporciona una flexibilidad
     completa para ejecuciones condicionales en las diferentes partes de
     tu programa.
    </simpara>
   </sect1>
 
   <sect1 id="control-structures.else">
    <title><literal>else</literal></title>
    <para>
     A menudo queremos ejecutar una sentencia si se cumple una cierta
     condicion, y una sentencia distinta si la condici&oacute;n no se cumple.
     Esto es para lo que sirve <literal>else</literal>.
     <literal>else</literal> extiende una sentencia <literal>if</literal>
     para ejecutar una sentencia en caso de que la expresi&oacute;n en la sentencia
     <literal>if</literal> se eval&uacute;e como &false;.  Por
     ejemplo, el siguiente c&oacute;digo mostrar&iacute;a <computeroutput>a es mayor que
     b</computeroutput> si <replaceable>$a</replaceable> fuera mayor que
     <replaceable>$b</replaceable>, y <computeroutput>a NO es mayor que b
     </computeroutput> en cualquier otro caso:
     <informalexample>
      <programlisting role="php">
 if ($a > $b) {
     print "a es mayor que b";
 } else {
     print "a NO es mayor que b";
 }
      </programlisting>
     </informalexample>
 
     La sentencia <literal>else</literal> se ejecuta solamente si la
     expresi&oacute;n <literal>if</literal> se eval&uacute;a como &false;,
     y si hubiera alguna expresi&oacute;n <literal>elseif</literal> - s&oacute;lo si se
     evaluaron tambi&eacute;n a &false; (Ver <link
     linkend="control-structures.elseif">elseif</link>).
     </para>
    </sect1>
 
   <sect1 id="control-structures.elseif">
    <title><literal>elseif</literal></title>
 
    <para>
     <literal>elseif</literal>, como su nombre sugiere, es una combinaci&oacute;n
     de <literal>if</literal> y <literal>else</literal>.  Como
     <literal>else</literal>, extiende una sentencia <literal>if</literal>
     para ejecutar una sentencia diferente en caso de que la expresi&oacute;n
     <literal>if</literal> original se eval&uacute;a como &false;.
     No obstante, a diferencia de <literal>else</literal>, ejecutar&aacute;
     esa expresi&oacute;n alternativa solamente si la expresi&oacute;n condicional
     <literal>elseif</literal> se eval&uacute;a como &true;.
     Por ejemplo, el siguiente c&oacute;digo mostrar&iacute;a <computeroutput>a es
     mayor que b</computeroutput>, <computeroutput>a es igual a b
     </computeroutput> o <computeroutput>a es menor que b</computeroutput>:
     <informalexample>
      <programlisting role="php">
 if ($a > $b) {
     print "a es mayor que b";
 } elseif ($a == $b) {
     print "a es igual que b";
 } else {
     print "a es mayor que b";
 }
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Puede haber varios <literal>elseif</literal>s dentro de la misma
     sentencia <literal>if</literal>.  La primera expresi&oacute;n 
     <literal>elseif</literal> (si hay alguna) que se eval&uacute;e como
     &true; se ejecutar&iacute;a.  En PHP, tambi&eacute;n se puede
     escribir 'else if' (con dos palabras) y el comportamiento ser&iacute;a
     id&eacute;ntico al de un 'elseif' (una sola palabra). El significado
     sint&aacute;ctico es ligeramente distinto (si estas familiarizado con C,
     es el mismo comportamiento) pero la l&iacute;nea b&aacute;sica es que
     ambos resultar&iacute;an tener exactamente el mismo comportamiento.
    </simpara> 
    <simpara>
     La sentencia <literal>elseif</literal> se ejecuta s&oacute;lo si la expresi&oacute;n
     <literal>if</literal> precedente y cualquier expresi&oacute;n
     <literal>elseif</literal> precedente se eval&uacute;an como
     &false;, y la expresi&oacute;n
     <literal>elseif</literal> actual se eval&uacute;a como &true;.
    </simpara>
   </sect1>
 
   <sect1 id="control-structures.alternative-syntax">
    <title>Sintaxis Alternativa de Estructuras de Control</title>
   <para>
	PHP ofrece una sintaxis altenativa para alguna de sus estructuras
        de control; a saber, <literal>if</literal>,
	<literal>while</literal>, <literal>for</literal>, y
	<literal>switch</literal>.  En cada caso, la forma b&aacute;sica de la
	sintaxis alternativa es cambiar abrir-llave por dos puntos (:) y
	cerrar-llave por <literal>endif;</literal>,
	<literal>endwhile;</literal>, <literal>endfor;</literal>, or
	<literal>endswitch;</literal>, respectivamente.
      <informalexample>
       <programlisting role="php">
 &lt;?php if ($a==5): ?&gt;
 A es igual a 5
 &lt;?php endif; ?&gt;
       </programlisting>
      </informalexample>
    </para>
     <simpara>
      En el ejemplo de arriba, el bloque HTML "A = 5" se anida dentro de una
      sentencia <literal>if</literal> escrita en la sintaxis alternativa.
      El bloque HTML se mostrar&iacute;a solamente si $a fuera igual a 5.
     </simpara>
     <para>
      La sintaxis alternativa se aplica a <literal>else</literal>
      y tambi&eacute;n a <literal>elseif</literal>.  La siguiente es una
      estructura <literal>if</literal> con <literal>elseif</literal>
      y <literal>else</literal> en el formato alternativo:
      <informalexample>
       <programlisting role="php">
 if ($a == 5):
     print "a es igual a 5";
     print "...";
 elseif ($a == 6):
     print "a es igual a 6";
     print "!!!";
 else:
     print "a no es ni 5 ni 6";
 endif;
       </programlisting>
      </informalexample>
   </para>
   <para>
	Mirar tambi&eacute;n <link linkend="control-structures.while">while</link>,
	<link linkend="control-structures.for">for</link>, e <link
	 linkend="control-structures.if">if</link> para m&aacute;s ejemplos.
   </para>
  </sect1>
 
   <sect1 id="control-structures.while">
    <title><literal>while</literal></title>
    <para>
     Los bucles <literal>while</literal> son los tipos de bucle m&aacute;s simples
     en PHP. Se comportan como su contrapartida en C.  La forma b&aacute;sica de
     una sentencia <literal>while</literal> es:
     <informalexample>
      <programlisting>
 while (expr) sentencia
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     El significado de una sentencia <literal>while</literal> es simple.
     Le dice a PHP que ejecute la(s) sentencia(s) anidada(s) repetidamente,
     mientras la expresi&oacute;n <literal>while</literal> se eval&uacute;e como
     &true;.  El valor de la expresi&oacute;n es
     comprobado cada vez al principio del bucle, as&iacute; que incluso si este
     valor cambia durante la ejecuci&oacute;n de la(s) sentencia(s) anidada(s),
     la ejecuci&oacute;n no parar&aacute; hasta el fin de la iteraci&oacute;n (cada vez que
     PHP ejecuta las sentencias en el bucle es una iteraci&oacute;n).
     A veces, si la expresi&oacute;n <literal>while</literal> se eval&uacute;a como
     &false; desde el principio de todo, la(s) sentencia(s)
     anidada(s) no se ejecutar&aacute;n ni siquiera una vez.
    </simpara>
    <para>
     Como con la sentencia <literal>if</literal>, se pueden agrupar
     multiples sentencias dentro del mismo bucle <literal>while</literal>
     encerrando un grupo de sentencias con llaves, o usando la sintaxis
     alternativa:
     <informalexample>
      <programlisting>
 while (expr): sentencia ... endwhile;
      </programlisting>
     </informalexample>
    </para>
    <para>
      Los siguientes ejemplos son id&eacute;nticos, y ambos imprimen n&uacute;meros del
      1 al 10:
     <informalexample>
      <programlisting>
 /* ejemplo 1 */
 
 $i = 1;
 while ($i <= 10) {
     print $i++;  /* el valor impreso ser&iacute;a
                     $i antes del incremento
                     (post-incremento) */
 }
 
 /* ejemplo 2 */
 
 $i = 1;
 while ($i <= 10):
     print $i;
     $i++;
 endwhile;
      </programlisting>
     </informalexample>
    </para>
   </sect1>
 
 
   <sect1 id="control-structures.do.while">
    <title><literal>do..while</literal></title>
 
    <simpara>
     Los bucles <literal>do..while</literal> son muy similares a los
     bucles <literal>while</literal>, excepto que las condiciones se
     comprueban al final de cada iteraci&oacute;n en vez de al principio.
     La principal diferencia frente a los bucles regulares 
     <literal>while</literal> es que se garantiza la ejecuci&oacute;n de la
     primera iteraci&oacute;n de un bucle <literal>do..while</literal>
     (la condici&oacute;n se comprueba s&oacute;lo al final de la iteraci&oacute;n),
     mientras que puede no ser necesariamente ejecutada con un bucle
     <literal>while</literal> regular (la condici&oacute;n se comprueba
     al principio de cada iteraci&oacute;n, si esta se eval&uacute;a como
     &false; desde el principio la ejecuci&oacute;n del bucle
     finalizar&aacute; inmediatamente).
    </simpara>
    <para>
     Hay una sola sintaxis para los bucles <literal>do..while</literal>:
 
     <informalexample>
      <programlisting role="php">
 $i = 0;
 do {
     print $i;
 } while ($i>0);
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     El bucle de arriba se ejecutar&iacute;a exactamente una sola vez, despu&eacute;s
     de la primera iteraci&oacute;n, cuando la condici&oacute;n se comprueba,
     se eval&uacute;a como &false; ($i no es m&aacute;s grande que 0)
     y la ejecuci&oacute;n del bucle finaliza.
    </simpara>
    <para>
     Los usuarios avanzados de C pueden estar familiarizados con un uso
     distinto del bucle <literal>do..while</literal>, para permitir parar
     la ejecuci&oacute;n en medio de los bloques de c&oacute;digo, encapsulandolos con
     <literal>do..while</literal>(0), y usando la sentencia
     <link linkend="control-structures.break"><literal>break</literal></link>.
     El siguiente fragmento de c&oacute;digo demuestra esto:
     <informalexample>
      <programlisting role="php">
 do {
     if ($i < 5) {
         print "i no es lo suficientemente grande";
         break;
     }
     $i *= $factor;
     if ($i < $minimum_limit) {
         break;
     }
     print "i es correcto";
     ...procesa i...
 } while(0);
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     No se preocupes si no entiende esto completamente o en absoluto.
     Se pueden codificar archivos de comandos e incluso archivos de
     comandos potentes sin usar esta 'propiedad'.
    </simpara>
   </sect1>
 
   <sect1 id="control-structures.for">
    <title><literal>for</literal></title>
    <para>
     Los bucles <literal>for</literal> son los bucles m&aacute;s complejos en
     PHP.  Se comportan como su contrapartida en C.  La sintaxis de un
     bucle <literal>for</literal> es:
     <informalexample>
      <programlisting>
for (expr1; expr2; expr3) sentencia
      </programlisting>
     </informalexample>
   </para>
   <simpara>
     La primera expresi&oacute;n (<replaceable>expr1</replaceable>) se eval&uacute;a
     (ejecuta) incondicionalmente una vez al principio del bucle.
   </simpara>
   <simpara>
     Al comienzo de cada iteraci&oacute;n, se eval&uacute;a <replaceable>expr2
     </replaceable>.  Si se eval&uacute;a como &true;, el
     bucle contin&uacute;a y las sentencias anidadas se ejecutan. Si se eval&uacute;a
     como &false;, la ejecuci&oacute;n del bucle finaliza.
   </simpara>
   <simpara>
     Al final de cada iteraci&oacute;n, se eval&uacute;a (ejecuta)
     <replaceable>expr3</replaceable>.
   </simpara>
    <simpara>
     Cada una de las expresiones puede estar vac&iacute;a.
     Que <replaceable>expr2</replaceable> est&eacute; vac&iacute;a significa
     que el bucle deber&iacute;a correr indefinidamente (PHP implicitamente
     lo considera como &true;, al igual que C).
     Esto puede que no sea tan in&uacute;til como se podr&iacute;a pensar, puesto
     que a menudo se quiere salir de un bucle usando una sentencia
     <link linkend="control-structures.break"><literal>break</literal></link> 
     condicional en vez de usar la condici&oacute;n de <literal>for</literal>.
    </simpara>
    <para>
     Considera los siguientes ejemplos.  Todos ellos muestran n&uacute;meros del
     1 al 10:
 
     <informalexample>
      <programlisting role="php">
 /* ejemplo 1 */
 
 for ($i = 1; $i <= 10; $i++) {
     print $i;
 }
 
 /* ejemplo 2 */
 
 for ($i = 1;;$i++) {
     if ($i > 10) {
         break;
     }
     print $i;
 }
 
 /* ejemplo 3 */
 
 $i = 1;
 for (;;) {
     if ($i > 10) {
         break;
     }
     print $i;
     $i++;
 }
 
 /* ejemplo 4 */
 
 for ($i = 1; $i <= 10; print $i, $i++) ;
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Por supuesto, el primer ejemplo parece ser el mas elegante (o quiz&aacute;s
     el cuarto), pero uno puede descubrir que ser capaz de usar expresiones
     vac&iacute;as en bucles <literal>for</literal> resulta &uacute;til en muchas
     ocasiones.
    </simpara>
    <para>
     PHP tambi&eacute;n soporta la "sintaxis de dos puntos" alternativa para
     bucles <literal>for</literal>.
     <informalexample>
      <programlisting>
 for (expr1; expr2; expr3): sentencia; ...; endfor;
      </programlisting>
     </informalexample>
   </para>
   <para>
    Otros lenguajes poseen una sentencia <literal>foreach</literal> para
    traducir un array o una tabla hash. PHP3 no posee tal construcci&oacute;n;
    PHP4 s&iacute; (ver <link linkend="control-structures.foreach">foreach</link>).
    En PHP3, se puede combinar <link linkend="control-structures.while">while</link>
    con las funciones <function>list</function> y <function>each</function>
    para conseguir el mismo efecto. Mirar la documentaci&oacute;n de estas funciones
    para ver un ejemplo.
   </para>
  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP4 (PHP3 no) incluye una construcci&oacute;n <literal>foreach</literal>,
    tal como perl y algunos otros lenguajes. Esto simplemente da un
    modo f&aacute;cil de iterar sobre arrays. Hay dos sintaxis; la segunda es
    una extensi&oacute;n menor, pero &uacute;til de la primera:
    <informalexample>
     <programlisting>
foreach(expresion_array as $value) sentencia
foreach(expresion_array as $key => $value) sentencia
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La primera forma recorre el array dado por
    <literal>expresion_array</literal>. En cada iteraci&oacute;n, el valor del
    elemento actual se asigna a <literal>$value</literal> y
    el puntero interno del array se avanza en una unidad (as&iacute; en el siguiente
    paso, se estar&aacute; mirando el elemento siguiente).
   </simpara>
   <simpara>
    La segunda manera hace lo mismo, salvo que la clave del elemento
    actual ser&aacute; asignada a la variable <literal>$key</literal> en cada
    iteraci&oacute;n.
   </simpara>
   <para>
    <note>
     <para>
    Cuando <literal>foreach</literal> comienza su primera ejecuci&oacute;n,
    el puntero interno a la lista (array) se reinicia autom&aacute;ticamente al primer
    elemento del array. Esto significa que no se necesita llamar a
    <function>reset</function> antes de un bucle <literal>foreach</literal>.
     </para>
    </note>
   </para>
   <para>
    <note>
         <para>
           Hay que tener en cuanta que<literal>foreach</literal> con una
           copia de la lista (array) especificada y no la lista en si, por
           ello el puntero de la lista no es modificado como en la construcci&oacute;n 
           each.
         </para>
    </note>
   </para>
   <para>
    Puede haber observado que las siguientes son funcionalidades id&eacute;nticas:
    <informalexample>
     <programlisting role="php">
reset( $arr );
while( list( , $value ) = each( $arr ) ) {
   echo "Valor: $value&lt;br&gt;\n";
}

foreach( $arr as $value ) {
   echo "Valor: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
    Las siguientes tambi&eacute;n son funcionalidades id&eacute;nticas:
    <informalexample>
     <programlisting role="php">
reset( $arr );
while( list( $key, $value ) = each( $arr ) ) {
   echo "Key: $key; Valor: $value&lt;br&gt;\n";
}

foreach( $arr as $key => $value ) {
   echo "Key: $key; Valor: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Algunos ejemplos m&aacute;s para demostrar su uso:
    <informalexample>
     <programlisting role="php">
/* foreach ejemplo 1: s&oacute;lo valor*/
$a = array(1, 2, 3, 17);

foreach($a as $v) {
   print "Valor actual de \$a: $v.\n";
}

/* foreach ejemplo 2: valor (con clave impresa para ilustrar) */
$a = array(1, 2, 3, 17);

$i = 0; /* s&oacute;lo para prop&oacute;sitos demostrativos */

foreach($a as $v) {
   print "\$a[$i] => $k.\n";
}

/* foreach ejemplo 3: clave y valor */
$a = array(
   "uno" => 1,
   "dos" => 2,
   "tres" => 3,
   "diecisiete" => 17
);

foreach($a as $k => $v) {
   print "\$a[$k] => $v.\n";
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.break">
    <title><literal>break</literal></title> 
    <simpara>
     <literal>break</literal> escapa de la estructuras de control 
     iterante (bucle) actuales <literal>for</literal>, <literal>while</literal>, o
    <literal>switch</literal>.
    </simpara>
    <simpara>
    <literal>break</literal> accepta un par&aacute;metro opcional, el cual determina 
    cuantas estructuras de control hay que escapar.
   </simpara>
   <para>
     <informalexample>
      <programlisting role="php">
$arr = array ('one', 'two', 'three', 'four', 'stop', 'five');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* You could also write 'break 1;' here. */
    }
    echo "$val&lt;br&gt;\n";
}

/* Using the optional argument. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5&lt;br&gt;\n";
        break 1;  /* Exit only the switch. */
    case 10:
        echo "At 10; quitting&lt;br&gt;\n";
        break 2;  /* Exit the switch and the while. */
    default:
        break;
    }
}
      </programlisting>
     </informalexample>
    </para>
   </sect1>
 
   <sect1 id="control-structures.continue">
    <title><literal>continue</literal></title>
 
    <simpara>
     <literal>continue</literal> se usa dentro de la estructura del bucle
     para saltar el resto de la iteraci&oacute;n actual del bucle y continuar
     la ejecuci&oacute;n al comienzo de la siguiente iteraci&oacute;n.
    </simpara>
   <simpara>
    <literal>continue</literal> accepta un par&aacute;metro opcional, el cual determina 
    cuantos niveles (bluces) hay que saltar antes de continuar con la ejecuci&oacute;n.
   </simpara>
   <para>
     <informalexample>
      <programlisting role="php">
 while (list($key,$value) = each($arr)) {
     if ($key % 2) { // salta los miembros impares
         continue;
     }
     do_something_odd ($value);
 }
$i = 0;
while ($i++ &lt; 5) {
    echo "Outer&lt;br&gt;\n";
    while (1) {
        echo "&nbsp;&nbsp;Middle&lt;br&gt;\n";
        while (1) {
            echo "&nbsp;&nbsp;Inner&lt;br&gt;\n";
            continue 3;
        }
        echo "This never gets output.&lt;br&gt;\n";
    }
    echo "Neither does this.&lt;br&gt;\n";
}
      </programlisting>
     </informalexample>
    </para>
   </sect1>
 
   <sect1 id="control-structures.switch">
    <title><literal>switch</literal></title>
 
    <simpara>
     La sentencia <literal>switch</literal> es similar a una serie de
     sentencias IF en la misma expresi&oacute;n.  En muchas ocasiones,
     se quiere comparar la misma variable (o expresi&oacute;n) con
     nuchos valores diferentes, y ejecutar una parte de c&oacute;digo distinta
     dependiendo de a qu&eacute; valor es igual.
     Para ello sirve la sentencia <literal>switch</literal>.
    </simpara>
    <para>
     Los siguientes dos ejemplos son dos modos distintos de escribir la
     misma cosa, uno usa una serie de sentencias <literal>if</literal>,
     y el otro usa la sentencia <literal>switch</literal>:
     <informalexample>
      <programlisting role="php">
 if ($i == 0) {
     print "i es igual a 0";
 }
 if ($i == 1) {
     print "i es igual a 1";
 }
 if ($i == 2) {
     print "i es igual a 2";
 }
 
 switch ($i) {
     case 0:
         print "i es igual a 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
 }
      </programlisting>
     </informalexample>
    </para>
    <para>
     Es importante entender c&oacute;mo se ejecuta la sentencia 
     <literal>switch</literal> para evitar errores. La
     sentencia <literal>switch</literal> ejecuta l&iacute;nea por l&iacute;nea (realmente,
     sentencia a sentencia).  Al comienzo, no se ejecuta c&oacute;digo.
     S&oacute;lo cuando se encuentra una sentencia <literal>case</literal> con un
     valor que coincide con el valor de la expresi&oacute;n <literal>switch</literal>
     PHP comienza a ejecutar las sentencias.  PHP contin&uacute;a ejecutando las
     sentencias hasta el final del bloque <literal>switch</literal>,
     o la primera vez que vea una sentencia <literal>break</literal>.
     Si no se escribe una sentencia <literal>break</literal> al final
     de una lista de sentencias case, PHP seguir&aacute; ejecutando las sentencias
     del siguiente case.  Por ejemplo:
     <informalexample>
      <programlisting role="php">
 switch ($i) {
     case 0:
         print "i es igual a 0";
     case 1:
         print "i es igual a 1";
     case 2:
         print "i es igual a 2";
 }
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Aqu&iacute;, si $i es igual a 0, ¡PHP ejecutar&iacute;a todas las sentecias print!
     Si $i es igual a 1, PHP ejecutar&iacute;a las &uacute;ltimas dos sentencias print
     y s&oacute;lo si $i es igual a 2, se obtendr&iacute;a la conducta 'esperada' 
     y solamente se mostrar&iacute;a 'i es igual a 2'.  As&iacute;, es importante no
     olvidar las sentencias <literal>break</literal>
     (incluso aunque pueda querer evitar escribirlas intencionadamente
     en ciertas circunstancias).
   </simpara>
   <simpara>
	En una sentencia <literal>switch</literal>, la condici&oacute;n se
	eval&uacute;a s&oacute;lo una vez  y el resultado se compara a cada sentencia
	<literal>case</literal>.  En una sentencia <literal>elseif</literal>,
	la condici&oacute;n se eval&uacute;a otra vez.  Si tu condici&oacute;n es m&aacute;s complicada
        que una comparaci&oacute;n simple y/o est&aacute; en un bucle estrecho,
	un <literal>switch</literal> puede ser m&aacute;s r&aacute;pido.
   </simpara>
   <para>
     La lista de sentencias de un case puede tambi&eacute;n estar vac&iacute;a, lo cual
     simplemente pasa el control a la lista de sentencias del siguiente case.
     <informalexample>
      <programlisting role="php">
 switch ($i) {
     case 0:
     case 1:
     case 2:
         print "i es menor que 3, pero no negativo";
         break;
     case 3:
         print "i es 3";
 }
      </programlisting>
     </informalexample>
    </para>
    <para>
     Un case especial es el default case.  Este case coincide con
     todo lo que no coincidan los otros case. Por ejemplo:
     <informalexample>
      <programlisting role="php">
 switch ($i) {
     case 0:
         print "i es igual a 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
     default:
         print "i no es igual a 0, 1 o 2";
 }
      </programlisting>
     </informalexample>
   </para>
    <para>
     La expresi&oacute;n <literal>case</literal> puede ser cualquier expresi&oacute;n
     que se eval&uacute;e a un tipo simple, es decir, n&uacute;meros enteros o de punto
     flotante y cadenas de texto.  No se pueden usar aqu&iacute; ni arrays ni
     objetos a menos que se conviertan a un tipo simple.
   </para>
   <para>
	La sintaxis alternativa para las estructuras de control est&aacute; tambi&eacute;n
	soportada con switch. Para m&aacute;s informaci&oacute;n, ver <link
	 linkend="control-structures.alternative-syntax">Sintaxis alternativa
	 para estructuras de control</link>.
     <informalexample>
      <programlisting role="php">
switch ($i):
     case 0:
         print "i es igual 0";
         break;
     case 1:
         print "i es igual a 1";
         break;
     case 2:
         print "i es igual a 2";
         break;
     default:
         print "i no es igual a 0, 1 o 2";
 endswitch;
      </programlisting>
     </informalexample>
  </para>
  </sect1>
 
  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
	La sentencia <function>require</function> se sustituye a s&iacute; misma con
	el archivo especificado, tal y como funciona la directiva
	<literal>#include</literal> de C.
   </simpara>
   <simpara>
	Un punto importante sobre su funcionamiento es que cuando un archivo se
	incluye con <function>include</function> o se requiere con 
	<function>require</function>), el int&eacute;rprete sale del modo PHP 
	y entra en modo HTML al principio del archivo referenciado, 
	y vuelve de nuevo al modo PHP al final. Por esta raz&oacute;n, cualquier 
	c&oacute;digo dentro del archivo referenciado que debiera ser ejecutado 
	como c&oacute;digo PHP debe ser encerrado dentro de <link
	linkend="language.basic-syntax.phpmode"> etiquetas v&aacute;lidas de 
	comienzo y fin de PHP</link>.
   </simpara>
   <simpara>
	<function>require</function> no es en realidad una funci&oacute;n de PHP;
	es m&aacute;s una construcci&oacute;n del lenguaje. Est&aacute; sujeta a algunas reglas
        distintas de las de funciones. Por ejemplo,
	<function>require</function> no esta sujeto a ninguna estructura de
        control contenedora. Por otro lado, no devuelve ning&uacute;n valor; 
	intentar leer un valor de retorno de una llamada a un
	<function>require</function> resulta en un error del int&eacute;rprete.
   </simpara>
   <simpara>
	A diferencia de <function>include</function>, <function>require</function>
	<emphasis>siempre</emphasis> leer&aacute; el archivo referenciado,
	<emphasis>incluso si la l&iacute;nea en que est&aacute; no se ejecuta
        nunca</emphasis>. Si se quiere incluir condicionalmente un archivo, se
	usa <function>include</function>. La sentencia conditional no
	afecta a <function>require</function>. No obstante, si la l&iacute;nea
	en la cual aparece el <function>require</function> no se ejecuta,
	tampoco se ejecutar&aacute; el c&oacute;digo del archivo referenciado.
   </simpara>
   <simpara>
	De forma similar, las estructuras de bucle no afectan la conducta de
	<function>require</function>. Aunque el c&oacute;digo contenido en el
	archivo referenciado est&aacute; todav&iacute;a sujeto al bucle, el propio
	<function>require</function> s&oacute;lo ocurre una vez.
   </simpara>
   <para>
	Esto significa que no se puede poner una sentencia 
	<function>require</function> dentro de una estructura de bucle y 
	esperar que incluya el contenido de un archivo distinto en cada
	iteraci&oacute;n. Para hacer esto, usa una sentencia 
	<function>include</function>.
     <informalexample>
      <programlisting role="php">
require( 'header.inc' );
      </programlisting>
     </informalexample>
   </para>
   <simpara>
    When a file is <function>require</function>ed, the code it
    contains inherits the variable scope of the line on which the
    <function>require</function> occurs. Any variables available at
    that line in the calling file will be available within the called
    file. If the <function>require</function> occurs inside a
    function within the calling file, then all of the code contained
    in the called file will behave as though it had been defined
    inside that function.
   </simpara>
   <para>
    If the <function>require</function>ed file is called via HTTP
    using the fopen wrappers, and if the target server interprets the
    target file as PHP code, variables may be passed to the
    <function>require</function>ed file using an URL request string as
    used with HTTP GET. This is not strictly speaking the same thing
    as <function>require</function>ing the file and having it inherit
    the parent file's variable scope; the script is actually being run
    on the remote server and the result is then being included into
    the local script.
    <informalexample>
     <programlisting role="php">
/* This example assumes that someserver is configured to parse .php
 * files and not .txt files. Also, 'works' here means that the variables 
 * $varone and $vartwo are available within the require()ed file. */

/* Won't work; file.txt wasn't handled by someserver. */
require ("http://someserver/file.txt?varone=1&amp;vartwo=2");

/* Won't work; looks for a file named 'file.php?varone=1&amp;vartwo=2'
 * on the local filesystem. */
require ("file.php?varone=1&amp;vartwo=2");               

/* Works. */
require ("http://someserver/file.php?varone=1&amp;vartwo=2"); 

$varone = 1;
$vartwo = 2;
require ("file.txt");  /* Works. */
require ("file.php");  /* Works. */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
	En PHP3, es posible ejecutar una sentencia <literal>return</literal>
	dentro de un archivo referenciado con <function>require</function>,
        en tanto en cuanto esa sentencia aparezca en el &aacute;mbito global del
	archivo requerido (<function>require</function>). No puede aparecer
        dentro de ning&uacute;n bloque (lo que siginifica dentro de llaves({})).
	En PHP4, no obstante, esta capacidad ha sido desestimada.
	Si se necesita esta funcionalidad, v&eacute;ase <function>include</function>.
   </simpara>
   <simpara>
    Ver tambien <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
     y <function>virtual</function>.
   </simpara>
  </sect1>
 
  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
	La sentencia <function>include</function> incluye y eval&uacute;a 
	el archivo especificado.
   </simpara>
   <simpara>
    Si "URL fopen wrappers" esta activada en PHP (como est&aacute; en la
    configuraci&oacute;n inicial), se puede especificar el fichero que se 
    va a incluir usando una URL en vez de un fichero local (con su Path)
    Ver <link linkend="features.remote-files">Ficheros remotos</link> 
    y <function>fopen</function> para m&aacute;s informaci&oacute;n.
   </simpara>
   <simpara>
	Un punto importante sobre su funcionamiento es que cuando un archivo
	se incluye con <function>include</function> o se requiere con
	<function>require</function>, el int&eacute;rprete sale del modo PHP
	y entra en modo HTML al principio del archivo referenciado, 
	y vuelve de nuevo al modo PHP al final. Por esta raz&oacute;n, cualquier 
	c&oacute;digo dentro del archivo referenciado que debiera ser ejecutado 
	como c&oacute;digo PHP debe ser encerrado dentro de <link 
	linkend="language.basic-syntax.phpmode"> etiquetas v&aacute;lidas de 
	comienzo y fin de PHP</link>.
   </simpara>
    <para>
     Esto sucede cada vez que se encuentra la sentencia
     <function>include</function>, as&iacute; que se puede usar una sentencia
     <function>include</function> dentro de una estructura de bucle para
     incluir un n&uacute;mero de archivos diferentes.
 
	<informalexample>
	 <programlisting role="php">
$archivos = array ('primero.inc', 'segundo.inc', 'tercero.inc');
for ($i = 0; $i < count($archivos); $i++) {
    include $archivos[$i];
}
	 </programlisting>
	</informalexample>
   </para>
   <para>
	<function>include</function> difiere de
	<function>require</function> en que la sentencia include se
	re-eval&uacute;a cada vez que se encuentra (y s&oacute;lo cuando est&aacute; siendo
	ejecutada), mientras que la sentencia <function>require</function>
	se reemplaza por el archivo referenciado cuando se encuentra por
	primera vez, se vaya a evaluar el contenido del archivo o no
	(por ejemplo, si est&aacute; dentro de una sentencia <link
	linkend="control-structures.if">if</link> cuya condici&oacute;n evaluada
	es falsa).
   </para>
   <para>
	Debido a que <function>include</function> es una construcci&oacute;n especial
	del lenguaje, se debe encerrar dentro de un bloque de sentencias si
	est&aacute; dentro de un bloque condicional.
	<informalexample>
	 <programlisting role="php">
 /* Esto es ERR&Oacute;NEO y no funcionar&aacute; como se desea. */
 
 if ($condicion)
     include($archivo);
 else
     include($otro);
 
 /* Esto es CORRECTO. */
 
 if ($condicion) {
     include($archivo);
 } else {
     include($otro);
 }
	 </programlisting>
	</informalexample>
   </para>
   <simpara>
	En ambos, PHP3 y PHP4, es posible ejecutar una sentencia
	<literal>return</literal> dentro de un archivo incluido con
	<function>include</function>, para terminar el procesado de ese
	archivo y volver al archivo de comandos que lo llam&oacute;.
	Existen algunas diferencias en el modo en que esto funciona,
	no obstante. La primera es que en PHP3, <literal>return</literal> 
	no puede aparecer dentro de un bloque a menos que sea un bloque de
	funci&oacute;n, en el cual <literal>return</literal> se aplica a esa funci&oacute;n
	y no al archivo completo. En PHP4, no obstante, esta restricci&oacute;n no
	existe. Tambi&eacute;n, PHP4 permite devolver valores desde archivos 
        incluidos con <function>include</function>. Se puede capturar el valor de la
	llamada a <function>include</function> como se har&iacute;a con una
	funci&oacute;n normal. Esto genera un error de int&eacute;rprete en PHP3.
   </simpara>
   <example>
	<title><function>include</function> en PHP3 y PHP4</title>
	<para>
	 Asumamos la existencia del siguiente archivo (llamado
	 <filename>test.inc</filename>) en el mismo directorio que el
	 archivo principal:
	 <programlisting role="php">
&lt?php
echo "Antes del return &lt;br&gt;\n";
if ( 1 ) {
   return 27;
}
echo "Despu&eacute;s del return &lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>
	<para>
	 Asumamos que el archivo principal (<filename>main.html</filename>)
	 contiene lo siguiente:
	 <programlisting role="php">
&lt?php
$retval = include( 'test.inc' );
echo "El archivo devolvi&oacute;: '$retval'&lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>
	<para>
	 Cuando se llama a <filename>main.html</filename> en PHP3,
	 generar&aacute; un error del int&eacute;rprete en la linea 2; no se puede
	 capturar el valor de un <function>include</function> en PHP3.
	 En PHP4, no obstante, el resultado ser&aacute;:
	 <screen>
Antes del return
El archivo devolvi&oacute;: '27'
	 </screen>
	</para>
	<para>
	 Ahora, asumamos que se ha modificado <filename>main.html</filename>
	 para que contenga lo siguiente:
	 <programlisting role="php">
&lt?php
include( 'test.inc' );
echo "De vuelta en main.html&lt;br&gt;\n";
?&gt;
	 </programlisting>
	</para>
	<para>
	 En PHP4, la salida ser&aacute;:
	 <screen>
Antes del return
De vuelta en main.html
	 </screen>
	 No obstante, PHP3 dar&aacute; la siguiente salida:
	 <screen>
Antes del return
27De vuelta en main.html

Parse error: parse error in /home/torben/public_html/phptest/main.html on line 5
	 </screen>
	</para>
	<para>
	 El error del int&eacute;rprete es resultado del hecho de que la sentencia
	 <literal>return</literal> est&aacute; encerrada en un bloque de no-funci&oacute;n
	 dentro de <filename>test.inc</filename>. Cuando el return se mueve
	 fuera del bloque, la salida es:
	 <screen>
Antes del return
27De vuelta en main.html
	 </screen>
	</para>
	<para>
	 El '27' esp&uacute;reo se debe al hecho de que PHP3 no soporta devolver
	 valores con <literal>return</literal> desde archivos como ese. 
	</para>
   </example>
   <simpara>
    When a file is <function>include</function>ed, the code it
    contains inherits the variable scope of the line on which the
    <function>include</function> occurs. Any variables available at
    that line in the calling file will be available within the called
    file. If the <function>include</function> occurs inside a
    function within the calling file, then all of the code contained
    in the called file will behave as though it had been defined
    inside that function.
   </simpara>
   <para>
    If the <function>include</function>ed file is called via HTTP
    using the fopen wrappers, and if the target server interprets the
    target file as PHP code, variables may be passed to the
    <function>include</function>ed file using an URL request string as
    used with HTTP GET. This is not strictly speaking the same thing
    as <function>include</function>ing the file and having it inherit
    the parent file's variable scope; the script is actually being run
    on the remote server and the result is then being included into
    the local script.
    <informalexample>
     <programlisting role="php">
/* This example assumes that someserver is configured to parse .php
 * files and not .txt files. Also, 'works' here means that the variables 
 * $varone and $vartwo are available within the include()ed file. */

/* Won't work; file.txt wasn't handled by someserver. */
include ("http://someserver/file.txt?varone=1&amp;vartwo=2");

/* Won't work; looks for a file named 'file.php?varone=1&amp;vartwo=2'
 * on the local filesystem. */
include ("file.php?varone=1&amp;vartwo=2");               

/* Works. */
include ("http://someserver/file.php?varone=1&amp;vartwo=2"); 

$varone = 1;
$vartwo = 2;
include ("file.txt");  /* Works. */
include ("file.php");  /* Works. */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    See also <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
        and <function>virtual</function>.
   </simpara>
  </sect1>
 
  <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    The <function>require_once</function> statement replaces
    itself with the specified file, much like the C preprocessor's
    <literal>#include</literal> works, and in that respect is
        similar to the <function>require</function> statement. The main
        difference is that in an inclusion chain, the use of
        <function>require_once</function> will assure that the code is
        added to your script only once, and avoid clashes with variable
        values or function names that can happen.
   </para>
   <para>
     For example, if you create the following 2 include files
         <literal>utils.inc</literal> and <literal>foolib.inc</literal>
         <example>
         <title>utils.inc</title>
         <programlisting role="php">
&lt;?php
define(PHPVERSION, floor(phpversion()));
echo "GLOBALS ARE NICE\n";
function goodTea() {
        return "Oolong tea tastes good!";
}
?&gt;
         </programlisting>
         </example>
         <example>
         <title>foolib.inc</title>
         <programlisting role="php">
&lt;?php
require ("utils.inc");
function showVar($var) {
        if (PHPVERSION == 4) {
                print_r($var);
        } else {
                dump_var($var);
        }
}

// bunch of other functions ...
?&gt;
         </programlisting>
         </example>
         And then you write a script <literal>cause_error_require.php</literal>
         <example>
         <title>cause_error_require.php</title>
         <programlisting role="php">
&lt;?php
require("foolib.inc");
/* the following will generate an error */
require("utils.inc");
$foo = array("1",array("complex","quaternion"));
echo "this is requiring utils.inc again which is also\n";
echo "required in foolib.inc\n";
echo "Running goodTea: ".goodTea()."\n";
echo "Printing foo: \n";
showVar($foo);
?&gt;
         </programlisting>
         </example>
         When you try running the latter one, the resulting ouptut will be (using
         PHP 4.01pl2):
         <informalexample>
         <programlisting>
GLOBALS ARE NICE
GLOBALS ARE NICE

Fatal error:  Cannot redeclare causeerror() in utils.inc on line 5
         </programlisting>
         </informalexample>
         By modifying <literal>foolib.inc</literal> and
         <literal>cause_errror_require.php</literal> 
         to use <function>require_once</function>
         instead of <function>require</function> and renaming the
         last one to <literal>avoid_error_require_once.php</literal>, we have:
         <example>
         <title>foolib.inc (fixed)</title>
         <programlisting role="php">
...
require_once("utils.inc");
function showVar($var) {
...
         </programlisting>
         </example>
         <example>
         <title>avoid_error_require_once.php</title>
         <programlisting role="php">
...
require_once("foolib.inc");
require_once("utils.inc");
$foo = array("1",array("complex","quaternion"));
...
         </programlisting>
         </example>
         And when running the latter, the output will be (using PHP 4.0.1pl2):
         <informalexample>
         <programlisting>
GLOBALS ARE NICE
this is requiring globals.inc again which is also
required in foolib.inc
Running goodTea: Oolong tea tastes good!
Printing foo:
Array
(
    [0] =&gt; 1
    [1] =&gt; Array
        (
            [0] =&gt; complex
            [1] =&gt; quaternion
        )

)
         </programlisting>
         </informalexample>
   </para>
   <para>
     Also note that, analogous to the behavior of the
         <literal>#include</literal> of the C preprocessor, this statement
         acts at "compile time", e.g. when the script is parsed and before it
         is executed, and should not be used for parts of the script that need
         to be inserted dynamically during its execution. You should use
         <function>include_once</function> or <function>include</function>
         for that purpose.
   </para>
   <para>
     For more examples on using <function>require_once</function> and 
         <function>include_once</function>, look at the PEAR code included in
         the latest PHP source code distributions.
   </para>
   <para>
    See also: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
        and <function>virtual</function>.
   </para>
  </sect1>
  
  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    The <function>include_once</function> statement includes and evaluates
    the specified file during the execution of the script.
        This is a behavior similar to the <function>include</function> statement,
        with the important difference that if the code from a file has already
        been included, it will not be included again.
   </para>
   <para>
    As mentioned in the <function>require_once</function> description, the
        <function>include_once</function> should be used in the cases in which
        the same file might be included and evaluated more than once during a
        particular execution of a script, and you want to be sure that it is
        included exactly once to avoid problems with function redefinitions,
        variable value reassignments, etc.
   </para>
   <para>
     For more examples on using <function>require_once</function> and 
         <function>include_once</function>, look at the PEAR code included in
         the latest PHP source code distributions.
   </para>
   <para>
    See also: <function>require</function>,
    <function>include</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
        and <function>virtual</function>.
   </para>
  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
