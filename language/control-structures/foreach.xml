<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: af4410a7e15898c3dbe83d6ea38246745ed9c6fb Maintainer: jpberdejo Status: ready -->

<sect1 xml:id="control-structures.foreach" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title><literal>foreach</literal></title>
 <para>
  PHP 4 introdujo un constructor <literal>foreach</literal>, muy
  parecido al de Perl y algunos otros lenguajes. Simplemente da un modo fácil de
  iterar sobre arrays. <literal>foreach</literal> sólo trabaja sólo sobre arrays y
  resultará en un error al intentar usarlo en una variable con un diferente
  tipo de datos o una variable no inicializada. Hay dos sintaxis; la
  segunda es una extensión menor, pero útil de la primera:
  <informalexample>
   <programlisting>
<![CDATA[
foreach (array_expression as $value)
    sentencias
foreach (array_expression as $key => $value)
    sentencias
]]>
   </programlisting>
  </informalexample>
 </para>
 <simpara>
  La primera forma recorre el array dado por
  <literal>array_expression</literal>. En cada ciclo, el valor de
  el elemento actual es asignado a <literal>$value</literal> y
  el puntero interno del array es avanzado en uno (así en el próximo
  ciclo se estará mirando el siguiente elemento).
 </simpara>
 <simpara>
  La segunda manera hace lo mismo, excepto que la clave del elemento
  actual será asignada a la variable
  <literal>$key</literal> en cada ciclo.
 </simpara>
 <simpara>
  A partir de PHP 5, es posible
  <link linkend="language.oop5.iterations">iterar objetos</link> también.
 </simpara>
 <para>
  <note>
   <para>
    Cuando <literal>foreach</literal> inicia la primera ejecución, el
    puntero interno del array se pone automáticamente en el primer elemento
    del array. Esto significa que no es necesario llamar la función 
    <function>reset</function> antes de un bucle 
    <literal>foreach</literal>.
   </para>
  </note>
 </para>
 <para>
  <note>
   <para>
    A menos que el array este <link linkend="language.references">referenciado</link>,
    <literal>foreach</literal> opera sobre una copia del
    array especificado y no sobre el propio array. <literal>foreach</literal>
    tiene algunos efectos secundarios sobre el puntero del array. No se puede confiar en el puntero
    del array durante o después del <literal>foreach</literal> sin reposicionarlo.
   </para>
  </note>
 </para>
 <para>
  A partir de PHP 5, se pueden modificar fácilmente elementos del array al preceder
  <literal>$value</literal> con &amp;. Esto asignará
  una <link linkend="language.references">referencia</link> en lugar de copiar
  el valor.
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr ahora es array(2, 4, 6, 8)
unset($value); // rompe la referencia con el último elemento
?>
]]>
   </programlisting>
  </informalexample>
  Esto sólo es posible si el array iterado puede ser referenciado (es decir, es una
  variable), lo que significa que el código siguiente no funciona:
   <programlisting role="php">
<![CDATA[
<?php
foreach (array(1, 2, 3, 4) as &$value) {
    $value = $value * 2;
}

?>
]]>
   </programlisting>
 </para>
 <warning>
  <para>
   Referencia del <literal>$value</literal> y el último elemento del array
   permanecen aún después del bucle <literal>foreach</literal>. Se recomienda
   destruirlos con <function>unset</function>.
  </para>
 </warning>
 <para>
  <note>
   <para>
    <literal>foreach</literal> no soporta la capacidad de 
    suprimir mensajes de error usando '@'.
   </para>
  </note>
 </para>
 <para>
  Puede haber notado que las siguientes son funcionalmente
  idénticas:
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array("uno", "dos", "tres");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "Valor: $value<br />\n";
}

foreach ($arr as $value) {
    echo "Valor: $value<br />\n";
}
?>
]]>
   </programlisting>
  </informalexample>
  Las siguientes también son funcionalmente idénticas:
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr = array("uno", "dos", "tres");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "Clave: $key; Valor: $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Clave: $key; Valor: $value<br />\n";
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <para>
  Algunos ejemplos más para demostrar su uso:
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
/* foreach ejemplo 1: sólo valor */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
    echo "Valor actual de \$a: $v.\n";
}

/* foreach ejemplo 2: valor (con su notación de acceso manual impreso con fines ilustrativos) */

$a = array(1, 2, 3, 17);

$i = 0; /* sólo para efectos ilustrativos */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* foreach ejemplo 3: clave y valor */

$a = array(
    "uno" => 1,
    "dos" => 2,
    "tres" => 3,
    "diecisiete" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* foreach ejemplo 4: arrays multi-dimensionales */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* foreach ejemplo 5: arrays dinámicos */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

