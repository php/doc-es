<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.61 Maintainer: lboshell Status: ready -->
 <chapter id="security.index">
  <title>Seguridad</title>

  <simpara>
PHP es un poderoso lenguaje e int&eacute;rprete, ya sea incluido como
parte de un servidor web en forma de m&oacute;dulo o ejecutado como un
binario <acronym>CGI</acronym> separado, es capaz de acceder a
archivos, ejecutar comandos y abrir conexiones de red en el
servidor. Estas propiedades hacen que cualquier cosa que sea ejecutada
en un servidor web sea insegura por naturaleza. PHP est&aacute;
dise&ntilde;ado espec&iacute;ficamente para ser un lenguaje m&aacute;s
seguro para escribir programas CGI que Perl o C, y con la
selecci&oacute;n correcta de opciones de configuraci&oacute;n en
tiempos de compilaci&oacute;n y ejecuci&oacute;n, y siguiendo algunas
pr&aacute;cticas correctas de programaci&oacute;n, PHP le puede dar la
combinaci&oacute;n precisa de libertad y seguridad que usted necesita.
  </simpara>
  <simpara>
Ya que hay muchas maneras de utilizar PHP, existen varias opciones de
configuraci&oacute;n dise&ntilde;adas para controlar su
comportamiento. Un amplio rango de opciones le garantizan que pueda
usar PHP para muchos prop&oacute;sitos distintos, pero tambi&eacute;n
quiere decir que hay combinaciones de &eacute;stas opciones y
configuraciones de servidor que pueden resultar en un entorno
inseguro.
  </simpara>
  <simpara>
El nivel de flexibilidad en la configuraci&oacute;n de PHP se compara
quiz&aacute;s solo con su flexibilidad de desarrollo. PHP puede ser
usado para escribir aplicaciones completas de servidor, con todo el
poder de un usuario de un int&eacute;rprete de comandos, o puede ser
usado para inclusiones simples del lado del servidor con muy poco
riesgo en un entorno minuciosamente controlado. C&oacute;mo construir
ese entorno, y qu&eacute; tan seguro es, b&aacute;sicamente depende
del desarrollador PHP.
  </simpara>
  <simpara>
Este cap&iacute;tulo comienza con algunas recomendaciones generales de
seguridad, explica las diferentes combinaciones de opciones de
configuraci&oacute;n y las situaciones en las que pueden ser usadas
con seguridad, y describe diferentes consideraciones a la hora de
programar para diferentes niveles de seguridad.
  </simpara>

  <sect1 id="security.general">
   <title>Consideraciones generales</title>
   <simpara>
La pretensi&oacute;n de contar con un sistema completamente seguro es
pr&aacute;cticamente un imposible, de modo que el enfoque usado con
mayor frecuencia en la profesi&oacute;n de seguridad es uno que busque
el balance adecuado entre riesgo y funcionalidad. Si cada variable
enviada por un usuario requiriera de dos formas de validaci&oacute;n
biom&eacute;trica (como rastreo de retinas y an&aacute;lisis
dactilar), usted contar&iacute;a con un nivel extremadamente alto de
confiabilidad. Tambi&eacute;n implicar&iacute;a que llenar los datos
de un formulario razonablemente complejo podr&iacute;a tomar media
hora, cosa que podr&iacute;a incentivar a los usuarios a buscar
m&eacute;todos para esquivar los mecanismos de seguridad.
   </simpara>
   <simpara>
La mejor seguridad con frecuencia es lo suficientemente razonable como
para suplir los requerimientos dados sin prevenir que el usuario
realice su labor de forma natural, y sin sobrecargar al autor del
c&oacute;digo con una complejidad excesiva. De hecho, algunos ataques
de seguridad son simples recursos que aprovechan las vulnerabilidades
de este tipo de seguridad sobrecargada, que tiende a erosionarse con
el tiempo.
   </simpara>
   <simpara>
Una frase que vale la pena recordar: Un sistema es apenas tan bueno
como el eslab&oacute;n m&aacute;s d&eacute;bil de una cadena. Si todas
las transacciones son registradas copiosamente bas&aacute;ndose en la
fecha/hora, ubicaci&oacute;n, tipo de transacci&oacute;n, etc. pero la
verificaci&oacute;n del usuario se realiza &uacute;nicamente mediante
una cookie sencilla, la validez de atar a los usuarios al registro de
transacciones es mermada severamente.
   </simpara>
   <simpara>
Cuando realice pruebas, tenga en mente que no ser&aacute; capaz de
probar todas las diferentes posibilidades, incluso para las
p&aacute;ginas m&aacute;s simples. Los datos de entrada que usted
puede esperar en sus aplicaciones no necesariamente tendr&aacute;n
relaci&oacute;n alguna con el tipo de informaci&oacute;n que
podr&iacute;a ingresar un empleado disgustado, un cracker con meses de
tiempo entre sus manos, o un gato dom&eacute;stico caminando sobre el
teclado. Es por esto que es mejor observar el c&oacute;digo desde una
perspectiva l&oacute;gica, para determinar en d&oacute;nde
podr&iacute;an introducirse datos inesperados, y luego hacer un
seguimiento de c&oacute;mo esta informaci&oacute;n es modificada,
reducida o amplificada.
   </simpara>
   <simpara>
Internet est&aacute; repleto de personas que tratan de crearse fama al
romper la seguridad de su c&oacute;digo, bloquear su sitio, publicar
contenido inapropiado, y por lo dem&aacute;s haciendo que sus
d&iacute;as sean m&aacute;s interesantes. No importa si usted
administra un sitio peque&ntilde;o o grande, usted es un objetivo por
el simple hecho de estar en l&iacute;nea, por tener un servidor al
cual es posible conectarse. Muchas aplicaciones de cracking no hacen
distinciones por tama&ntilde;os, simplemente recorren bloques masivos
de direcciones IP en busca de v&iacute;ctimas. Trate de no convertirse
en una.
   </simpara>
  </sect1>

  <sect1 id="security.cgi-bin">
   <title>Instalaci&oacute;n como un binario CGI</title>

   <sect2 id="security.cgi-bin.attacks">
    <title>Posibles ataques</title>
    <simpara>
El uso de PHP como un binario <acronym>CGI</acronym> es una
opci&oacute;n para el tipo de situaciones en las que por alguna
raz&oacute;n no se desea integrar PHP como m&oacute;dulo de
alg&uacute;n software de servidor web (como Apache), o en donde se
espera usar PHP con diferentes tipos de capas que envuelven el entorno
CGI para crear ambientes chroot y setuid seguros para la
ejecuci&oacute;n de scripts. Esta configuraci&oacute;n usualmente
involucra la instalaci&oacute;n de un binario ejecutable del
int&eacute;rprete PHP en el directorio cgi-bin del servidor web. El
aviso de seguridad de CERT <ulink url="&url.cert;">CA-96.11</ulink>
recomienda que se evite la colocaci&oacute;n de cualquier
int&eacute;rprete bajo cgi-bin. Incluso si el binario PHP puede ser
usado como un int&eacute;rprete independiente, PHP est&aacute;
dise&ntilde;ado para prevenir el tipo de ataques que esta
configuraci&oacute;n hace posible:
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       Acceso a archivos del sistema: <filename
       role="url">http://mi.servidor/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
La informaci&oacute;n del query en una url, la cual viene
despu&eacute;s del signo de interrogaci&oacute;n (?), es pasada como
argumentos de l&iacute;nea de comandos al int&eacute;rprete por la
interfaz CGI. Usualmente los int&eacute;rpretes abren y ejecutan el
archivo especificado como primer argumento de la l&iacute;nea de
comandos.
      </simpara>
      <simpara>
Cuando es invocado como un binario CGI, PHP se reh&uacute;sa a
interpretar los argumentos de la l&iacute;nea de comandos.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Acceso a cualquier documento web en el servidor: <filename
       role="url">http://mi.servidor/cgi-bin/php/zona_secreta/doc.html</filename>
      </simpara>
      <simpara>
El segmento de la url que sigue al nombre del binario de PHP, que
contiene la informaci&oacute;n sobre la ruta <filename
role="uri">/zona_secreta/doc.html</filename> es usada
convencionalmente para especificar el nombre de un archivo que ha de
ser abierto e interpretado por el programa
<acronym>CGI</acronym>. Usualmente, algunas directivas de
configuraci&oacute;n del servidor web (Apache: Action) son usadas para
redireccionar peticiones de documentos como <filename
role="url">http://mi.servidor/zona_secreta/script.php</filename> al
int&eacute;rprete de PHP. Bajo este modelo, el servidor web revisa
primero los permisos de acceso al directorio <filename
role="uri">/zona_secreta</filename>, y despu&eacute;s de eso crea la
petici&oacute;n de redireccionamiento a <filename
role="url">http://mi.servidor/cgi-bin/php/zona_secreta/script.php</filename>.
Desafortunadamente, si la petici&oacute;n se hace originalmente en
esta forma, no se realizan chequeos de acceso por parte del servidor
web para el archivo <filename
role="uri">/zona_secreta/script.php</filename>, &uacute;nicamente para
el archivo <filename role="uri">/cgi-bin/php</filename>. De este modo,
cualquier usuario capaz de acceder a <filename
role="uri">/cgi-bin/php</filename> es capaz tambi&eacute;n de acceder
a cualquier documento protegido en el servidor web.
      </simpara>
      <simpara>
En PHP, la configuraci&oacute;n de tiempo de compilaci&oacute;n <link
linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
y las directivas de configuraci&oacute;n en tiempo de ejecuci&oacute;n
<link linkend="ini.doc-root">doc_root</link> y <link
linkend="ini.user-dir">user_dir</link> pueden ser usadas para prevenir
este tipo de ataques, si el &aacute;rbol de documentos del servidor
llegara a tener directorio alguno con restricciones de
acceso. Consulte las siguientes secciones para una explicaci&oacute;n
detallada de las diferentes combinaciones.
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="security.cgi-bin.default">
    <title>Caso 1: s&oacute;lo se sirven archivos p&uacute;blicos</title>

    <simpara>
Si su servidor no tiene contenido alguno que no est&eacute;
restringido por contrase&ntilde;as o control de acceso basado en
direcciones ip, no hay ninguna necesidad de recurrir a estas opciones
de configuraci&oacute;n. Si su servidor web no le permite hacer
redireccionamientos, o el servidor no tiene una forma de comunicarle
al binario PHP que la petici&oacute;n de redireccionamiento es segura,
puede especificar la opci&oacute;n <link
linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
en el script de configuraci&oacute;n. Aun as&iacute; debe asegurarse
de que sus scripts PHP no dependan de alguna forma especial de hacer
llamados al script, ya sea directamente mediante <filename
role="php">http://mi.servidor/cgi-bin/php/dir/script.php</filename> ni
por la redirecci&oacute;n <filename
role="php">http://mi.servidor/dir/script.php</filename>.
    </simpara>
    <simpara>
Los redireccionamientos pueden ser configurados en Apache mediante el
uso de directivas AddHandler y Action (vea m&aacute;s adelante).
    </simpara>

   </sect2>

   <sect2 id="security.cgi-bin.force-redirect">
    <title>Caso 2: uso de --enable-force-cgi-redirect</title>
    <simpara>
Esta opci&oacute;n en tiempo de compilaci&oacute;n previene que
cualquier persona haga llamados a PHP directamente mediante una url
como <filename
role="php">http://mi.servidor/cgi-bin/php/directorio_secreto/script.php</filename>.
En lugar de esto, PHP analizar&aacute; documentos de esta forma
&uacute;nicamente si han pasado por una regla de redirecci&oacute;n
del servidor web.
    </simpara>
    <simpara>
Por lo general, el redireccionamiento en la configuraci&oacute;n de
Apache es realizada con alguna de las siguientes directivas:
    </simpara>
    <programlisting role="apache-conf">
<![CDATA[
Action php-script /cgi-bin/php
AddHandler php-script .php
]]>
    </programlisting>
    <simpara>
Esta opci&oacute;n ha sido probada &uacute;nicamente con el servidor
web Apache, y depende de que Apache defina la variable de entorno
no-est&aacute;ndar <envar>REDIRECT_STATUS</envar> a la hora de
gestionar peticiones redirigidas. Si su servidor web no dispone de
modo alguno de comunicar si la petici&oacute;n es directa o
redirigida, no puede usar esta opci&oacute;n y debe recurrir a alguna
de las otras formas documentadas aqu&iacute; de ejecutar la
versi&oacute;n CGI.
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.doc-root">
    <title>Caso 3: configuraci&oacute;n de doc_root o user_dir</title>
    <simpara>
Incluir contenido activo en los directorios de documentos del servidor
web, como scripts y ejecutables, es considerada en ocasiones una
pr&aacute;ctica insegura. Si, por alg&uacute;n fallo de
configuraci&oacute;n, los scripts no llegaran a ser ejecutados sino
desplegados como documentos HTML normales, esto podr&iacute;a resultar
en la revelaci&oacute;n de informaci&oacute;n cr&iacute;tica como
trabajos cubiertos por normas de propiedad intelectual o datos de
seguridad como contrase&ntilde;as. Por lo tanto muchos administradores
de sistemas preferir&aacute;n la configuraci&oacute;n de otra
estructura de directorios para los scripts que sean asequibles
&uacute;nicamente a trav&eacute;s del CGI PHP, y por lo tanto deben
ser interpretados siempre y no desplegados directamente.
    </simpara>
    <simpara>
As&iacute; mismo, si el m&eacute;todo para asegurarse de que las
peticiones no son redireccionadas, tal y como se describi&oacute; en
la secci&oacute;n anterior, no est&aacute; disponible, es necesario
entonces configurar un directorio ra&iacute;z (doc_root) de scripts
que sea diferente al directorio ra&iacute;z de documentos web.
    </simpara>
    <simpara>
Puede definir el directorio ra&iacute;z para scripts de PHP mediante
la directiva de configuraci&oacute;n <link
linkend="ini.doc-root">doc_root</link> en el <link
linkend="configuration.file">archivo de configuraci&oacute;n</link>, o
puede darle un valor a la variable de entorno
<envar>PHP_DOCUMENT_ROOT</envar>. Si &eacute;sta est&aacute; definida,
la versi&oacute;n CGI de PHP construir&aacute; siempre el nombre del
archivo a abrir con este <parameter>doc_root</parameter> y la
informaci&oacute;n de la ruta dada en la petici&oacute;n, de modo que
puede estar seguro de que ning&uacute;n script ser&aacute; ejecutado
por fuera de este directorio (excepto por aquellos indicados en
<parameter>user_dir</parameter>, como se ver&aacute; a
continuaci&oacute;n).
    </simpara>
    <simpara>
Otra opci&oacute;n que puede ser usada en este caso es <link
linkend="ini.user-dir">user_dir</link>. Cuando user_dir no est&aacute;
definida, lo &uacute;nico que controla la apretura de archivos es
<parameter>doc_root</parameter>. Abrir una url como <filename
role="url">http://mi.servidor/~usuario/doc.php</filename> no resulta
en la apertura de un archivo bajo el directorio personal del usuario,
sino de un archivo llamado <filename
role="uri">~usuario/doc.php</filename> bajo la ruta doc_root
(as&iacute; es, un directorio cuyo nombre comienza por el caracter de
equivalencia [<literal>~</literal>]).
    </simpara>
    <simpara>
Si user_dir est&aacute; definido como, por ejemplo, <filename
role="dir">public_php</filename>, una petici&oacute;n como <filename
role="url">http://mi.servidor/~usuario/doc.php</filename>
abrir&aacute; un archivo llamado <filename>doc.php</filename> bajo el
directorio con el nombre <filename role="dir">public_php</filename>
ubicado en el directorio personal del usuario. Si el directorio
personal del usuario es <filename role="dir">/home/usuario</filename>,
el archivo ejecutado es
<filename>/home/usuario/public_php/doc.php</filename>.
    </simpara>
    <simpara>
La expansi&oacute;n del valor de <parameter>user_dir</parameter>
ocurre independientemente del par&aacute;metro
<parameter>doc_root</parameter>, de modo que es posible controlar el
directorio ra&iacute;z de los documentos y el acceso a los directorios
de los usuarios en forma separada.
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.shell">
    <title>Caso 4: int&eacute;rprete PHP por fuera del &aacute;rbol web</title>
    <para>
Una opci&oacute;n bastante segura es colocar el int&eacute;rprete
binario de PHP en alguna parte por fuera del &aacute;rbol de archivos
web. En <filename role="dir">/usr/local/bin</filename>, por
ejemplo. El &uacute;nico inconveniente real con esta alternativa es
que ahora usted tendr&aacute; que colocar una l&iacute;nea como esta:
     <informalexample>
      <programlisting>
<![CDATA[
#!/usr/local/bin/php
]]>
      </programlisting>
     </informalexample>
al comienzo de cualquier archivo que contenga etiquetas
PHP. Tambi&eacute;n tendr&aacute; que hacer cada archivo
ejecutable. Esto quiere decir que debe tratarlo exactamente igual a
como tratar&iacute;a cualquier otro script CGI escrito en Perl o sh o
cualquier otro lenguaje de scripting com&uacute;n que usara el
mecanismo de escape-shell <literal>#!</literal> para el lanzamiento
del int&eacute;rprete.
    </para>
    <para>
Para lograr que PHP gestione correctamente la informaci&oacute;n de
<envar>PATH_INFO</envar> y <envar>PATH_TRANSLATED</envar> con este
tipo de configuraci&oacute;n, el int&eacute;rprete PHP debe haber sido
compilado con la opci&oacute;n de configuraci&oacute;n <link
linkend="install.configure.enable-discard-path">--enable-discard-path</link>.
    </para>
   </sect2>

  </sect1>

  <sect1 id="security.apache">
   <title>Instalaci&oacute;n como m&oacute;dulo de Apache</title>
   <simpara>
Cuando PHP es usado como un m&oacute;dulo de Apache, hereda los
permisos del usuario de Apache (generalmente los del usuario
"nobody"). Este hecho representa varios impactos sobre la seguridad y
las autorizaciones. Por ejemplo, si est&aacute; usando PHP para
acceder a una base de datos, a menos que tal base de datos disponga de
un control de acceso propio, usted tendr&aacute; que hacer que la base
de datos sea asequible por el usuario "nobody".  Esto quiere decir que
un script malicioso podr&iacute;a tener acceso y modificar la base de
datos, incluso sin un nombre de usuario y contrase&ntilde;a. Es
completamente posible que un archivador automatizado de documentos web
pudiera toparse con la p&aacute;gina web de administraci&oacute;n de
una base de datos, y eliminar todas sus bases de datos. Usted puede
protegerse de este tipo de situaciones mediante mecanismos de
autorizaci&oacute;n de Apache, o puede dise&ntilde;ar su propio modelo
de acceso usando LDAP, archivos &htaccess;, etc. e incluir ese
c&oacute;digo como parte de sus scripts PHP.
   </simpara>
   <simpara>
Con frecuencia, una vez la seguridad se ha establecido en un punto en
donde el usuario de PHP (en este caso, el usuario de apache) tiene
asociada una muy leve capacidad de riesgo, se descubre que PHP se
encuentra ahora imposibilitado de escribir archivos en los directorios
de los usuarios. O quiz&aacute;s se le haya desprovisto de la
capacidad de acceder o modificar bases de datos. Se ha prevenido
exitosamente que pudiera escribir tanto archivos buenos como malos, o
que pudiera realizar transacciones buenas o malas en la base de datos.
   </simpara>
   <simpara>
Un error de seguridad cometido con frecuencia en este punto es darle
permisos de administrador (root) a apache, o incrementar las
habilidades del usuario de apache de alguna otra forma.
   </simpara>
   <simpara>
Escalar los permisos del usuario de Apache hasta el nivel de
administrador es extremadamente peligroso y puede comprometer al
sistema entero, as&iacute; que el uso de entornos sudo, chroot, o
cualquier otro mecanismo que sea ejecutado como root no deber&iacute;a
ser una opci&oacute;n viable para aquellos que no son profesionales en
seguridad.
   </simpara>
   <simpara>
Existen otras soluciones m&aacute;s simples. Mediante el uso de <link
linkend="ini.open-basedir">open_basedir</link> usted puede controlar y
restringir aquellos directorios que podr&iacute;an ser usados por
PHP. Tambi&eacute;n puede definir &aacute;reas solo-Apache, para
restringir todas las actividades basadas en web a archivos que no son
de usuarios, o del sistema.
   </simpara>
  </sect1>

  <sect1 id="security.filesystem">
   <title>Seguridad del sistema de archivos</title>
   <simpara>
PHP est&aacute; sujeto a la seguridad misma de la mayor&iacute;a de
sistemas de servidores en lo que a permisos sobre archivos y
directorios se refiere. Esto le permite controlar cu&aacute;les
archivos en el sistema de archivos pueden ser le&iacute;dos. Debe
tenerse cuidado con aquellos archivos que tengan permisos de lectura
globales, para asegurarse de que su contenido es seguro y no
represente peligro el que pueda ser le&iacute;do por todos los
usuarios con acceso al sistema de archivos.
   </simpara>
   <simpara>
Ya que PHP fue dise&ntilde;ado para permitir acceso al nivel de
usuarios al sistema de archivos, es completamente posible escribir un
script PHP que le permita leer archivos del sistema como /etc/passwd,
modificar sus conexiones tipo ethernet, enviar trabajos de
impresi&oacute;n masivos, etc. Esto tiene algunas implicaciones
obvias, en el sentido en que usted tiene que asegurarse de que los
archivos desde lo que lee y hacia los que escribe datos, sean los
correctos.
   </simpara>
   <simpara>
Considere el siguiente script, en donde un usuario indica que quisiera
eliminar un archivo ubicado en su directorio personal. Este caso asume
que se trata de una situaci&oacute;n en donde se usa normalmente una
interfaz web que se vale de PHP para la gesti&oacute;n de archivos,
as&iacute; que el usuario de Apache tiene permitido eliminar archivos
en los directorios personales de los usuarios.
   </simpara>
   <para>
    <example>
     <title>Un chequeo pobre de variables nos lleva a...</title>
     <programlisting role="php">
<![CDATA[
<?php
// eliminar un archivo del directorio personal del usuario

$nombre_usuario = $_POST['nombre_enviado_por_el_usuario'];
$directorio     = "/home/$nombre_usuario";

$archivo_a_eliminar = "$archivo_de_usuario";

unlink ("$directorio/$archivo_de_usuario");

echo "&iexcl;El archivo $archivo_a_eliminar ha sido eliminado!";
?>
]]>
     </programlisting>
    </example>
Ya que el nombre de usuario es enviado desde un formulario de usuario,
cualquiera puede enviar un nombre de usuario y archivo propiedad de
otra persona, y eliminar archivos. En este caso, usted querr&aacute;
usar otro m&eacute;todo de autenticaci&oacute;n. Considere lo que
sucede si las variables enviadas son "../etc/" y "passwd". El
c&oacute;digo entonces se ejecutar&iacute;a efectivamente como:
    <example>
     <title>... un ataque al sistema de archivos</title>
     <programlisting role="php">
<![CDATA[
<?php
// elimina un archivo de cualquier parte del disco duro al que el
// usuario de PHP tiene acceso. Si PHP tiene acceso de root:

$nombre_usuario = "../etc/";
$directorio     = "/home/../etc/";

$archivo_a_eliminar = "passwd";

unlink ("/home/../etc/passwd");

echo "&iexcl;El archivo /home/../etc/passwd ha sido eliminado!";
?>
]]>
     </programlisting>
    </example>
Hay dos importantes medidas que usted debe tomar para prevenir estas
situaciones.
    <itemizedlist>
     <listitem>
      <simpara>
Otorgarle &uacute;nicamente permisos limitados al usuario web del
binario PHP.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
Chequear todas las variables que son enviadas por usuarios.
      </simpara>
     </listitem>
    </itemizedlist>
Aqu&iacute; hay una versi&oacute;n mejorada del script:
    <example>
     <title>Un chequeo de nombres de archivos m&aacute;s seguro</title>
     <programlisting role="php">
<![CDATA[
<?php
// elimina un archivo de cualquier parte del disco duro al que el
// usuario de PHP tiene acceso.

$nombre_usuario = $_SERVER['REMOTE_USER']; // uso de un mecanismo de
                                           // autenticacion

$directorio = "/home/$nombre_usuario";

$archivo_a_eliminar = basename("$archivo_de_usuario"); // remover rutas
unlink ($directorio/$archivo_a_eliminar);

$fp = fopen("/home/registros/eliminacion.log","+a"); // registrar el proceso

$cadena_de_registro = "$nombre_usuario $directorio $archivo_a_eliminar";

fputs ($fp, $cadena_de_registro);
fclose($fp);

echo "&iexcl;El archivo $archivo_a_eliminar ha sido eliminado!";
?>
]]>
     </programlisting>
    </example>
    Sin embargo, incluso este caso no est&aacute; libre de
    problemas. Si su sistema de autenticaci&oacute;n le ha permitido a
    los usuarios la creaci&oacute;n de sus propios nombres en el
    sistema, y un usuario elige "../etc/", el sistema se encuenrta
    nuevamente expuesto. Por esta raz&oacute;n, puede que uster
    prefiera escribir un chequeo m&aacute;s personalizado:
    <example>
     <title>Chequeo de nombres de archivos aun m&aacute;s seguro</title>
     <programlisting role="php">
<![CDATA[
<?php
$nombre_usuario = $_SERVER['REMOTE_USER']; // uso de un mecanismo de
                                           // autenticacion

$directorio = "/home/$nombre_usuario";

if (!ereg('^[^./][^/]*$', $archivo_de_usuario))
     die('nombre de archivo inv&aacute;lido'); // finalizar,
                                               // no ejecutar el proceso

if (!ereg('^[^./][^/]*$', $nombre_usuario))
     die('nombre de archivo inv&aacute;lido'); // finalizar,
                                               // no ejecutar el proceso

//etc...
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
Dependiendo de su sistema operativo, existe una amplia variedad de
archivos sobre los que usted deber&iacute;a estar atento, incluyendo
las entradas de dispositivos (/dev/ o COM1), archivos de
configuraci&oacute;n (archivos /etc/ y los archivos .ini), areas
conocidas de almacenamiento de datos (/home/, Mis Documentos),
etc. Por esta raz&oacute;n, usualmente es m&aacute;s sencillo crear
una pol&iacute;tica en donde se proh&iacute;ba toda transacci&oacute;n
excepto por aquellas que usted permita expl&iacute;citamente.
   </para>
  </sect1>

  <sect1 id="security.database">
   <title>Seguridad de Bases de Datos</title>

   <simpara>
Hoy en d&iacute;a, las bases de datos son componentes cardinales de
cualquier aplicaci&oacute;n basada en web, permitiendo que los sitios
web provean contenido din&aacute;mico. Debido a que informaci&oacute;n
considerablemente sensible o secreta puede ser almacenada en tales
bases de datos, usted debe considerar seriamente la forma de
protegerlas.
   </simpara>
   <simpara>
Para recuperar o almacenar cualquier informaci&oacute;n necesita
conectarse a la base de datos, enviar una consulta v&aacute;lida,
recoger el resultado y cerrar la conexi&oacute;n. Hoy en d&iacute;a,
el lenguaje de consultas usado com&uacute;nmente en estas
interacciones es el Lenguaje de Consultas Estructurado (SQL por sus
siglas en Ingl&eacute;s). Puede apreciar c&oacute;mo un atacante puede
<link linkend="security.database.sql-injection">intentar acometidas
con una consulta SQL</link>.
   </simpara>
   <simpara>
Como puede apreciar, PHP no puede proteger su base de datos por
s&iacute; solo. Las siguientes secciones est&aacute;n dirigidas a
servir de introducci&oacute;n a los conceptos b&aacute;sicos de
c&oacute;mo acceder y manipular bases de datos desde scripts PHP.
   </simpara>
   <simpara>
Mantenga en mente esta simple regla: protecci&oacute;n en
profundidad. Entre m&aacute;s acciones tome para incrementar la
protecci&oacute;n de su base de datos, menor ser&aacute; la
probabilidad de que un atacante tenga &eacute;xito, y exponga o abuse
de cualquier informaci&oacute;n secreta que estuviera almacenada. Un
buen dise&ntilde;o del esquema de la base de datos y de la
aplicaci&oacute;n basta para lidiar con sus mayores temores.
   </simpara>

   <sect2 id="security.database.design">
    <title>Dise&ntilde;o de Bases de Datos</title>
     <simpara>
El primer paso siempre es crear la base de datos, a menos que desee
usar una existente, creada por alguien m&aacute;s. Cuando una base de
datos es creada, &eacute;sta es asignada a un due&ntilde;o, quien
ejecut&oacute; la sentencia de creaci&oacute;n. Usualmente,
&uacute;nicamente el due&ntilde;o (o un super-usuario) puede hacer
cualquier cosa con los objetos de esa base de datos, y para que otros
usuarios puedan usarla, deben otorgarse privilegios.
     </simpara>
     <simpara>
Las aplicaciones nunca deber&iacute;an conectarse a la base de datos
bajo el usuario correspondiente a su due&ntilde;o, o como un
super-usuario, ya que &eacute;stos usuarios pueden, por ejemplo,
ejecutar cualquier consulta a su antojo, modificando el esquema
(p. ej. eliminando tablas) o borrando su contenido completo.
     </simpara>
     <simpara>
Usted puede crear diferentes usuarios de la base de datos para cada
aspecto de su aplicaci&oacute;n con derechos muy limitados sobre los
objetos de la base de datos. Tan solo deben otorgarse los privilegios
estrictamente necesarios, y evitar que el mismo usuario pueda
interactuar con la base de datos en diferentes casos de uso. Esto
quiere decir que si un intruso gana acceso a su base de datos usando
una de &eacute;stas credenciales, &eacute;l solo puede efectuar tantos
cambios como su aplicaci&oacute;n se lo permita.
     </simpara>
     <simpara>
Es buena idea que no implemente toda la l&oacute;gica del asunto en la
aplicaci&oacute;n web (es decir, en su script); en su lugar,
h&aacute;galo en el esquema de la base de datos usando vistas,
disparadores o reglas. Si el sistema evoluciona, se espera que nuevos
puertos sean abiertos a la aplicaci&oacute;n, y tendr&aacute; que
reimplementar la l&oacute;gica para cada cliente de la base de
datos. Por sobre todo, los disparadores pueden ser usados para
gestionar de forma transparente todos los campos
autom&aacute;ticamente, lo cual con frecuencia provee
informaci&oacute;n &uacute;til cuando se depuren problemas de su
aplicaci&oacute;n, o se realicen rastreos sobre transacciones
particulares.
     </simpara>
   </sect2>

   <sect2 id="security.database.connection">
    <title>Conexi&oacute;n con la Base de Datos</title>
    <simpara>
Puede que desee establecer las conexiones sobre SSL para encriptar las
comunicaciones cliente/servidor, incrementando el nivel de seguridad,
o puede hacer uso de ssh para encriptar la conexi&oacute;n de red
entre los clientes y el servidor de la base de datos. Si cualquiera de
estos recursos es usado, entonces monitorear su tr&aacute;fico y
adquirir informaci&oacute;n de esta manera ser&aacute; un trabajo bien
dif&iacute;cil.
    </simpara>
    <!--simpara>
     If your database server has native SSL support, consider to use <link
     linkend="ref.openssl">OpenSSL functions</link> in communication between
     PHP and database via SSL.
    </simpara-->
   </sect2>

   <sect2 id="security.database.storage">
    <title>Modelo de Almacenamiento Encriptado</title>
    <simpara>
SSL/SSH protege los datos que viajan desde el cliente al servidor,
SSL/SSH no protege los datos persistentes almacenados en la base de
datos. SSL es un protocolo sobre-el-cable.
    </simpara>
    <simpara>
Una vez el atacante adquiere acceso directo a su base de datos
(evitando el paso por el servidor web), los datos cr&iacute;ticos
almacenados pueden estar expuestos o malutilizados, a menos que la
informaci&oacute;n est&eacute; protegida en la base de datos misma. La
encriptaci&oacute;n de datos es una buena forma de mitigar esta
amenaza, pero muy pocas bases de datos ofrecen este tipo de mecanismo
de encriptaci&oacute;n de datos.
    </simpara>
    <simpara>
La forma m&aacute;s sencilla de evitar este problema es crear primero
su propio paquete de encriptaci&oacute;n, y luego utilizarlo desde sus
scripts de PHP. PHP puede ayudarle en este caso con sus varias
extensiones, como <link linkend="ref.mcrypt">Mcrypt</link> y <link
linkend="ref.mhash">Mhash</link>, las cuales cubren una amplia
variedad de algoritmos de encriptaci&oacute;n. El script entonces debe
encriptar los datos a ser almacenados primero, y luego la decripta
cuando la recupera. Vea las referencias para consultar m&aacute;s
ejemplos de c&oacute;mo opera la encriptaci&oacute;n.
    </simpara>
    <simpara>
En el caso de datos realmente escondidos, si su representaci&oacute;n
original no se necesita (es decir, no debe ser desplegada), los
res&uacute;menes criptogr&aacute;ficos pueden llegar a considerarse. El ejemplo
cl&aacute;sico de gesti&oacute;n de res&uacute;menes
criptogr&aacute;ficos es el almacenamiento de secuencias MD5 de una
contrase&ntilde;a en una base de datos, en lugar de la
contrase&ntilde;a misma. Vea tambi&eacute;n <function>crypt</function>
y <function>md5</function>.
    </simpara>
    <example>
     <title>Uso de un campo de contrase&ntilde;as encriptado</title>
     <programlisting role="php">
<![CDATA[
// almacenamiento de resumen criptografico de la contrasenya

$consulta  = sprintf("INSERT INTO usuarios(nombre,contr) VALUES('%s','%s');",
                     addslashes($nombre_usuario), md5($contrasenya));
$resultado = pg_exec($conexion, $consulta);


// consulta de verificacion de la contrasenya enviada

$consulta  = sprintf("SELECT 1 FROM usuarios WHERE nombre='%s' AND contr='%s';",
                     addslashes($nombre_usuario), md5($contrasenya));
$resultado = pg_exec($conexion, $consulta);

if (pg_numrows($resultado) > 0) {
    echo "&iexcl;Bienvenido, $nombre_usuario!";
}
else {
    echo "No pudo autenticarse a $nombre_usuario.";
}
]]>
     </programlisting>
    </example>
   </sect2>

   <sect2 id="security.database.sql-injection">
    <title>Inyecci&oacute;n de SQL</title>
    <simpara>
Muchos desarrolladores web no son conscientes de c&oacute;mo pueden
manipularse las consultas SQL, y asumen que una consulta SQL es un
comando confiable. Esto representa que las consultas SQL pueden burlar
los controles de acceso, y de este modo evitar los chequeos
est&aacute;ndares de autenticaci&oacute;n y autorizaci&oacute;n, y a
veces las consultas SQL pueden incluso permitir acceso a comandos al
nivel del sistema operativo de la m&aacute;quina hu&eacute;sped.
    </simpara>
    <simpara>
La Inyecci&oacute;n Directa de Comandos SQL es una t&eacute;cnica en
la cual un atacante crea o altera comandos SQL existentes para exponer
datos escondidos, o sobrescribir datos cr&iacute;ticos, o incluso
ejecutar comandos del sistema peligrosos en la m&aacute;quina en donde
se encuentra la base de datos. Esto se consigue cuando la
aplicaci&oacute;n toma informaci&oacute;n de entrada del usuario y la
combina con par&aacute;metros est&aacute;ticos para construir una
consulta SQL. Los siguientes ejemplos, desafortunadamente,
est&aacute;n basados en historias reales.
    </simpara>
    <para>
Debido a la falta de validaci&oacute;n de la informaci&oacute;n de
entrada y el establecimiento de conexiones con la base de datos desde
un super-usuario o aquel que puede crear usuarios, el atacante
podr&iacute;a crear un super-usuario en su base de datos.
     <example>
      <title>
Paginaci&oacute;n del conjunto de resultados ... y creaci&oacute;n de
super-usuarios (PostgreSQL y MySQL)
      </title>
      <programlisting role="php">
<![CDATA[
$offset   = argv[0]; // atencion, no se valida la entrada!
$consulta = "SELECT id, nombre FROM productos ORDER BY nombre LIMIT 20 " .
            "OFFSET $offset;";

// con PostgreSQL 
$resultado = pg_exec($conexion, $consulta);

// con MySQL
$resultado = mysql_query($consulta);
]]>
      </programlisting>
     </example>
Los usuarios normales pulsan sobre los enlaces 'siguiente' y
'anterior', en donde el desplazamiento (<varname>$offset</varname>) es
un n&uacute;mero decimal. Sin embargo, alguien puede intentar un
ataque a&ntilde;adiendo una forma codificada
(<function>urlencode</function>) de lo siguiente en la URL
      <informalexample>
       <programlisting>
<![CDATA[
// en el caso de PostgreSQL
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// en el caso de MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;
]]>
       </programlisting>
      </informalexample>
Si esto ocurriera, entonces el script le presentar&iacute;a un acceso
de superusuario al atacante. Note que <literal>0;</literal> es usado
para ofrecer un desplazamiento v&aacute;lido a la consulta original y
finalizarla.
    </para>
    <note>
     <para>
Es una t&eacute;cnica com&uacute;n obligar al analizador
sint&aacute;ctico de SQL a que ignore el resto de la consulta escrita
por el desarrollador mediante
<literal>--</literal>, el cual es el signo de comentarios en SQL.
     </para>
    </note>
    <para>
Una forma viable de adquirir contrase&ntilde;as es jugar con las
p&aacute;ginas de resultados de b&uacute;squedas. Todo lo que necesita
el atacante es probar si existe alguna variable enviada por el usuario
que sea usada en una sentencia SQL sin el tratamiento adecuado. Estos
filtros pueden ubicarse por lo general previos a
cl&aacute;usulas <literal>WHERE, ORDER BY, LIMIT</literal>
y <literal>OFFSET</literal> en sentencias
<literal>SELECT</literal> para personalizar la instrucci&oacute;n Si su base
de datos soporta la construcci&oacute;n <literal>UNION</literal>, el
atacante puede intentar a&ntilde;adir una consulta completa a la consulta
original para generar una lista de contrase&ntilde;as desde una tabla
cualquiera. El uso de campos encriptados de contrase&ntilde;as es
altamente recomendable.
     <example>
      <title>
       Listado de art&iacute;culos ... y algunas contrase&ntilde;as
       (en cualquier base de datos)
      </title>
      <programlisting role="php">
<![CDATA[
$consulta  = "SELECT id, nombre, insertado, tam FROM productos
                  WHERE tam = '$tam'
                  ORDER BY $orden LIMIT $limite, $offset;";
$resultado = odbc_exec($conexion, $consulta);
]]>
      </programlisting>
     </example>
La parte est&aacute;tica de la consulta puede combinarse con otra
sentencia <literal>SELECT</literal> la cual revela todas las
contrase&ntilde;as:
     <informalexample>
      <programlisting>
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
Si esta consulta (la cual juega con <literal>'</literal> y
<literal>--</literal>) fuera asignada a una de las variables usadas
en <varname>$consulta</varname>, la bestia de la consulta habr&aacute;
despertado.
    </para>
    <para>
Las sentencias UPDATE en SQL tambi&eacute;n son objetivos de ataques
en su base de datos. Estas consultas tambi&eacute;n se encuentran
amenazadas por un posible acotamiento y adici&oacute;n de una consulta
completamente nueva. Pero en este caso el atacante puede ama&ntilde;ar
la informaci&oacute;n de una
cl&aacute;usula <literal>SET</literal>. En este caso se requiere
contar con cierta informaci&oacute;n sobre el esquema de la base de
datos para poder manipular la consulta satisfactoriamente. Esta
informaci&oacute;n puede ser adquirida mediante el estudio de los
nombres de variables de los formularios, o simplemente por fuerza
bruta. No existen demasiadas convenciones para nombrar campos de
contrase&ntilde;as o nombres de usuario.
     <example>
     <title>
De restablecer una contrase&ntilde;a ... a adquirir m&aacute;s
privilegios (con cualquier servidor de base de datos)
     </title>
      <programlisting role="php">
<![CDATA[
$consulta = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
]]>
      </programlisting>
     </example>
Pero un usuario malicioso env&iacute;a el valor <literal>' or uid
like'%admin%'; --</literal> como <varname>$uid</varname> para cambiar
la contrase&ntilde;a del administrador, o simplemente establece
<varname>$pwd</varname> a <literal>"hehehe', admin='yes', trusted=100
"</literal> (con un espacio al inicio) para adquirir m&aacute;s
privilegios. En tal caso, la consulta ser&iacute;a manipulada:
     <informalexample>
      <programlisting role="php">
<![CDATA[
// $uid == ' or uid like'%admin%'; --
$consulta = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$consulta = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
Un horrible ejemplo de c&oacute;mo puede accederse a comandos del
nivel del sistema operativo en algunas m&aacute;quinas anfitrionas de
bases de datos.
     <example>
     <title>Ataque al sistema operativo de la m&aacute;quina anfitriona de
     la base de datos (MSSQL Server)</title>
      <programlisting role="php">
<![CDATA[
$consulta  = "SELECT * FROM productos WHERE id LIKE '%$prod%'";
$resultado = mssql_query($consulta);
]]>
      </programlisting>
     </example>
Si el atacante env&iacute;a el valor <literal>a%' exec
master..xp_cmdshell 'net user test testpass /ADD' --</literal> a
<varname>$prod</varname>, entones la <varname>$consulta</varname>
ser&aacute;:
     <informalexample>
      <programlisting role="php">
<![CDATA[
$consulta  = "SELECT * FROM productos
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$resultado = mssql_query($consulta);
]]>
      </programlisting>
     </informalexample>
MSSQL Server ejecuta sentencias SQL en el lote, incluyendo un comando
para agregar un nuevo usuario a la base de datos de cuentas
locales. Si esta aplicaci&oacute;n estuviera corriendo como
<literal>sa</literal> y el servicio MSSQLSERVER est&aacute; corriendo
con los privilegios suficientes, el atacante tendr&iacute;a ahora una
cuenta con la que puede acceder a esta m&aacute;quina.
    </para>
    <note>
     <para>
Algunos de los ejemplos anteriores est&aacute;n atados a un servidor
de base de datos espec&iacute;fico. Esto no quiere decir que un ataque
similar sea imposible con otros productos. Su base de datos puede ser
tanto o m&aacute;s vulnerable en otras formas distintas.
     </para>
    </note>

    <sect3 id="security.database.avoiding">
     <title>T&eacute;cnicas de protecci&oacute;n</title>
     <simpara>
Usted puede argumentar con justa raz&oacute;n que el atacante debe
poseer cierta cantidad de informaci&oacute;n sobre el esquema de la
base de datos en la mayor&iacute;a de ejemplos que hemos visto. Tiene
raz&oacute;n, pero usted nunca sabe cu&aacute;ndo y c&oacute;mo puede
filtrarse esta informaci&oacute;n, y si ocurre, su base de datos
estar&aacute; expuesta. Si est&aacute; usando un paquete de
gesti&oacute;n de bases de datos de c&oacute;digo abierto, o cuyo
c&oacute;digo fuente est&aacute; disponible p&uacute;blicamente, el
cual puede pertenecer a alg&uacute;n sistema de administraci&oacute;n
de contenido o foro, los intrusos pueden producir f&aacute;cilmente
una copia de un trozo de su c&oacute;digo. Tambi&eacute;n puede ser un
riesgo de seguridad si es un segmento de c&oacute;digo pobremente
dise&ntilde;ado.
     </simpara>
     <simpara>
Estos ataques se basan principalmente en la explotaci&oacute;n del
c&oacute;digo que no ha sido escrito pensando en la seguridad. Nunca
conf&iacute;e en ning&uacute;n tipo de informaci&oacute;n de entrada,
especialmente si proviene del lado del cliente, aun si lo hace desde
una caja de selecci&oacute;n, un campo de entrada hidden o una
cookie. El primer ejemplo le muestra que una consulta as&iacute; de
descuidada puede causar desastres.
     </simpara>

     <itemizedlist>
      <listitem>
       <simpara>
Nunca se conecte a la base de datos como un super-usuario o como el
due&ntilde;o de la base de datos. Use siempre usuarios personalizados
con privilegios muy limitados.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
Revise si la entrada recibida es del tipo apropiado. PHP posee un
amplio rango de funciones de validaci&oacute;n de datos, desde los
m&aacute;s simples encontrados en <link
linkend="ref.variables">Funciones sobre variables</link> y en <link
linkend="ref.ctype">Funciones de tipo de caracter</link>
(p. ej. <function>is_numeric</function>,
<function>ctype_digit</function> respectivamente) hasta el soporte
para <link linkend="ref.pcre">Expresiones Regulares compatibles con
Perl</link>.
       </simpara>
      </listitem>
      <listitem>
       <para>
Si la aplicaci&oacute;n espera alguna entrada num&eacute;rica, considere
verificar la informaci&oacute;n con <function>is_numeric</function>, o
modifique silenciosamente su tipo usando <function>settype</function>,
o utilice su representaci&oacute;n num&eacute;rica, dada por
<function>sprintf</function>.
        <example>
         <title>
Una forma m&aacute;s segura de generar una consulta para paginado
         </title>
         <programlisting role="php">
<![CDATA[
settype($offset, 'integer');
$consulta = "SELECT id, nombre FROM productos ORDER BY nombre " .
            "LIMIT 20 OFFSET $offset;";

// note el simbolo %d en la cadena de formato, usar %s no tendria sentido
$consulta = sprintf("SELECT id, nombre FROM productos ORDER BY nombre" .
                    "LIMIT 20 OFFSET %d;", $offset);
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
Ubique cada entrada del usuario no-num&eacute;rica que sea pasada a la
base de datos entre comillas con <function>addslashes</function> o
<function>addcslashes</function>. Vea <link
linkend="security.database.storage">el primer ejemplo</link>. Como se
ve all&iacute;, las comillas colocadas en la parte est&aacute;tica de
la consulta no son suficientes, y pueden ser manipuladas
f&aacute;cilmente.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
No imprima ninguna informaci&oacute;n espec&iacute;fica sobre la base
de datos, especialmente sobre su esquema, ya sea por razones justas o
por equivocaciones. Vea tambi&eacute;n <link
linkend="security.errors">Reporte de Errores</link> y <link
linkend="ref.errorfunc">Gesti&oacute;n de Errores y Funciones de
Registro</link>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
Puede usar procedimientos almacenados y cursores previamente definidos
para abstraer el acceso a las bases de datos, de modo que los usuarios
no tengan acceso directo a las tablas o vistas, aunque esta
soluci&oacute;n tiene otros impactos.
       </simpara>
      </listitem>
     </itemizedlist>

     <simpara>
Adem&aacute;s de estas acciones, usted puede beneficiarse del registro
expl&iacute;cito de las consultas realizadas, ya sea desde su script o
por la base de datos misma, si &eacute;sta lo soporta. Por supuesto,
el registro de acciones no puede prevenir cualquier intento peligroso,
pero puede ser &uacute;til para rastrear cu&aacute;les aplicaciones
han sido usadas para violar la seguridad. El registro en s&iacute; no
es &uacute;til; lo es la informaci&oacute;n que contiene. Entre
m&aacute;s detalles se tengan, por lo general es mejor.
     </simpara>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="security.errors">
   <title>Reporte de Errores</title>
   <para>
Hablando de la seguridad en PHP, hay dos caras en lo que se concierne
al reporte de errores. Una es ben&eacute;fica al incremento de la
seguridad, la otra va en direcci&oacute;n de su detrimento.
   </para>
   <para>
Una t&aacute;ctica de ataque t&iacute;pica involucra la
acumulaci&oacute;n de un perfil de datos del sistema
aliment&aacute;ndolo con datos inapropiados, y luego chequear los
tipos de errores que son devueltos, y sus contextos. Esto permite que
el cracker del sistema pueda adquirir informaci&oacute;n del
servidor, para as&iacute; determinar posibles debilidades. Por
ejemplo, si un atacante ha recogido informaci&oacute;n sobre una
p&aacute;gina creada a partir de los datos de un formulario, &eacute;l
podr&iacute;a intentar sobrescribir las variables, o modificarlas:
    <example>
     <title>Ataque a Variables con una p&aacute;gina HTML personalizada</title>
     <programlisting role="php">
<![CDATA[
<form method="POST" action="destino_del_ataque?username=badfoo&password=badfoo">
<input type="hidden" name="username" value="badfoo">
<input type="hidden" name="password" value="badfoo">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
     Los errores de PHP que son devueltos normalmente pueden ser
     bastante &uacute;tiles para un desarrollador que est&eacute;
     tratando de depurar un script, indicando cosas como la
     funci&oacute;n o archivo que fall&oacute;, el archivo PHP y el
     n&uacute;mero de l&iacute;nea en donde ocurren los fallos. Toda
     esta es informaci&oacute;n de la que puede sacarse provecho. No
     es extra&ntilde;o que un desarrollador php
     use <function>show_source</function>,
     <function>highlight_string</function>, o
     <function>highlight_file</function> como medida de
     depuraci&oacute;n, pero en un sitio en producci&oacute;n, esta
     acci&oacute;n puede exponer variables ocultas, sintaxis sin
     chequear, y otra informaci&oacute;n peligrosa. Algo especialmente
     peligroso es ejecutar c&oacute;digo que proviene de fuentes bien
     conocidas con gestores de depuraci&oacute;n incorporados, o que
     usan t&eacute;cnicas de depuraci&oacute;n comunes. Si el atacante
     puede determinar qu&eacute; t&eacute;cnica general est&aacute;
     usando, puede intentar un ataque de fuerza bruta sobre
     una p&aacute;gina, enviando varias cadenas comunes de
     depuraci&oacute;n:
    <example>
     <title>Explotaci&oacute;n de variables comunes de depuraci&oacute;n</title>
     <programlisting role="php">
<![CDATA[
<form method="POST" action="destino_del_ataque?errors=Y&amp;showerrors=1&amp;debug=1">
<input type="hidden" name="errors" value="Y">
<input type="hidden" name="showerrors" value="1">
<input type="hidden" name="debug" value="1">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
Independientemente del m&eacute;todo de gesti&oacute;n de errores, la
capacidad de conseguir que un sistema revele sus posibles estados de
error representa un camino para darle informaci&oacute;n al atacante.
   </para>
   <para>
Por ejemplo, el estilo mismo de un error de PHP gen&eacute;rico indica
que el sistema est&aacute; ejecutando PHP. Si el atacante estuviera
viendo una p&aacute;gina .html, y quisiera consultar qu&eacute;
est&aacute; siendo usado para la generaci&oacute;n de ella por
detr&aacute;s (en busca de debilidades conocidas en el sistema),
podr&iacute;a determinar que el sistema fue creado usando PHP
aliment&aacute;ndolo con informaci&oacute;n equivocada.
   </para>
   <para>
Un error de funci&oacute;n puede indicar si el sistema est&aacute;
ejecutando un tipo particular de motor de base de datos, o dar pistas
sobre c&oacute;mo fue programada o dise&ntilde;ada una p&aacute;gina
web. Esto facilita posteriores investigaciones en determinados puertos
abiertos de bases de datos, o en busca de fallos espec&iacute;ficos o
debilidades en una p&aacute;gina web. Al entregar diferentes trozos de
datos inv&aacute;lidos al sistema, por ejemplo, un atacante puede
determinar el orden de autenticaci&oacute;n en un script, (a partir de
los n&uacute;meros de l&iacute;nea de los errores) as&iacute; como
averiguar sobre vulnerabilidades que pueden aprovecharse en diferentes
puntos del script.
   </para>
   <para>
Un error del sistema de archivos o en general de PHP puede indicar
qu&eacute; permisos tiene el servidor web, as&iacute; como la
estructura y organizaci&oacute;n de los archivos en el servidor
web. Algn c&oacute;digo de gesti&oacute;n de errores escrito por el
desarrollador puede agravar este problema, llevando a la f&aacute;cil
explotaci&oacute;n de informaci&oacute;n hasta entonces "escondida".
   </para>
   <para>
Existen tres soluciones principales a este problema. La primera es
revisar cuidadosamente todas las funciones, y tratar de compensar por
la mayor&iacute;a de errores encontrados. La segunda es deshabilitar
el reporte de errores completamente del c&oacute;digo que est&aacute;
siendo ejecutado. La tercera es usar las funciones de gesti&oacute;n
de errores personalizables de PHP para crear su propio gestor de
errores. Dependiendo de su pol&iacute;tica de seguridad, puede
encontrar que todas ellas pueden ser aplicables a su
situaci&oacute;n.
   </para>
   <para>
Una forma de detectar este problema por adelantado es hacer uso del
reporte de errores propio de PHP
(<function>error_reporting</function>), para ayudarle a asegurar su
c&oacute;digo y encontrar uso de variables que pueda ser peligroso. Al
probar su c&oacute;digo, previamente a su entrega final, con E_ALL,
puede encontrar r&aacute;pidamente &aacute;reas en donde sus variables
pueden estar abiertas a la manipulaci&oacute;n y explotaci&oacute;n en
distintas formas. Una vez est&eacute; listo para liberar su
c&oacute;digo, usando E_NONE puede aislarlo de posibles
intentos por adquirir informaci&oacute;n &uacute;til para un atacante.
    <example>
     <title>Detecci&oacute;n de variables peligrosas con E_ALL</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($nombre_usuario) {  // Variable no inicializada o chequeada antes de su uso
    $login_correcto = 1;
}
if ($login_correcto == 1) { // Si la condicion anterior falla, esta variable
                            // no se encuentra inicializada ni validada
                            // antes de su uso

    readfile ("/informacion/altamente/confidencial/index.html");
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="security.registerglobals">
   <title>Uso de Register Globals</title>
   <para>
Quiz&aacute;s el cambio m&aacute;s controversial en la historia de PHP
se ha dado cuando la directiva <link
linkend="ini.register-globals">register_globals</link> pas&oacute; de
tener como valor por defecto ON al valor OFF en PHP <ulink
url="&url.php.release4.2.0;">4.2.0</ulink>. La dependencia sobre esta
directiva era bastante com&uacute;n y muchas personas nisiquiera
estaban enteradas de que exist&iacute;a y asum&iacute;an que ese era
el modo en que PHP trabajaba. Esta p&aacute;gina explicar&aacute;
c&oacute;mo puede llegar a escribirse c&oacute;digo inseguro con esta
directiva pero tenga en mente que no es la directiva misma la que es
insegura sino el uso inapropiado de ella.
   </para>
   <para>
Cuando se encuentra activa, la directiva register_globals
inyectar&aacute; (o envenenar&aacute;) sus scripts con todo tipo de
variables, como variables de peticiones provenientes de formularios
html. Esto junto con el hecho de que PHP no requiere la
inicializaci&oacute;n de variables significa que es muy f&aacute;cil
escribir c&oacute;digo inseguro. Fue una decisi&oacute;n
dif&iacute;cil, pero la comunidad de PHP decidi&oacute; desahibilar
esta directiva por defecto. Cuando est&aacute; habilitada, las
personas usan variables sin saber con seguridad de d&oacute;nde
provienen y solo queda asumir. Las variables internas que son
definidas en el script mismo son mezcladas con los datos enviados por
los usuarios y al deshabilitar register_globals se modifica este
comportamiento. Demostremos este caso con un ejemplo del uso
incorrecto de register_globals:
   </para>
   <para>
    <example>
     <title>Ejemplo del uso inapropiado de register_globals = on</title>
     <programlisting role="php">
<![CDATA[
<?php
// definir $autorizado = true solo si el usuario ha sido autenticado

if (usurio_autenticado()) {
    $autorizado = true;
}

// Ya que no inicializamos $autorizado como false, esta podria estar
// definida a traves de register_globals, como en el caso de GET
// auth.php?autorizado=1

// De modo que cualquier persona podria verse como autenticada!

if ($autorizado) {
    include "/datos/muy/importantes.php";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
Cuando register_globals = on, nuestra l&oacute;gica anterior
podr&iacute;a verse comprometida. Cuando la directiva est&aacute;
deshabilitada, <varname>$autorizado</varname> no puede definirse a
trav&eacute;s de peticiones, as&iacute; que no habr&aacute;
ning&uacute;n problema, aunque es cierto que siempre es una buena
pr&aacute;ctica de programaci&oacute;n inicializar las variables
primero. Por ejemplo, en nuestro ejemplo anterior pudimos haber
realizado primero algo como <literal>$authorized =
false</literal>. Hacer esto representa que el c&oacute;digo anterior
podr&iacute;a funcionar con register_globals establecido a on u off ya
que los usuarios no ser&iacute;an autorizados por defecto.
   </para>
   <para>
Otro ejemplo es aquel de las <link
linkend="ref.session">sesiones</link>. Cuando register_globals = on,
podr&iacute;amos usar
tambi&eacute;n <varname>$nombre_usuario</varname> en nuestro siguiente
ejemplo, pero nuevamente usted debe notar que
<varname>$nombre_usuario</varname> puede provenir de otros medios,
como GET (a trav&eacute;s de la URL).
   </para>
   <para>
    <example>
     <title>Ejemplo del uso de sesiones con register_globals on u off</title>
     <programlisting role="php">
<![CDATA[
<?php
// No sabriamos de donde proviene $nombre_usuario, pero sabemos que
// $_SESSION es para datos de sesion

if (isset($_SESSION['nombre_usuario'])) {
    
    echo "Hola <b>{$_SESSION['nombre_usuario']}</b>";

} else {
    
    echo "Hola <b>Invitado</b><br />";
    echo "&iquest;Quisiera iniciar su sesi&oacute;n?";

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
Incluso es posible tomar medidas preventivas para advertir cuando se
intente falsificar la informaci&oacute;n. Si usted sabe previamente
con exactitud el lugar de donde deber&iacute;a provenir una variable,
usted puede chequear si los datos enviados provienen de una fuente
inadecuada. Aunque esto no garantiza que la informaci&oacute;n no haya
sido falsificada, esto requiere que un atacante adivine el medio
apropiado para falsificar la informaci&oacute;n. Si no le importa de
d&oacute;nde proviene la informaci&oacute;n, puede
usar <varname>$_REQUEST</varname> ya que all&iacute; se incluye una
mezcla de variables que provienen de datos GET, POST y
COOKIE. Consulte tambi&eacute;n la secci&oacute;n del manual sobre el
uso de <link linkend="language.variables.external">variables desde
fuera de PHP</link>.
   </para>
   <para>
    <example>
     <title>Detecci&oacute;n de envenenamiento simple de variables</title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['COOKIE_MAGICA'])) {
    
    // COOKIE_MAGICA proviene de una cookie.
    // Asegurese de validar los datos de la cookie!

} elseif (isset($_GET['COOKIE_MAGICA']) || isset($_POST['COOKIE_MAGICA'])) {
   
   mail("admin@ejemplo.com", "Posible intento de intromision",
        $_SERVER['REMOTE_ADDR']);
   echo "Violaci&oacute;n de seguridad, el administrador ha sido alertado.";
   exit;

} else {
   
   // COOKIE_MAGICA no fue definida en este REQUEST

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
Por supuesto, deshabilitar register_globals no quiere decir que su
c&oacute;digo vaya a ser seguro. Por cada trozo de datos que sea
enviado por el usuario, &eacute;ste debe ser chequeado en otras
formas. &iexcl;Siempre valide los datos de los usuarios e inicialice
sus variables! Para chequear por variables no inicializadas, usted
puede usar
<function>error_reporting</function> para mostrar errores del nivel
<constant>E_NOTICE</constant>.
   </para>
   
   &note.superglobals;

  </sect1>


  <sect1 id="security.variables">
   <title>Datos Enviados por el Usuario</title>
   <para>
Las mayores debilidades de muchos programas PHP no son inherentes al
lenguaje mismo, sino simplemente un problema generado cuando se escribe
c&oacute;digo sin pensar en la seguridad. Por esta raz&oacute;n, usted
deber&iacute;a tomarse siempre el tiempo para considerar las
implicaciones de cada pedazo de c&oacute;digo, para averiguar el
posible peligro involucrado cuando una variable inesperada es enviada.
    <example>
     <title>Uso Peligroso de Variables</title>
     <programlisting role="php">
<![CDATA[
<?php
// eliminar un archivo del directorio personal del usuario .. o
// quizas de alguien mas?

unlink ($variable_malvada);

// Imprimir el registro del acceso... o quizas una entrada de /etc/passwd?
fputs ($desc_archivo, $variable_malvada);

// Ejecutar algo trivial.. o rm -rf *?
system ($variable_malvada);
exec ($variable_malvada);

?>
]]>
     </programlisting>
    </example>
Usted deber&iacute;a examinar siempre, y cuidadosamente su
c&oacute;digo para asegurarse de que cualquier variable siendo enviada
desde un navegador web sea chequeada apropiadamente, y preguntarse a
s&iacute; mismo:
    <itemizedlist>
     <listitem>
      <simpara>

       &iquest;Este script afectar&aacute; &uacute;nicamente los archivos que se pretende?

      </simpara>
     </listitem>
     <listitem>
      <simpara>

&iquest;Puede tomarse acci&oacute;n sobre datos inusuales o indeseados?

      </simpara>
     </listitem>
     <listitem>
     <simpara>

&iquest;Puede ser usado este script en formas malintencionadas?

      </simpara>
     </listitem>
     <listitem>
      <simpara>

&iquest;Puede ser usado en conjunto con otros scripts en forma negativa?

      </simpara>
     </listitem>
     <listitem>
      <simpara>

&iquest;Ser&aacute;n adecuadamente registradas las transacciones?

      </simpara>
     </listitem>
    </itemizedlist>
Al preguntarse adecuadamente estas preguntas mientras escribe su
script, en lugar de hacerlo posteriormente, usted previene una
desafortunada re-implementaci&oacute;n del programa cuando desee
incrementar el nivel de seguridad. Al comenzar con esta mentalidad, no
garantizar&aacute; la seguridad de su sistema, pero puede ayudar a
mejorarla.
   </para>
   <para>
Puede que tambi&eacute;n desee considerar la deshabilitaci&oacute;n de
register_globals, magic_quotes, u otros par&aacute;metros convenientes
que pueden causar confusi&oacute;n sobre la validez, fuente o valor de
una determinada variable. Trabajar con PHP en modo
error_reporting(E_ALL) tambi&eacute;n puede ayudarle a advertir
variables que est&aacute;n siendo usadas antes de ser chequeadas o
inicializadas (de modo que puede prevenir que datos inusuales
produzcan operaciones inadvertidas).
   </para>
  </sect1>

  <sect1 id="security.hiding">
   <title>Ocultando PHP</title>
   <para>
En general, la seguridad por oscuridad es una de las formas m&aacute;s
d&eacute;biles de seguridad. Pero, en algunos casos, cada
peque&ntilde;o elemento extra de seguridad es deseable.
   </para>
   <para>
Unas cuantas t&eacute;cnicas simples pueden ayudarle a esconder PHP,
posiblemente retrasando a un atacante que est&eacute; intentando
descubrir debilidades en su sistema. Al establecer expose_php = off en
su archivo &php.ini;, usted reduce la cantidad de informaci&oacute;n
disponible a posibles atacantes.
   </para>
   <para>
Otra t&aacute;ctica consiste en configurar los servidores web como
apache para que procesen diferentes tipos de archivos como scripts de
PHP, ya sea con una directiva &htaccess;, o en el archivo de
configuraci&oacute;n de apache mismo. En ese caso puede usar
extensiones de archivo que produzcan confusi&oacute;n:
    <example>
     <title>Ocultando PHP como otro lenguaje</title>
     <programlisting role="apache-conf">
<![CDATA[
# Hacer que el codigo PHP parezca como otro tipo de codigo
AddType application/x-httpd-php .asp .py .pl
]]>
     </programlisting>
    </example>

U ocultarlo completamente:

    <example>
     <title>Uso de tipos desconocidos como extensiones para
     PHP</title>

     <programlisting role="apache-conf">
<![CDATA[
# Hacer que el codigo PHP parezca como de tipos desconocidos
AddType application/x-httpd-php .bop .foo .133t
]]>
     </programlisting>
    </example>
O esc&oacute;ndalo como c&oacute;digo html, lo que tiene un
peque&ntilde;o impacto de rendimiento ya que todos los documentos html
ser&aacute;n procesados por el motor de PHP:
    <example>
     <title>Uso de tipos html para extensiones PHP</title>
     <programlisting role="apache-conf">
<![CDATA[
# Hacer que todo el codigo PHP luzca como html
AddType application/x-httpd-php .htm .html
]]>
     </programlisting>
    </example>
Para que esto funcione de manera efectiva, usted debe renombrar sus
archivos PHP con las extensiones anteriores. Aunque es una forma de
seguridad por oscuridad, representa una medida preventiva con pocas
incomodidades.
   </para>
  </sect1>

  <sect1 id="security.current">
   <title>Mantenerse al D&iacute;a</title>
   <simpara>
PHP, como cualquier otro sistema de tama&ntilde;o considerable,
est&aacute; bajo constante escrutinio y remodelaci&oacute;n. Cada
nueva versi&oacute;n incluye con frecuencia cambios mayores y menores
para mejorar y reparar fallos de seguridad, problemas de
configuraci&oacute;n, y otros asuntos que puedan afectar la seguridad
y estabilidad global de su sistema.
   </simpara>
   <simpara>
Como cualquier lenguaje y programa de scripting del nivel del sistema,
el mejor enfoque es el de actualizar con frecuencia, y mantenerse
alerta sobre las &uacute;ltimas versiones y sus cambios.
   </simpara>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
