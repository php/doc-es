<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 297028 $ -->
<!-- EN-Revision: 96c9d88bad9a7d7d44bfb7f26c226df7ee9ddf26 Maintainer: jesusdiez Status: working -->
<!-- Reviewed: no -->
<!-- splitted from ./index.xml, last change in rev 1.66 -->
  <chapter xml:id="security.errors" xmlns="http://docbook.org/ns/docbook">
   <title>Informe de Errores</title>
   <para>
    Hablando de la seguridad de PHP, el informe de errores tiene dos caras, 
    una de las cuales es beneficiosa para incrementar la seguridad y la otra
    es dañina. 
   </para>
   <para>
    Una estrategia de ataque estándar implica un análisis del sistema
    basado en intentar introducir datos inapropiados y revisar los tipos
    y contextos de los errores devueltos. Esto permite al cracker obtener
    información acerca del servidor y determinar así posibles debilidades.
    Por ejemplo, si un atacante ha recogido información de una página
    basada en el envío previo de un formulario, puede intentar reemplazar
    variables o bien modificarlas:   
    <example>
     <title>Atacando Variables con una página HTML específica</title>
     <programlisting role="html">
<![CDATA[
<form method="post" action="objetivodelataque?username=badfoo&amp;password=badfoo">
<input type="hidden" name="username" value="badfoo" />
<input type="hidden" name="password" value="badfoo" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Los errores de PHP que se devuelven normalmente pueden ser de mucha
    ayuda para un desarrollador que intente depurar un script, indicándo
    información como la función o archivo que falló, así como el archivo
    PHP y la linea de código en la que ocurrió el error. Toda esta es 
    información que puede ser explotada. El uso de funciones como   
    <function>show_source</function>,
    <function>highlight_string</function>, o
    <function>highlight_file</function> no es inusual para desarrolladores 
    de php como método de depuración, pero su uso en un sitio web en producción
    puede exponer variables ocultas, sintaxis sin comprobar y otra información
    peligrosa. Es especialmente peligroso ejecutar código procedente de 
    sitios populares y con métodos de activación de la depuración conocidos, 
    o bien utilizar técnicas de depuración demasiado comunes.
    Si un atacante puede determinar la técnica general que utiliza una página 
    puede intentar atacarla mediante fuerza bruta, enviando valores típicos 
    de activación de la depuración:
    <example>
     <title>Explotando variables típicas de depuración</title>
     <programlisting role="html">
<![CDATA[
<form method="post" action="objetivodelataque?errors=Y&amp;showerrors=1&amp;debug=1">
<input type="hidden" name="errors" value="Y" />
<input type="hidden" name="showerrors" value="1" />
<input type="hidden" name="debug" value="1" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Independientemente del método de control de errores, la capacidad de conocer 
    los errores de un sistema nos lleva a proporcionar al atacante más
    información
   </para>
   <para>
    Por ejemplo, el simple estilo de un error PHP genérico indica que el
    sistema está ejecutando PHP. Si el atacante estaba mirando una página .html e
    intentaba comprobar el back-end (para encontrar en el sistema debilidades conocidas),
    con tan solo introducir datos erróneos podría ser capaz de determinar 
    que ese sistema esta basado en PHP.
   </para>
   <para>
    Un error de una función puede indicar que un sistema está ejecutando
    un motor de bases de datos particular, o dar pistas acerca de cómo
    está programada o diseñada una web. Esto permite una investigación más
    concienzuda sobre puertos de bases de datos abiertos, o en buscar fallos 
    o debilidades específicas de una web. Proporcionando distintas "piezas" de 
    datos inválidos un atacante puede, por ejemplo, determinar el orden de 
    autenticación en un script (basándose en las líneas de error) así como probar
    "exploits" que pueden ser ejecutados en diferentes zonas del script.   
   </para>
   <para>
    A filesystem or general PHP error can indicate what permissions
    the web server has, as well as the structure and organization of
    files on the web server. Developer written error code can aggravate
    this problem, leading to easy exploitation of formerly "hidden"
    information.
   </para>
   <para>
    There are three major solutions to this issue. The first is to
    scrutinize all functions, and attempt to compensate for the bulk
    of the errors. The second is to disable error reporting entirely
    on the running code. The third is to use PHP's custom error
    handling functions to create your own error handler. Depending
    on your security policy, you may find all three to be applicable
    to your situation.
   </para>
   <para>
    One way of catching this issue ahead of time is to make use of
    PHP's own <function>error_reporting</function>, to help you
    secure your code and find variable usage that may be dangerous.
    By testing your code, prior to deployment, with <constant>E_ALL</constant>,
    you can quickly find areas where your variables may be open to poisoning
    or modification in other ways. Once you are ready for deployment,
    you should either disable error reporting completely by setting
    <function>error_reporting</function> to 0, or turn off the error
    display using the &php.ini; option <literal>display_errors</literal>,
    to insulate your code from probing. If you choose to do the latter,
    you should also define the path to your log file using the
    <literal>error_log</literal> ini directive, and turn
    <literal>log_errors</literal> on.
    <example>
     <title>Finding dangerous variables with E_ALL</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($usuario) {  // No se ha inicializado ni comprobado antes de usarse
    $permitir_acceso = 1;
}
if ($permitir_acceso == 1) { // Si la comprobación anterior falla, no se ha inicializado ni comprobado antes de usarse
    readfile ("/datos/muy/importantes/index.html");
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
