 <reference id="ref.url">
  <title>Funciones URL</title>
  <titleabbrev>URLs</titleabbrev>

  <refentry id="function.base64-decode">
   <refnamediv>
    <refname>base64_decode</refname>
    <refpurpose>decodifica datos cifrados con MIME base64</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>string <function>base64_decode</function></funcdef>
     <paramdef>string <parameter>datos_cifrados</parameter></paramdef>
    </funcsynopsis>
    <para>
     <function>base64_decode</function> decodifica
     <parameter>datos_cifrados</parameter> y devuelve los datos
     originales. Los datos devueltos pueden ser binarios.</para>

    <para>
     Vea también:
     <function>base64_encode</function>,
     RFC-2045 sección 6.8.</para>

   </refsect1>
  </refentry>

  <refentry id="function.base64-encode">
   <refnamediv>
    <refname>base64_encode</refname>
    <refpurpose>Codifica datos en MIME base64</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>string <function>base64_encode</function></funcdef>
     <paramdef>string <parameter>datos</parameter></paramdef>
    </funcsynopsis>
    <para>
     <function>base64_encode</function> devuelve
     <parameter>datos</parameter> cifrados en base64. Esta codificación
     está pensada para que los datos binarios sobrevivan al transporte
     a través de capas que no son de 8 bits, como por ejemplo los cuerpos 
     de los mensajes de correo.</para>

    <para>
     Los datos codificados con Base64 ocupan aproximadamente un 33% más
     de espacio que los datos originales.</para>

    <para>
     Vea también:
     <function>base64_decode</function>,
     <function>chunk_split</function>,
     RFC-2045 sección 6.8.</para>

   </refsect1>
  </refentry>

  <refentry id="function.parse-url">
   <refnamediv>
    <refname>parse_url</refname>
    <refpurpose>Analiza una URL y devuelve sus componentes</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>array <function>parse_url</function></funcdef>
     <paramdef>string <parameter>url</parameter></paramdef>
    </funcsynopsis>
    <para>
     Esta función devuelve una matriz que apunta a alguno de los
     componentes de la URL que estén presentes. Esto incluye el    
     "esquema", "host", "puerto", "usuario", "pass", "path", 
     "consulta", y "fragmento".</para>
   </refsect1>
  </refentry>


  <refentry id="function.urldecode">
   <refnamediv>
    <refname>urldecode</refname>
    <refpurpose>decodifica URL-cifradas en una cadena de texto</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>string <function>urldecode</function></funcdef>
     <paramdef>string <parameter>cadena</parameter></paramdef>
    </funcsynopsis>
    <para>
     Decodifica cualquier <literal>%<replaceable>##</replaceable></literal>
     cifrado en la cadena dada. Se devuelve la cadena decodificada.
     <example>
      <title>Ejemplo urldecode() </title>
      <programlisting>
$a = split ('&', $querystring);
$i = 0;
while ($i &lt; count ($a)) {
  $b = split ('=', $a [$i]);
  echo 'El valor para el parámetro ', htmlspecialchars (urldecode ($b [0])),
       ' es ', htmlspecialchars (urldecode ($b [1])), "&lt;BR>";
  $i++;
}
</programlisting></example></para>
 
    <para>
     Vea también <function>urlencode</function></para>
   </refsect1>
  </refentry>


  <refentry id="function.urlencode">
   <refnamediv>
    <refname>urlencode</refname>
    <refpurpose>Codifica una URL en una cadena de texto</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descripción</title>
    <funcsynopsis>
     <funcdef>string <function>urlencode</function></funcdef>
     <paramdef>string <parameter>cadena</parameter></paramdef>
    </funcsynopsis>
    <para>
     Devuelve una cadena en la que todos los carácteres no alfanuméricos
     excepto <literal>-_.</literal> han sido reemplazados con un signo de
     porcentaje (<literal>%</literal>) seguido por dos dígitos hexadecimales
     y los espacios han sido codificados como signos positivos 
     (<literal>+</literal>). Está codificado de la misma manera que los
     datos que se envian desde un formulario WWW, es decir de la misma
     forma que el tipo <literal>application/x-www-form-urlencoded</literal>.
     Esto difiere del cifrado RFC1738 (vea <function>rawurlencode</function> ) 
     en el que por razones históricas, los espacios son codificados como
     signos positivos (+ ). Esta función es conveniente para codificar
     una cadena de texto que va a ser usada como parte de una consulta
     de una URL, y es una forma adecuada de pasar variables a la página
     siguiente:

     <example>
      <title>Ejemplo urlencode()</title>
      <programlisting>
echo '&lt;A HREF="mycgi?foo=', urlencode ($userinput), '">';
</programlisting></example></para>
 
    <para>
     Vea también <function>urldecode</function></para>

   </refsect1>
  </refentry>



 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
