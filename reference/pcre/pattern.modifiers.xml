<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 8ad0d94e1c87b2daabff88e74acc31e8a11eec0a Maintainer: aeoris Status: ready -->
<!-- Reviewed: no -->
<!-- splitted from ./en/functions/pcre.xml, last change in rev 1.2 -->
<article xml:id="reference.pcre.pattern.modifiers" xmlns="http://docbook.org/ns/docbook">
 <title>Modificadores de Patrón</title>
 <titleabbrev>Posibles modificadores en patrones de expresiones regulares</titleabbrev>
 <para>
  Los modificadores PCRE disponibles son listados a continuación. Los nombres
  entre paréntesis se refieren a nombres internos de PCRE para dichos modificadores.
  Los espacios y nuevas líneas son ignorados en los modificadores, otros caracteres generan error.
 </para>
 <para>
  <blockquote>
   <variablelist>
    <varlistentry>
     <term><emphasis>i</emphasis> (<literal>PCRE_CASELESS</literal>)</term>
     <listitem>
      <simpara>
       Si se aplica este modificador, las letras en el patrón coincidirán
       tanto con letras mayúsculas como minúsculas.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>m</emphasis> (<literal>PCRE_MULTILINE</literal>)</term>
     <listitem>
      <simpara>
       Por defecto, PCRE trata la cadena objetivo como si fuera una
       única "línea" de caracteres (incluso si en realidad contiene
       varias nuevas líneas). El meta-carácter "inicio de línea" (^)
       coincide sólo con el inicio de la cadena, mientras que el
       meta-carácter "final de línea" ($) coincide sólo con el final de la
       cadena, o antes del final de una nueva línea (a menos que el modificador
       <emphasis>D</emphasis> se aplique). Esto es igual que en
       Perl.
      </simpara>
      <simpara>
       Cuando se aplica este modificador, los constructores "inicio de línea" y
       "final de línea" coinciden inmediatamente después o inmediatamente
       antes que cualquier nueva línea de la cadena objetivo, respectivamente, así
       como al inicio y final absolutos. Esto es equivalente al
       modificador /m de Perl. Si no hay caracteres "\n" en una
       cadena objetivo, o no hay incidencias de ^ o $ en el patrón,
       la aplicación de este modificador no tiene efecto.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>s</emphasis> (<literal>PCRE_DOTALL</literal>)</term>
     <listitem>
      <simpara>
       Si se aplica este modificador, un meta-carácter punto en el patrón
       coincide con todos los caracteres, incluyendo nuevas líneas. Sin él,
       las nuevas líneas son excluidas. Este modificador es equivalente al
       modificador /s de Perl. Una clase negativa como [^a] siempre coincidirá con un
       carácter de nueva línea, independientemente de la aplicación de este
       modificador.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>x</emphasis> (<literal>PCRE_EXTENDED</literal>)</term>
     <listitem>
      <simpara>
       Si se aplica este modificador, los caracteres de información de espacios en blanco en el
       patrón se ignoran totalmente excepto cuando están escapados o dentro de
       una clase carácter, y los caracteres entre un # sin escapar
       fuera de una clase carácter y el siguiente carácter nueva línea,
       inclusive, también son ignorados. Esto es equivalente al modificador /x
       de Perl, y hace posible incluir comentarios dentro de
       patrones complicados. Observe, sin embargo, que esto se aplica sólo
       a caracteres de información. Los caracteres espacio en blanco nunca pueden aparecer
       dentro de secuencias de caracteres especiales en un patrón, por ejemplo
       dentro de la secuencia (?( la cual inicia un sub-patrón condicional.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>e</emphasis> (<literal>PREG_REPLACE_EVAL</literal>)</term>
     <listitem>
      &warn.deprecated.feature-5-5-0;
      <simpara>
       Si se aplica este modificador, <function>preg_replace</function>
       realiza las sustituciones normales de retro-referencias en la
       cadena a sustituir, la evalúa como código PHP, y usa el resultado
       para sustituir la cadena de búsqueda.
       Las comillas simples, comillas dobles, barras invertidas (<literal>\</literal>)
       y caracteres NULL serán escapados
       con barras invertidas en las retro-referencias sustituidas.
      </simpara>
      <caution>
       <para>
        La función <function>addslashes</function> se ejecuta en cada retroreferencia que coincida antes
        de que se realice la sustitución. Por lo tanto, cuando la retroreferencia
        se usa como una cadena entrecomillada, los caracteres escapados serán convertidos
        a literales. to literals. Sin embargo, los caracteres que son escapados, los cuales
        normalmente no serían convertidos, mantendrán sus barras. Esto hace que
        el uso de este modificador sea muy complicado.
       </para>
      </caution>
      <caution>
       <para>
        Asegúrese de que <parameter>replacement</parameter> constituye una cadena de código PHP válida;
        de otro modo PHP responderá con un error de análisis en la línea que contiene
        <function>preg_replace</function>.
       </para>
      </caution>
      <caution>
       <para>
        El uso de este modificador está <emphasis>desaconsejado</emphasis>, ya que puede introducir fácilmente
        vulnerabilidades de seguridad:
       </para>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
$html = $_POST['html'];

// cabeceras en mayúsculas
$html = preg_replace(
    '(<h([1-6])>(.*?)</h\1>)e',
    '"<h$1>" . strtoupper("$2") . "</h$1>"',
    $html
);
]]>
         </programlisting>
       </informalexample>
       <para>
        En el código de ejemplo de arriba puede ser explotado fácilmente pasando una cadena de texto como
        <literal>&lt;h1&gt;{${eval($_GET[php_code])}}&lt;/h1&gt;</literal>. Esto proporciona
        al atacante la capacidad de ejecutar código de PHP arbitrario y tener
        acceso casi completo al servidor.
       </para>
       <para>
        Para evitar este tipo de vulnerabilidad de ejecución de código remoto, se
        debería usar la función <function>preg_replace_callback</function> en su lugar:
       </para>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
$html = $_POST['html'];

// cabeceras en mayúsculas
$html = preg_replace_callback(
    '(<h([1-6])>(.*?)</h\1>)',
    function ($m) {
        return "<h$m[1]>" . strtoupper($m[2]) . "</h$m[1]>";
    },
    $html
);
]]>
          </programlisting>
       </informalexample>
     </caution>
     <note>
      <para>
       Sólamente <function>preg_replace</function> utiliza este modificador;
       es ingnorado por otras funciones PCRE.
      </para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>A</emphasis> (<literal>PCRE_ANCHORED</literal>)</term>
    <listitem>
     <simpara>
      Si se aplica este modificador, el patrón es forzado a ser
      "anclado", es decir, se le obliga a coincidir sólo con el
      inicio de la cadena que está siendo buscada (la "cadena
      objetivo"). Este efecto también se puede lograr mediante construcciones
      apropiadas en el patrón mismo, lo cual es la única manera de hacerlo
      en Perl.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>D</emphasis> (<literal>PCRE_DOLLAR_ENDONLY</literal>)</term>
    <listitem>
     <simpara>
      Si se aplica este modificador, un meta-carácter dólar en el patrón
      coincidirá sólo con el final de la cadena objetivo. Sin este
      modificador, un dólar coincide también inmediatamente antes del
      carácter final si éste es una nueva línea (pero no antes de cualquier otra
      nueva línea). Este modificador es ignorado si el modificadr <emphasis>m</emphasis>
      se aplica. No existe equivalente a este modificador en
      Perl.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>S</emphasis></term>
    <listitem>
     <simpara>
      Cuando un patrón se va a usar varias veces, merece la pena
      dedicar más tiempo a analizarlo a fin de acelerar
      el tiempo tomado para las comparaciones. Si se aplica este modificador, se
      realiza este análisis extra. Actualmente, estudiar un patrón
      es útil sólamente para patrones no anclados que no tienen
      un carácter de inicio único fijo.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>U</emphasis> (<literal>PCRE_UNGREEDY</literal>)</term>
    <listitem>
     <simpara>
      Este modificador invierte la "codicia" de los cuantificadores de modo
      que no sean codiciosos por defecto, pero se vuelven codiciosos si son seguidos
      por <literal>?</literal>. Esto no es compatible con Perl. También se puede
      aplicar por un <link linkend="regexp.reference.internal-options">modificador
      de ajuste dentro del patrón</link> (<literal>?U</literal>)
      o por un signo de interrogación detrás del cuantificador (p.ej.
      <literal>.*?</literal>).
     </simpara>
     <note>
      <para>
       Normalmente no es posible hacer coincidir más de <link
       linkend="ini.pcre.backtrack-limit">pcre.backtrack_limit</link>
       caracteres en el modo no codicioso.
      </para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>X</emphasis> (<literal>PCRE_EXTRA</literal>)</term>
    <listitem>
     <simpara>
      Este modificador pone en marcha funcionalidad adicional de PCRE que
      es incompatible con Perl. Cualquier barra invertida en un patrón que
      esté seguida por una letra que no tenga un significado especial causa
      un error, por lo que se reservan estas combinaciones para futuras
      expansiones. Por defecto, como en Perl, una barra invertida seguida de una
      letra que no tenga un significado especial se trata como un literal.
      No hay en la actualidad otras características controladas por este
      modificador.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>J</emphasis> (<literal>PCRE_INFO_JCHANGED</literal>)</term>
    <listitem>
     <simpara>
      El ajuste de opción interna (?J) cambia la opción local <literal>PCRE_DUPNAMES</literal>.
      Permite nombres duplicados para sub-patrones.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>u</emphasis> (<literal>PCRE_UTF8</literal>)</term>
    <listitem>
     <simpara>
      Este modificador pone en marcha funcionalidad adicional de PCRE que
      es incompatible con Perl. Las cadenas de patrones son tratadas como
      UTF-8. Este modificador está disponible a partir de PHP 4.1.0 o posterior
      en Unix y desde PHP 4.2.3 en win32.
      La validez UTF-8 del patrón es verificada desde PHP 4.3.5.
     </simpara>
    </listitem>
   </varlistentry>
  </variablelist>
 </blockquote>
</para>
</article>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
