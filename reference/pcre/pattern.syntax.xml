<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: e25450d9dc5f49da38026350643730de2017ac67 Maintainer: aeoris Status: ready -->
<!-- Reviewed: no -->
<!-- splitted from ./en/functions/pcre.xml, last change in rev 1.2 -->
<chapter xml:id="reference.pcre.pattern.syntax" xmlns="http://docbook.org/ns/docbook">
 <title>Sintaxis de Patrón</title>
 <titleabbrev>Sintaxis de expresiones regulares de PCRE</titleabbrev>
 
 <section xml:id="regexp.introduction">
  <title>Introducción</title>
  <para>
   La sintaxis y semántica de las expresiones regulares
   soportadas por PCRE están descritas más adelante. Las expresiones regulares
   también están descritas en la documentación de Perl y en otros
   libros, algunos de los cuales tienen abundantes ejemplos. El libro de Jeffrey
   Friedl "Mastering  Regular  Expressions", publicado por
   O'Reilly  (ISBN 1-56592-257-3), las cubre en gran detalle.
   La descripción aquí dada está prevista como documentación de referencia.
  </para>
  <para>
   Una expresión regular es un patrón que se compara con una
   cadena objetivo de izquierda a derecha. La mayoría de los caracteres se
   representan a sí mismos en un patrón, y se comparan con el carácter
   correspondiente en el sujeto. Como ejemplo trivial, el patrón
   <literal>El veloz murciélago hindú</literal>
   coincide con una porción de una cadena objetivo que es idéntica a dicho patrón.  
  </para>
 </section>
 <section xml:id="regexp.reference.delimiters">
  <title>Delimitadores</title>
  <para>
   Cuando se usan funciones PCRE, se requiere que el patrón esté encerrado
   entre <emphasis>delimitadores</emphasis>. Un delimitador puede ser cualquier carácter
   no alfanumérico, que no sea una barra invertida, y que no sea un espacio en blanco.
  </para>
  <para>
   Los delimitadores que se usan a menudo son barras oblícuas (<literal>/</literal>), signos
   de número (<literal>#</literal>) y tildes (<literal>~</literal>). Los
   siguientes ejemplos son todos patrones delimitados válidos.
   <informalexample>
    <programlisting>
<![CDATA[
/foo bar/
#^[^0-9]$#
+php+
%[a-zA-Z0-9_-]%
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Si el delimitador necesita ser comparado dentro del patrón se debe
   escapar usando una barra invertida. Si el delimitador aparece a menudo dentro del
   patrón, es una buena idea escoger otro delimitador para aumentar
   la legibilidad.
   <informalexample>
    <programlisting>
<![CDATA[
/http:\/\//
#http://#
]]>
    </programlisting>
   </informalexample>
   La función <function>preg_quote</function> se puede usar para escapar una cadena
   para inyectarla dentro de un patrón y su segundo parámetro opcional de puede usar
   parar especificar el delimitador a escapar.
  </para>
  <para>
   Además de los delimitadores anteriormente mencionados, también es posible usar
   delimitadores estilo paréntesis donde los paréntesis de apertura y cierre son el
   delimitador de inicio y final, respectivamente.
   <informalexample>
    <programlisting>
<![CDATA[
{this is a pattern}
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Puede añadir <link linkend="reference.pcre.pattern.modifiers">modificadores de
   patrón</link> después del delimitador final. El siguiente es un ejemplo
   de comparación insensible a mayúsculas-minúsculas:
   <informalexample>
    <programlisting>
<![CDATA[
#[a-z]#i
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>
 <section xml:id="regexp.reference.meta">
  <title>Meta-caracteres</title>
  <para>     
   El poder de las expresiones regulares viene dado por la
   capacidad de incluir alternativas y repeticiones en el
   patrón. Éstos están codificadoes en el patrón por el uso de
   <emphasis>meta-caracteres</emphasis>, los cuales no se representan a sí mismos,
   sino que son interpretados de una forma especial.
  </para>
  <para>
   Hay dos conjuntos diferentes de meta-caracteres: aquéllos que
   son reconocidos en cualquier lugar de un patrón excepto dentro de
   los corchetes, y aquéllos que son reconocidos dentro de los corchetes.
   Fuera de los corchetes, los meta-caracteres son los siguientes:
   <variablelist>
    <varlistentry>
     <term><emphasis>\</emphasis></term>
     <listitem><simpara>carácter de escape general con varios usos</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>^</emphasis></term>
     <listitem><simpara>declaración de inicio de sujeto (o línea, en modo multilínea)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>$</emphasis></term>
     <listitem><simpara>declaración de fin de sujeto o antes de la terminación de nueva línea (o fin línea, en modo multilínea)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>.</emphasis></term>
     <listitem><simpara>coincide con cualquier carácter excepto con el de nueva línea (por defecto)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>[</emphasis></term>
     <listitem><simpara>inicio de la definición de la clase carácter</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>|</emphasis></term>
     <listitem><simpara>inicio de rama alternativa</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>(</emphasis></term>
     <listitem><simpara>inicio de sub-patrón</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>)</emphasis></term>
     <listitem><simpara>fin de sub-patrón</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>?</emphasis></term>
     <listitem>
      <simpara>
       extiende el significado de (, también cuantificador 0 ó 1,
       hace perezosos a los cuantificadores codiciosos
       (véase <link linkend="regexp.reference.repetition">repetición</link>)
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>*</emphasis></term>
     <listitem><simpara>cuantificador 0 o más</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>+</emphasis></term>
     <listitem><simpara>cuantificador 1 o más</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>{</emphasis></term>
     <listitem><simpara>inicio de cuantificador mín/máx</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>}</emphasis></term>
     <listitem><simpara>fin de cuantificador mín/máx</simpara></listitem>
    </varlistentry>
   </variablelist>
   
   La parte de un patrón que está entre corchetes se llama una
   "clase carácter". En una clase carácter los únicos meta-caracteres son:
   
   <variablelist>
    <varlistentry>
     <term><emphasis>\</emphasis></term>
     <listitem><simpara>carácter de escape general</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>^</emphasis></term>
     <listitem><simpara>niega la clase, pero sólo si se trata del primer carácter</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>-</emphasis></term>
     <listitem><simpara>define el rango de caracteres</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>]</emphasis></term>
     <listitem><simpara>finaliza la clase carácter</simpara></listitem>
    </varlistentry>
   </variablelist>
   
   Las siguientes secciones describen el uso de cada
   meta-carácter.
  </para>
 </section>
 
 <section xml:id="regexp.reference.escape">
  <title>Secuencias de escape</title>
  <para>
   El carácter barra invertida tiene varios usos. El primero es que si está
   seguido de un carácter no alfanumérico, toma cualquier
   significado especial que el carácter pueda tener. Este uso de
   la barra invertida como carácter de escape se aplica tanto dentro como fuera de
   las clases carácter.
  </para>
  <para>
   Por ejemplo, si quiere coincidir un carácter "*", escriba
   "\*" en el patrón. Esto se aplica aunque el
   siguiente carácter pudiera ser interpretado como un
   meta-carácter, por lo que es mejor asegurarse de preceder un carácter no alfanumérico
   con "\" para especificar que éste se representa a sí mismo. En
   particular, si quiere coincidir una barra invertida, escriba "\\".
  </para>
  <note>
   <para>
    Las <link linkend="language.types.string.syntax">cadenas</link> PHP entre comillas
    simples y dobles tienen un significado especial para la barra invertida.
    Así, si \ ha de ser comparado con una expresión
    regular \\, entonces se debe usar "\\\\" o '\\\\' en código PHP.
   </para>
  </note>
  <para>
   Si un patrón es compilado con la opción
   <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>,
   los espacios en blanco en el patrón (distinto de una clase carácter) y los
   caracteres entre un "#" fuera de una clase carácter y el siguiente carácter de nueva
   línea se ignoran. Una barra invertida de escape se puede usar para incluir un
   carácter espacio en blanco o "#" como parte del patrón.
  </para>
  <para>
   Un segundo uso de la barra invertida proporciona una manera de codificar
   caracteres no imprimibles en patrones de una forma visible. No hay
   restricciones en la aparición de los caracteres no imprimibles,
   excepto para el cero binario el cual finaliza el patrón,
   pero cuando un patrón está siendo preparado para edición de texto, normalmente
   es más fácil usar una de las siguientes secuencias de escape
   en vez del carácter binario que representan:
  </para>
  <para>
   <variablelist>
    <varlistentry>
     <term><emphasis>\a</emphasis></term>
     <listitem>
      <simpara>alarma, es decir, el carácter BEL (07 hex)</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\cx</emphasis></term>
     <listitem>
      <simpara>"control-x", donde x es cualquier carácter</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\e</emphasis></term>
     <listitem>
      <simpara>escape (1B hex)</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\f</emphasis></term>
     <listitem>
      <simpara>salto de página (0C hex)</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\n</emphasis></term>
     <listitem>
      <simpara>nueva línea (0A hex)</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\p{xx}</emphasis></term>
     <listitem>
      <simpara>
       un carácter con la propiedad xx, véase
       <link linkend="regexp.reference.unicode">propiedades unicode</link>
       para más información
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\P{xx}</emphasis></term>
     <listitem>
      <simpara>
       un carácter sin la propiedad xx, véase
       <link linkend="regexp.reference.unicode">propiedades unicode</link>
       para más información
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\r</emphasis></term>
     <listitem>
      <simpara>retorno de carro (0D hex)</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\t</emphasis></term>
     <listitem>
      <simpara>tabulador (09 hex)</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\xhh</emphasis></term>
     <listitem>
      <simpara>
       carácter con el código hexadecimal hh
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\ddd</emphasis></term>
     <listitem>
      <simpara>carácter con el código octal ddd, o retro-referencia</simpara>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   El efecto exacto de "<literal>\cx</literal>" es como sigue: 
   si "<literal>x</literal>" es una letra minúscula, ésta se convierte
   a mayúscula. Después se invierte el bit 6 del carácter (40 hex). 
   Así, "<literal>\cz</literal>" se convierte en 1A hex, pero
   "<literal>\c{</literal>" se convierte en 3B hex, mientras que "<literal>\c;</literal>"
   se conviente en 7B hex.
  </para>
  <para>
   Después de "<literal>\x</literal>", se leen hasta dos dígitos
   hexadecimales (las letras pueden ser tanto mayúsculas como minúsculas).
   En <emphasis>modo UTF-8</emphasis>, "<literal>\x{...}</literal>" es
   permitido, donde el contenido entre las llaves es una cadena de dígitos
   hexadecimales. Esto se interpreta como un carácter UTF-8 cuyo número de código es
   el dado por el número hexadecimal. La secuencia de escape hexadecimal original,
   <literal>\xhh</literal>, conincide con un carácter UTF-8 de dos bytes si el valor
   es mayor que 127.
  </para>
  <para>
   Después de "<literal>\0</literal>", se leen hasta dos dígitos octales más.
   En cualquier caso, si hay menos de dos dígitos, sólo se usan
   aquéllos que están presentes. Así, la secuencia "<literal>\0\x\07</literal>" 
   especifica dos ceros binarios seguidos de un carácter BEL. Asegúrese de
   proporcionar dos dígitos después del cero inicial si el carácter
   que sigue es también un dígito octal.
  </para>
  <para>
   El manejo de una barra invertida seguida de un dígito distinto de 0
   es complicado. Fuera de una clase carácter, PCRE lee este dígito,
   así como cualesquiera dígitos siguientes, como un número decimal. Si el número
   es menor que 10, o si ha habido al menos tantas
   capturas previas hacia la izquierda en la expresión, la
   secuencia entera es tomada como una <emphasis>retro-referencia</emphasis>. Una descripción
   de cómo funciona esto se da más adelante, seguido de una discusión
   sobre sub-patrones entre paréntesis.
  </para>
  <para>
   Dentro de una clase carácter, o si el número decimal es
   mayor que 9 y no han habido tantos sub-patrones de captura,
   PCRE relee hasta tres dígitos octales siguientes a la
   barra invertida, y genera un sólo byte de los
   8 bits menos significativos del valor. Cualesquiera dígitos subsiguientes
   se representan a sí mismos. Por ejemplo:
  </para>
  <para>
   <variablelist>
    <varlistentry>
     <term><emphasis>\040</emphasis></term>
     <listitem><simpara>es otra manera de escribir un espacio</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\40</emphasis></term>
     <listitem>
      <simpara>
       es lo mismo, siempre que haya menos de 40
       sub-patrones de captura previos
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\7</emphasis></term>
     <listitem><simpara>es siempre una retro-referencia</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\11</emphasis></term>
     <listitem>
      <simpara>
       puede ser una retro-refenrencia, u otra manera de
       escribir una tabulación
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\011</emphasis></term>
     <listitem><simpara>es siempre una tabulación</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\0113</emphasis></term>
     <listitem><simpara>es una tabulación seguida del carácter "3"</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\113</emphasis></term>
     <listitem>
      <simpara>
       es el carácter con el código octal 113 (ya que no
       puede haber más de 99 retro-referencias)
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\377</emphasis></term>
     <listitem><simpara>es un byte consistente en bits 1 enteramente</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\81</emphasis></term>
     <listitem>
      <simpara>
       es tanto una retro-referencia como un cero binario
       seguido de los caracteres "8" y "1"
      </simpara>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Observe que los valores octales 100 y mayores no deben ser
   precedidos por un cero inicial, ya que nunca se leen más de tres
   dígitos octales.
  </para>
  <para>
   Todas las secuencias que definen un valor de byte único se pueden
   usar tanto dentro como fuera de las clases carácter. Además,
   dentro de una clase carácter, la secuencia "<literal>\b</literal>"
   se interpreta como el carácter retroceso (08 hex). Fuera de una clase
   carácter tiene diferentes significados (véase más abajo).
  </para>
  <para>
   El tercer uso de la barra invertida es parar especificar tipos
   de caracteres genéricos:
  </para>
  <para>
   <variablelist>
    <varlistentry>
     <term><emphasis>\d</emphasis></term>
     <listitem><simpara>cualquier dígito decimal</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\D</emphasis></term>
     <listitem><simpara>cualquier carácter que no es un dígito decimal</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\h</emphasis></term>
     <listitem><simpara>cualquier carácter espacio en blanco horizontal
      (desde PHP 5.2.4)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\H</emphasis></term>
     <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco horizontal
      (desde PHP 5.2.4)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\s</emphasis></term>
     <listitem><simpara>cualquier carácter espacio en blanco</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\S</emphasis></term>
     <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\v</emphasis></term>
     <listitem><simpara>cualquier carácter espacio en blanco vertical
      (desde PHP 5.2.4)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\V</emphasis></term>
     <listitem><simpara>cualquier carácter que no es un carácter espacio en blanco vertical
      (desde PHP 5.2.4)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\w</emphasis></term>
     <listitem><simpara>cualquier carácter "palabra"</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\W</emphasis></term>
     <listitem><simpara>cualquier carácter que no es "palabra"</simpara></listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Cada par de sencuencias de escape divide el conjunto completo de
   caracteres en dos conjuntos separados. Cualquier carácter dado
   concide con uno, y sólo uno, de cada par.
  </para>
  <para>
   Un carácter "palabra" es cualquier letra o dígito o el carácter
   subrayado, es decir, cualquier carácter que pueda ser parte de una
   "<emphasis>palabra</emphasis>" Perl. La definición de letras y dígitos está
   controlada por las tablas de caracteres de PCRE, y pueden variar si 
   tiene lugar la comparación de configuraciones regionales específicas. Por ejemplo,
   en la localización "fr" (Francés), algunos códigos de caracteres
   mayores que 128 se usan para letras acentuadas,
   y éstos se comparan por <literal>\w</literal>.
  </para>
  <para>
   Estas secuencias de tipo de caracteres puede aparecer tanto dentro como
   fuera de las clases carácter. Cada una coincide con un carácter del
   tipo apropiado. Si el punto de coincidencia actual está
   al final de la cadena objetivo, todas ellas fallarán, ya que no
   hay caracteres a comparar.
  </para>
  <para>
   El cuarto uso de la barra invertida es para ciertas declaraciones
   simples. Una declaración especifica una condición que se debe encontrar
   en un punto particular de una comparación, sin consumir ningún
   carácter de la cadena objetivo. El uso de sub-patrones
   para declaraciones más complicadas se describe después. Las
   declaraciones de la barra invertida son
  </para>
  <para>
   <variablelist>
    <varlistentry>
     <term><emphasis>\b</emphasis></term>
     <listitem><simpara>límite de palabra</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\B</emphasis></term>
     <listitem><simpara>distinto a límite de palabra</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\A</emphasis></term>
     <listitem><simpara>comienzo del sujeto
      (independientemente del modo multi-linea)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\Z</emphasis></term>
     <listitem>
      <simpara>
       fin del sujeto o nueva línea al final (independientemente del
       modo multi-linea)
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\z</emphasis></term>
     <listitem><simpara>final del sujeto (independientemente del modo multi-línea)</simpara></listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>\G</emphasis></term>
     <listitem><simpara>primera posición de coincidencia del sujeto</simpara></listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Estas declaraciones pueden no aparecer en clases carácter (pero
   observe que "<literal>\b</literal>" tiene un significado diferente, a saber, el carácter
   retroceso, dentro de una clase carácter).
  </para>
  <para>
   Un límite de palabra es una posición en la cadena objetivo donde
   el carácter actual y el carácter previo no coinciden con
   <literal>\w</literal> o <literal>\W</literal> (es decir, uno coincide con
   <literal>\w</literal> y el otro coincice con
   <literal>\W</literal>), o el inicio o final de la cadena si el primer o último
   carácter coincide con <literal>\w</literal>, respectivamente.
  </para>
  <para>
   Las declaraciones <literal>\A</literal>, <literal>\Z</literal>, y
   <literal>\z</literal> difieren de los tradicionales
   circumflejo y dólar (descritos después) de modo que siempre
   coinciden con el inicio y final absolutos de la cadena objetivo,
   sin importar las opciones que se apliquen. No les afectan las opciones
   <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> o
   <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>.
   La diferencia entre <literal>\Z</literal> y
   <literal>\z</literal> es que <literal>\Z</literal> coincide antes de una
   nueva línea que es el último carácter de la cadena, además de al final de
   la cadena, mientras que <literal>\z</literal> coincide sólo con el final.
  </para>
  <para>
   La declaración <literal>\G</literal> es verdadera sólo cuando la posición
   de comparación actual está al principio del punto de coincidencia, tal como se especifica
   en el argumento <parameter>offset</parameter> de
   <function>preg_match</function>. Difiere de <literal>\A</literal>
   cuando el valor de <parameter>offset</parameter> no es cero.
  </para>
  
  <para>
   Se puede usar <literal>\Q</literal> y <literal>\E</literal> para ignorar
   meta-caracteres de expresiones regulares. Por ejemplo:
   <literal>\w+\Q.$.\E$</literal> coincidirá con uno o más caracteres palabra,
   seguidos por los literales <literal>.$.</literal> y anclados al final de
   la cadena.
  </para>
  
  <para>
   A partir de PHP 5.2.4, <literal>\K</literal> se puede usar para reiniciar el comienzo
   de comparación. Por ejemplo, el patrón <literal>foo\Kbar</literal> coincide con
   "foobar", pero informa de que ha coincidido con "bar". El uso de
   <literal>\K</literal> no interfiere con el parámetro de las cadenas
   capturadas. Por ejemplo, cuando el patrón <literal>(foo)\Kbar</literal>
   coincide con "foobar", la primera sub-cadena está establecida aún a "foo".
  </para>
  
 </section>
 
 <section xml:id="regexp.reference.unicode">
  <title>Propiedades de los caracteres Unicode</title>
  <para>
   A partir de 5.1.0, están disponibles
   tres secuencias de escape adicionales para comparar tipos de caracteres genéricos
   cuando el <emphasis>modo UTF-8</emphasis> está seleccionado. Son:
  </para>
  <variablelist>
   <varlistentry>
    <term><emphasis>\p{xx}</emphasis></term>
    <listitem><simpara>un carácter con la propiedad xx</simpara></listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>\P{xx}</emphasis></term>
    <listitem><simpara>un carácter sin la propiedad xx</simpara></listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>\X</emphasis></term>
    <listitem><simpara>una secuencia Unicode extendida</simpara></listitem>
   </varlistentry>
  </variablelist>
  <para>
   Los nombres de las propiedades representadas arriba por <literal>xx</literal> están limitadas
   a las propiedades de la categoría general de Unicode. Cada carácter tiene exactamente una
   propiedad, especificada por una abreviatura de dos letras. Por compatibilidad con
   Perl, la negación se puede especificar incluyendo un acento circunflejo entre la
   llave de apertura y el nombre de la propiedad. Por ejemplo, <literal>\p{^Lu}</literal> 
   es lo mismo que <literal>\P{Lu}</literal>.
  </para>
  <para>
   Si sólo se especifica una letra con <literal>\p</literal> o 
   <literal>\P</literal>, se incluyen todas las propiedades que comienzan con esa
   letra. En este caso, en la ausencia de negación, las llaves en la
   secuencia de escape son opcionales; estos dos ejemplos tienen el mismo efecto:
  </para>
  <informalexample>
   <programlisting>
<![CDATA[
\p{L}
\pL
]]>
   </programlisting>
  </informalexample>
  <table>
   <title>Códigos de propiedades soportados</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Propiedad</entry>
      <entry>Coincidencias</entry>
      <entry>Notas</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>C</literal></entry>
      <entry>Otro</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Cc</literal></entry>
      <entry>Control</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Cf</literal></entry>
      <entry>Formato</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Cn</literal></entry>
      <entry>Sin asignar</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Co</literal></entry>
      <entry>Uso privado</entry>
      <entry></entry>
     </row>
     <row rowsep="1">
      <entry><literal>Cs</literal></entry>
      <entry>Sustituto</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>L</literal></entry>
      <entry>Letra</entry>
      <entry>
       Incluye las siguientes propiedades: <literal>Ll</literal>,
       <literal>Lm</literal>, <literal>Lo</literal>, <literal>Lt</literal> y
       <literal>Lu</literal>.         
      </entry>
     </row>
     <row>
      <entry><literal>Ll</literal></entry>
      <entry>Letra minúscula</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Lm</literal></entry>
      <entry>Letra modificadora</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Lo</literal></entry>
      <entry>Otra letra</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Lt</literal></entry>
      <entry>Letra de título</entry>
      <entry></entry>
     </row>
     <row rowsep="1">
      <entry><literal>Lu</literal></entry>
      <entry>Letra mayúscula</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>M</literal></entry>
      <entry>Marca</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Mc</literal></entry>
      <entry>Marca de espacio</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Me</literal></entry>
      <entry>Marca de cierre</entry>
      <entry></entry>
     </row>
     <row rowsep="1">
      <entry><literal>Mn</literal></entry>
      <entry>Marca de no-espacio</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>N</literal></entry>
      <entry>Número</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Nd</literal></entry>
      <entry>Número decimal</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Nl</literal></entry>
      <entry>Número letra</entry>
      <entry></entry>
     </row>
     <row rowsep="1">
      <entry><literal>No</literal></entry>
      <entry>Otro número</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>P</literal></entry>
      <entry>Puntuación</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Pc</literal></entry>
      <entry>Puntuación de conexión</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Pd</literal></entry>
      <entry>Puntuación guión</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Pe</literal></entry>
      <entry>Puntuación de cierre</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Pf</literal></entry>
      <entry>Puntuación final</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Pi</literal></entry>
      <entry>Puntuación inicial</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Po</literal></entry>
      <entry>Otra puntuación</entry>
      <entry></entry>
     </row>
     <row rowsep="1">
      <entry><literal>Ps</literal></entry>
      <entry>Puntuación de apertura</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>S</literal></entry>
      <entry>Símbolo</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Sc</literal></entry>
      <entry>Símbolo de moneda</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Sk</literal></entry>
      <entry>Símbolo modificador</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Sm</literal></entry>
      <entry>Símbolo matemático</entry>
      <entry></entry>
     </row>
     <row rowsep="1">
      <entry><literal>So</literal></entry>
      <entry>Otro símbolo</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Z</literal></entry>
      <entry>Separador</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Zl</literal></entry>
      <entry>Separador de línea</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Zp</literal></entry>
      <entry>Separador de párrafo</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>Zs</literal></entry>
      <entry>Separador de espacio</entry>
      <entry></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Las propiedades extendidas tales como <literal>InMusicalSymbols</literal> no están
   admitidas por PCRE.
  </para>
  <para>
   El especificar coincidicencias insensibles a mayúsculas-minúsculas no afecta a estas secuencias
   de escape. Por ejemplo, <literal>\p{Lu}</literal> siempre coincide con letras mayúsculas.
  </para>
  <para>
   Los conjuntos de caracteres Unicode están definidos como pertenecientes a ciertos alfabetos. Se
   puede hacer coincidir un carácter de uno de estos conjuntos usando un nombre de alfabeto. Por
   ejemplo:
  </para>
  <itemizedlist>
   <listitem>
    <simpara><literal>\p{Greek}</literal></simpara>
   </listitem>
   <listitem>
    <simpara><literal>\P{Han}</literal></simpara>
   </listitem>
  </itemizedlist>
  <para>
   Aquellos que no son parte de un alfabeto identificado, son metidos en el mismo saco como
   <literal>Common</literal>. La lista actual de alfabetos es:
  </para>
  <table>
   <title>Supported scripts</title>
   <tgroup cols="5">
    <tbody>
     <row>
      <entry><literal>Arabic</literal></entry>
      <entry><literal>Armenian</literal></entry>
      <entry><literal>Avestan</literal></entry>
      <entry><literal>Balinese</literal></entry>
      <entry><literal>Bamum</literal></entry>
     </row>
     <row>
      <entry><literal>Batak</literal></entry>
      <entry><literal>Bengali</literal></entry>
      <entry><literal>Bopomofo</literal></entry>
      <entry><literal>Brahmi</literal></entry>
      <entry><literal>Braille</literal></entry>
     </row>
     <row>
      <entry><literal>Buginese</literal></entry>
      <entry><literal>Buhid</literal></entry>
      <entry><literal>Canadian_Aboriginal</literal></entry>
      <entry><literal>Carian</literal></entry>
      <entry><literal>Chakma</literal></entry>
     </row>
     <row>
      <entry><literal>Cham</literal></entry>
      <entry><literal>Cherokee</literal></entry>
      <entry><literal>Common</literal></entry>
      <entry><literal>Coptic</literal></entry>
      <entry><literal>Cuneiform</literal></entry>
     </row>
     <row>
      <entry><literal>Cypriot</literal></entry>
      <entry><literal>Cyrillic</literal></entry>
      <entry><literal>Deseret</literal></entry>
      <entry><literal>Devanagari</literal></entry>
      <entry><literal>Egyptian_Hieroglyphs</literal></entry>
     </row>
     <row>
      <entry><literal>Ethiopic</literal></entry>
      <entry><literal>Georgian</literal></entry>
      <entry><literal>Glagolitic</literal></entry>
      <entry><literal>Gothic</literal></entry>
      <entry><literal>Greek</literal></entry>
     </row>
     <row>
      <entry><literal>Gujarati</literal></entry>
      <entry><literal>Gurmukhi</literal></entry>
      <entry><literal>Han</literal></entry>
      <entry><literal>Hangul</literal></entry>
      <entry><literal>Hanunoo</literal></entry>
     </row>
     <row>
      <entry><literal>Hebrew</literal></entry>
      <entry><literal>Hiragana</literal></entry>
      <entry><literal>Imperial_Aramaic</literal></entry>
      <entry><literal>Inherited</literal></entry>
      <entry><literal>Inscriptional_Pahlavi</literal></entry>
     </row>
     <row>
      <entry><literal>Inscriptional_Parthian</literal></entry>
      <entry><literal>Javanese</literal></entry>
      <entry><literal>Kaithi</literal></entry>
      <entry><literal>Kannada</literal></entry>
      <entry><literal>Katakana</literal></entry>
     </row>
     <row>
      <entry><literal>Kayah_Li</literal></entry>
      <entry><literal>Kharoshthi</literal></entry>
      <entry><literal>Khmer</literal></entry>
      <entry><literal>Lao</literal></entry>
      <entry><literal>Latin</literal></entry>
     </row>
     <row>
      <entry><literal>Lepcha</literal></entry>
      <entry><literal>Limbu</literal></entry>
      <entry><literal>Linear_B</literal></entry>
      <entry><literal>Lisu</literal></entry>
      <entry><literal>Lycian</literal></entry>
     </row>
     <row>
      <entry><literal>Lydian</literal></entry>
      <entry><literal>Malayalam</literal></entry>
      <entry><literal>Mandaic</literal></entry>
      <entry><literal>Meetei_Mayek</literal></entry>
      <entry><literal>Meroitic_Cursive</literal></entry>
     </row>
     <row>
      <entry><literal>Meroitic_Hieroglyphs</literal></entry>
      <entry><literal>Miao</literal></entry>
      <entry><literal>Mongolian</literal></entry>
      <entry><literal>Myanmar</literal></entry>
      <entry><literal>New_Tai_Lue</literal></entry>
     </row>
     <row>
      <entry><literal>Nko</literal></entry>
      <entry><literal>Ogham</literal></entry>
      <entry><literal>Old_Italic</literal></entry>
      <entry><literal>Old_Persian</literal></entry>
      <entry><literal>Old_South_Arabian</literal></entry>
     </row>
     <row>
      <entry><literal>Old_Turkic</literal></entry>
      <entry><literal>Ol_Chiki</literal></entry>
      <entry><literal>Oriya</literal></entry>
      <entry><literal>Osmanya</literal></entry>
      <entry><literal>Phags_Pa</literal></entry>
     </row>
     <row>
      <entry><literal>Phoenician</literal></entry>
      <entry><literal>Rejang</literal></entry>
      <entry><literal>Runic</literal></entry>
      <entry><literal>Samaritan</literal></entry>
      <entry><literal>Saurashtra</literal></entry>
     </row>
     <row>
      <entry><literal>Sharada</literal></entry>
      <entry><literal>Shavian</literal></entry>
      <entry><literal>Sinhala</literal></entry>
      <entry><literal>Sora_Sompeng</literal></entry>
      <entry><literal>Sundanese</literal></entry>
     </row>
     <row>
      <entry><literal>Syloti_Nagri</literal></entry>
      <entry><literal>Syriac</literal></entry>
      <entry><literal>Tagalog</literal></entry>
      <entry><literal>Tagbanwa</literal></entry>
      <entry><literal>Tai_Le</literal></entry>
     </row>
     <row>
      <entry><literal>Tai_Tham</literal></entry>
      <entry><literal>Tai_Viet</literal></entry>
      <entry><literal>Takri</literal></entry>
      <entry><literal>Tamil</literal></entry>
      <entry><literal>Telugu</literal></entry>
     </row>
     <row>
      <entry><literal>Thaana</literal></entry>
      <entry><literal>Thai</literal></entry>
      <entry><literal>Tibetan</literal></entry>
      <entry><literal>Tifinagh</literal></entry>
      <entry><literal>Ugaritic</literal></entry>
     </row>
     <row>
      <entry><literal>Vai</literal></entry>
      <entry><literal>Yi</literal></entry>
      <entry />
      <entry />
      <entry />
      <entry />
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   El escape <literal>\X</literal> coincide con cualquier número de caracteres Unicode
   que forman un secuencia Unicode extendida. <literal>\X</literal> es equivalente
   a <literal>(?>\PM\pM*)</literal>.
  </para>
  <para>
   Es decir, coincide con un carácter sin la propiedad "marca", seguido
   por cero o más caracteres sin la propiedad "marca", y trata la
   secuencia como un grupo atómico (véase más adelante). Los caracteres con la propiedad
   "marca" son típicamente acentos que afectan al carácter precedente.
  </para>
  <para>
   La comparación de caracteres por propiedades Unicode no es rápida, porque PCRE ha
   de buscar una estructura que contiene datos por más de quince mil
   caracteres. Es por esto por lo que las secuencias de escape tradicionales tales como
   <literal>\d</literal> y <literal>\w</literal> no usan propiedades Unicode
   en PCRE.
  </para>
 </section>
 
 <section xml:id="regexp.reference.anchors">
  <title>Anclas</title>
  <para>
   Fuera de una clase carácter, en el modo de comparación por defecto, el
   carácter circunflejo (<literal>^</literal>) es una declaración que
   es verdadera sólo si el punto de coincidencia actual está en el inicio de
   de la cadena objetivo. Dentro de una clase carácter, circunflejo (<literal>^</literal>)
   tiene un significado totalmente diferente (véase más adelante).
  </para>
  <para>
   Circunflejo (<literal>^</literal>) no necesita ser el primer carácter
   del patrón si están implicadas varias alternativas, pero
   debería ser la primera cosa en cada alternativa en la que aparece
   si el patrón es comparado siempre con esa rama. Si todas las posibles
   alternativas comienzan con un circunflejo (<literal>^</literal>), es decir,
   si el patrón es obligado a coincidir sólo con el comienzo de la cadena objetivo,
   se dice que el patrón está "anclado". (También hay otras
   contrucciones que pueden causar que un patrón esté anclado.)
  </para>
  <para>
   Un carácter dólar (<literal>$</literal>) es una declaración la cual es
   &true; sólo si el punto actual de coincidencia está al final de la cadena
   objetivo, o inmediatamente antes de un carácter de nueva línea que es el último
   carácter en la cadena (por defecto). Dólar (<literal>$</literal>)
   no necesita ser el último carácter del patrón si están implicadas varias
   alternativas, pero debería ser el último elemento en cualquier rama
   en la que aparezca. Dólar no tiene un significado especial en una
   clase carácter.
  </para>
  <para>
   El significado de dólar se puede cambiar, de modo que sólo coincida
   con el final absoluto de la cadena, estableciendo la opción
   <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
   en tiempo de compilación o comparación. Esto no afecta a la declaración \Z.
  </para>
  <para>
   El significado de los caracteres circunflejo y dólar se
   cambia si la opción
   <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
   es establecida. Cuando este es el caso, conciden inmediatemente después e
   inmediatamente antes que un carácter "\n" interno, respectivamente, además
   de coincidir al principio y final de la cadena objetivo. Por ejemplo, el
   patrón /^abc$/ coincide con la cadena objetivo "def\nabc" en el modo multi-línea,
   y no en otros. Consecuentemente, los patrones que están anclados en el modo
   de una sóla línea, a causa del inicio de todas las ramas con "^", no están anclados en
   el modo multi-línea. La opción
   <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
   es ignorada si
   <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> está
   establecida.
  </para>
  <para>
   Observe que las secuencias \A, \Z, y \z se pueden usar para coincidir
   el inicio y final de la cadena objetivo en ambos modos, y si todas
   las ramas de un patrón comienzan con \A, el patrón siempre es anclado,
   sin tener en cuenta si <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>  
   está establecido o no.
  </para>
 </section>
 
 <section xml:id="regexp.reference.dot">
  <title>Punto</title>
  <para>
   Fuera de una clase carácter, un punto en el patrón coincide con
   un carácter en el sujeto, incluyendo un carácter no imprimible,
   pero no (por defecto) con una nueva línea. Si la opción
   <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
   está establecida, entonces los puntos coinciden con nuevas líneas tambíen. El
   manejo del punto es totalmente independiente del manejo de
   circunflejo y dólar, la única relación existente es que ambos
   implican caracteres de nueva línea. El punto no tiene un significado especial
   en una clase carácter.
  </para>
  <para>
   <emphasis>\C</emphasis> se puede usar para comparar un único byte. Tiene sentido
   en <emphasis>modo UTF-8</emphasis> donde el punto coincide con el carácter
   entero, el cual puede consistir en múltiples bytes.
  </para>
 </section>
 
 <section xml:id="regexp.reference.character-classes">
  <title>Clases carácter</title>
  <para>
   Un corchete de apertura inicia una clase carácter,
   finalizada por un corchete de cierre. Un corchete de
   cierre por sí solo no es especial. Si se requiere
   un corchete de cierre como un miembro de la clase, éste debería ser
   el primer carácter de información en la clase (después de un circunflejo
   inicial, si está presente) o escapado con una barra invertida.
  </para>
  <para>
   Una clase carácter coincide con un sólo carácter en el sujeto;
   el carácter debe estar en el conjunto de caracteres definido por
   la clase, a menos que el primer carácter en la clase sea un
   circunflejo, en cuyo caso el carácter sujeto no debe de estar en
   el conjunto definido por la clase. Si un circunflejo es requerido
   en realidad como un miembro de la clase, asegúrese de que no sea el
   primer carácter, o escápelo con una barra invertida.
  </para>
  <para>
   Por ejemplo, la clase carácter [aeiou] coincide con cualquier vocal
   minúscula, mientras que [^aeiou] con cualquier carácter que no sea
   una vocal minúscula. Observe que un circunflejo es sólo una
   notación conveniente para especificar los caracteres que están en
   la clase enumerando los que no están. Si no es una
   declaración: aún consume un carácter de la cadena objetivo,
   y falla si el punto actual está al final de la
   cadena.
  </para>
  <para>
   Cuando está establecida la coincidencia insensible a mayúsculas-minúculas, cualquier
   letra en una clase representa tanto su versión en mayúsculas como
   minusculas, así, por ejemplo, una clase insensible [aeiou] coincidice con "A"
   así como con "a", y una clase insensible [^aeiou] no coincide con
   "A", mientras que una versión sensible lo haría.
  </para>
  <para>
   El carácter nueva línea nunca es tratado de manera especial en
   las clases carácter, sin importar el establecimiento de la opción <link
   linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
   o <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>.
   Una clase como [^a] siempre coincidirá con una nueva línea.
  </para>
  <para>
   El carácter menos (guión) se puede usar para especificar un rango
   de caracteres en una clase carácter. Por ejemplo, [d-m]
   coincide con cualquier letra entre d y m, inclusive. Si un carácter
   - (menos) se requiere en una clase, se debe escapar con una
   barra invertida o aparecer en una posición donde no pueda ser
   interpretado como indicador de rango, típicamente como el primer o último
   carácter en una clase.
  </para>
  <para>
   No es posible tener un carácter literal "]" como el
   carácter final de un rango. Un patrón como [W-]46] es
   interpretado como una clase de dos caracteres ("W" y "-")
   seguido de una cadena literal "46]", por lo que coincidiría con "W46]" o
   "-46]". Sin embargo, si el "]" es escapado con una barra invertida
   es interpretado como el final del rango, así [W-\]46] es
   interpretado como un clase individual que contiene un rango seguido de dos
   caracteres aparte. La representación octal o hexadecimal
   de "]" también se puede usar al final del rango.
  </para>
  <para>
   Los rangos operan en la secuencia de colación de ASCII. También se pueden
   usar para caracteres especificados numéricamente, por ejemplo
   [\000-\037]. Si un rango que incluye letras se usa cuando
   se establece la coincidencia insensible a mayúsculas-minúsculas, coincide con las
   letras en cualquier caso. Por ejemplo, [W-c] es equivalente a
   [][\^_`wxyzabc], comparados insensiblemente, y si las tablas
   de caracteres para la configuración regional "fr" están siendo usadas, [\xc8-\xcb] coincide
   con caracteres E acentudos en ambos casos.
  </para>
  <para>
   Los tipos de caracteres \d, \D, \s, \S, \w, y \W también pueden
   aparecer en la clase carácter, y añaden a la clase los caracteres
   que ellos representan. Por ejemplo, [\dABCDEF] coincide con cualquier
   dígito hexadecimal. Un circunflejo se puede usar convenientemente
   con los tipos de caracteres en mayúsculas para especificar un
   conjunto de caracteres más restrictivo que el tipo de coincidencia en minúscula.
   Por ejemplo, la clase [^\W_] coincide con cualquier letra o dígito,
   excepto con el subrayado.
  </para>
  <para>
   Todos los caracteres no alfanuméricos distintos de \, -, ^ (al
   comienzo) y el ] finalizador no son especiales en una clase
   carácter, pero no es perjudicial si se escapan. El terminador
   de patrón siempre es especial y debe ser escapado cuando se usa
   dentro de una expresión.
  </para>
  <para>
   Perl soporta la notación POSIX para clases carácter. Ésta usa nombres
   encerrados entre <literal>[:</literal> y <literal>:]</literal> dentro de los corchetes. PCRE también
   soporta esta notación. Por ejemplo, <literal>[01[:alpha:]%]</literal>
   coincide con "0", "1", cualquier carácter alfabético, o "%". Los nombres de las
   clases soportadas son:
   <table>
    <title>Clases carácter</title>
    <tgroup cols="2">
     <tbody>
      <row><entry><literal>alnum</literal></entry><entry>letras y dígitos</entry></row>
      <row><entry><literal>alpha</literal></entry><entry>letras</entry></row>
      <row><entry><literal>ascii</literal></entry><entry>códigos de caracteres 0 - 127</entry></row>
      <row><entry><literal>blank</literal></entry><entry>espacio o tabulación solamente</entry></row>
      <row><entry><literal>cntrl</literal></entry><entry>caracteres de control</entry></row>
      <row><entry><literal>digit</literal></entry><entry>dígitos decimales (lo mismo que \d)</entry></row>
      <row><entry><literal>graph</literal></entry><entry>caracteres imprimibles, excluyendo el espacio</entry></row>
      <row><entry><literal>lower</literal></entry><entry>letras minúsculas</entry></row>
      <row><entry><literal>print</literal></entry><entry>caracteres imprimibles, incluyendo el espacio</entry></row>
      <row><entry><literal>punct</literal></entry><entry>caracterse imprimibles, excluyendo letras y dígitos</entry></row>
      <row><entry><literal>space</literal></entry><entry>escpacio en blanco (casi lo mismo que \s)</entry></row>
      <row><entry><literal>upper</literal></entry><entry>letras mayúsculas</entry></row>
      <row><entry><literal>word</literal></entry><entry>caracteres "word" (palabra) (lo mismo que \w)</entry></row>
      <row><entry><literal>xdigit</literal></entry><entry>dígitos hexadecimales</entry></row>
     </tbody>
    </tgroup>
   </table>
   Los caracteres <literal>space</literal> son HT (9), LF (10), VT (11), FF (12), CR (13),
   y espacio (32). Observe que esta lista incluye el caracter VT (código
   11). Esto hace que "space" sea diferente de <literal>\s</literal>, el cuál no incluye VT (por
   compatibilidad con Perl).
  </para>
  <para>
   El nombre <literal>word</literal> es una extensión de Perl, y <literal>blank</literal> es una extensión de GNU
   desde Perl 5.8. Otra extensión de Perl es la negación, indicada
   por un carácter <literal>^</literal> después de los dos puntos. Por ejemplo,
   <literal>[12[:^digit:]]</literal> coincide con "1", "2", o cualquier no-digito.
  </para>
  <para>
   En el modo UTF-8, los caracteres con valores mayores que 128 no coinciden con ninguna
   de las clases carácter POSIX.
  </para>
 </section>
 
 <section xml:id="regexp.reference.alternation">
  <title>Alternancia</title>
  <para>
   Los caracteres barra vertical se usan para separar patrones
   alternativos. Por ejemplo, el patrón
   <literal>gilbert|sullivan</literal>
   coincide con "gilbert" o con "sullivan". Pueden aparecer
   cualquier número de alternativas, y se permite una alternativa vacía
   (coincidiendo con la cadena vacía). El proceso de comparación prueba
   cada alternativa sucesivamente, de izquierda a derecha, y la primera
   que tenga éxito se usa. Si las alternativas están dentro de un
   sub-patrón (definido más adelante), "tener éxito" significa coincidir con el
   resto del patrón principal así como con la alternativa en el
   sub-patrón.
  </para>
 </section>
 
 <section xml:id="regexp.reference.internal-options">
  <title>Ajuste de opciones internas</title>
  <para>
   Los ajustes de <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>, 
   <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>,  
   <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
   <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>,
   <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link>,
   <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
   y PCRE_DUPNAMES se pueden cambiar desde dentro de un patrón por
   una secuencia de letras de opciones de Perl encerradas entre "(?" y
   ")". Las letras de opciones son:
   
   <table>
    <title>Letras de opciones internas</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry><literal>i</literal></entry>
       <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link></entry>
      </row>
      <row>
       <entry><literal>m</literal></entry>
       <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link></entry>
      </row>
      <row>
       <entry><literal>s</literal></entry>
       <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link></entry>
      </row>
      <row>
       <entry><literal>x</literal></entry>
       <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link></entry>
      </row>
      <row>
       <entry><literal>U</literal></entry>
       <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link></entry>
      </row>
      <row>
       <entry><literal>X</literal></entry>
       <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link></entry>
      </row>
      <row>
       <entry><literal>J</literal></entry>
       <entry>para <link linkend="reference.pcre.pattern.modifiers">PCRE_INFO_JCHANGED</link></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   Por ejemplo, (?im) establece la coincidencia insensible a mayúsculas-minúsculas,
   y multi-línea. También es posible eliminar estas opciones precediendo la letra
   con un guión, y un establecimiento y eliminación combinados como
   (?im-sx), el cual establece <link
   linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link> y
   <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
   mientras que elimina <link
   linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> y
   <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>,
   también está permitido. Si una letra aparece tanto antes como después del
   guión, la opción es eliminada.
  </para>
  <para>
   Cuando un cambio de opción sucede en el nivel superior (es decir, fuera
   de sub-patrones entre paréntesis), el cambio se aplica al resto del
   patrón que sigue. Así, <literal>/ab(?i)c/</literal> coincide sólo con "abc"
   y "abC".
  </para>
  <para>
   Si un cambio de opción sucede dentro de un sub-patrón, el efecto
   es diferente. Esto es un cambio de comportamiento en Perl 5.005.
   Un cambio de opción dentro de un sub-patrón afecta sólo a aquella parte
   del sub-patrón que le sigue, por lo que
   
   <literal>(a(?i)b)c</literal>
   
   coincide con abc y aBc y ninguna otra cadena más (asumiendo que no se usa
   <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>).
   Por medio de esto, las opciones pueden ser producidas para tener diferentes ajustes en
   diferentes partes del patrón. Cualquier cambio hecho en un alternativa
   continúa en ramas subsiguientes dentro del mismo sub-patrón. Por
   ejemplo,
   
   <literal>(a(?i)b|c)</literal>
   
   coincide con "ab", "aB", "c", y "C", incluso cuando al coincidir con
   "C" la primera rama es abandonada después de establecer la opción.
   Esto es porque los efectos del establecimiento de opciones ocurren en
   tiempo de compilación. De otro modo habría algunos comportamiento extraños.
  </para>
  <para>
   Las opciones específicas de PCRE <link 
   linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link> y  
   <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link> se pueden
   cambiar de la misma forma que las opciones compatibles con Perl
   usando los caracteres U y X respectivamente. La bandera
   de ajuste (?X) es especial ya que debe producirse siempre antes
   de que se active cualquier otra característica en el patrón,
   incluso si está en el nivel superior. Lo mejor es ponerlo al principio.
  </para>
 </section>
 
 <section xml:id="regexp.reference.subpatterns">
  <title>Sub-patrones</title>
  <para>
   Los sub-patrones están delimitados por paréntesis,
   los cuales pueden estar anidados. Marcar parte de un patrón como un sub-patrón
   hace dos cosas:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Localiza un conjunto de alternativas. Por ejemplo, el
     patrón <literal>cata(rata|pulta|)</literal> coincide con una de las palabras "cata",
     "catarata", o "catapulta". Sin los paréntesis, coincidiría con "catarata",
     "pulta" o la cadena vacía.
    </para>
   </listitem>
   <listitem>
    <para>
     Establece el sub-patrón como un sub-patrón de captura (como se definió antes).
     Cuando el patrón completo coincide, esa porción de la cadena objetivo
     que coincidió con el sub-patrón es devuelta la llamador mediante
     el argumento <emphasis>ovector</emphasis> de <function>pcre_exec</function>.
     Los paréntesis de apertura se cuentan de izquierda a derecha (comenzando por 1) para
     obtener el número de los sub-patrones de captura.
    </para>
   </listitem>
  </orderedlist>
  <para>
   Por ejemplo, si la cadena "el rojo amanecer" se compara con
   el patrón
   
   <literal>el ((rojo|oscuro) (amanecer|atarceder))</literal>
   
   las cadenas capturadas son "rojo amanecer", "rojo", y "amanecer",
   y son numeradas como 1, 2, y 3.
  </para>
  <para>
   El hecho de que los simples paréntesis lleven a cabo dos funciones no es
   siempre útil. Con frecuencia se presenta el caso en el que un
   sub-patrón de agrupamiento se requiere sin la necesidad de una captura. Si un
   paréntesis de apertura es seguido por "?:", el sub-patrón no
   realiza ninguna captura, y no es contado cuando se computa el
   número de cualquier sub-patrón de captura subsiguiente. Por ejemplo,
   si la cadena "el oscuro atardecer" se compara con el
   patrón
   
   <literal>the ((?:rojo|oscuro) (amanecer|atarceder))</literal>
   
   las sub-cadenas capturadas son "oscuro atardecer" y "atarceder", y
   son numeradas como 1 y 2. El número máximo de sub-cadenas capturadas
   es de 99, y el número máximo de todos los sub-patrones,
   tanto de captura como de no-captura, es de 200.
  </para>
  <para>
   Como abreviación conveniente, si se necesita cualquier establecimiento
   de opciones al inicio de un sub-patrón que no sea de captura, las
   letras de opciones pueden aparecen entre el "?" y ":". Así
   lo dos patrones
  </para>
  
  <informalexample>
   <programlisting>
<![CDATA[
(?i(?i:lunes|martes)
(?:(?i)lunes|martes)
]]>
   </programlisting>
  </informalexample>
  
  <para>
   coinciden exactamente con el mismo conjunto de cadenas. Dado que las ramas
   alternativas son probadas de izquierda a derecha, y las opciones no
   se reinician hasta que se alcance el final del sub-patrón, el establecimiento
   de una opción en una rama afecta a las ramas siguientes, por lo que
   los patrones de arriba coinciden tanto con "MARTES" como con "Lunes".
  </para>
  
  <para>
   Es posible nombrar un sub-patrón usando la sintaxis
   <literal>(?P&lt;nombre&gt;patrón)</literal>. Este sub-patrón será entonces
   indexado en el array de coincidencias mediante su posición numérica normal y
   mediante su nombre también. PHP 5.2.2 introdujo dos sintaxis alternativas
   <literal>(?&lt;nombre&gt;patrón)</literal> y <literal>(?'nombre'patrón)</literal>.
  </para>
  
  <para>
   A veces es necesario tener múltiples coincidencias, pero alternando
   subgrupos en una expresión regular. Normalmente, a cada subgrupo se le asignaría
   su propio número de retro-referencia incluso si sólo uno de ellos coincidiera.
   Para superar esto, la sintaxis <literal>(?|</literal> permite
   tener números duplicados. Considere la siguiente expresión regular comparada con la
   cadena <literal>Sunday</literal>:
  </para>
  
  <informalexample>
   <programlisting>
<![CDATA[(?:(Sat)ur|(Sun))day]]>
   </programlisting>
  </informalexample>
  
  <para>
   Aquí <literal>Sun</literal> se guarda en la retro-referencia 2, mientras
   que la retro-referencia 1 está vacía. La comparación cede <literal>Sat</literal> a la
   retro-referncia 1 mientras que la retro-referncia 2 no existe. Cambiar el patrón
   para usar <literal>(?|</literal> corrige este problema:
  </para>
  
  <informalexample>
   <programlisting>
<![CDATA[(?|(Sat)ur|(Sun))day]]>
   </programlisting>
  </informalexample>
  
  <para>
   Al usar este patrón, tanto <literal>Sun</literal> como <literal>Sat</literal>
   serían almacenados en la retro-referencia 1.
  </para>
 </section>
 
 <section xml:id="regexp.reference.repetition">
  <title>Repetición</title>
  <para>
   La repetición se especifica mediante cuantificadores, los cuales pueden ir detrás
   de cualquiera de los siguientes elementos:
   
   <itemizedlist>
    <listitem><simpara>un único carácter, posiblemente escapado</simpara></listitem>
    <listitem><simpara>el meta-carácter . (punto)</simpara></listitem>
    <listitem><simpara>una clase carácter</simpara></listitem>
    <listitem><simpara>una retro-referencia (véase la siguiente sección)</simpara></listitem>
    <listitem><simpara>un sub-patrón entre paréntesis (a menos que haya una declaración -
     véase más adelante)</simpara></listitem>
   </itemizedlist>
  </para>
  <para>
   El cuantificador de repetición general especifíca un mínimo y
   un máximo del número de coincidencias pertmitidas, dándose los dos
   números entre llaves, separados por una coma.
   Los números deben ser menores que 65536, y el primero debe ser
   menor o igual que el segundo. Por ejemplo:
   
   <literal>z{2,4}</literal>
   
   coincide con "zz", "zzz", o "zzzz". Una llave de cierre por sí misma
   no es un carácter especial. Si se omite el segundo número,
   pero la coma está presente, no hay límite superior; si el
   segundo número y la coma se omiten, el cuantificador
   especifica un número exacto de coincidencias requeridas. Así
   
   <literal>[aeiou]{3,}</literal>
   
   coincide al menos con 3 vocales sucesivas, pero puede coincidir con
   muchas más, mientras que
   
   <literal>\d{8}</literal>
   
   coincide exactamente con 8 dígitos. Una llave que
   aparezca en una posición donde no se permite un cuantificador, o
   una que no coincida con la sintaxis de un cuantificador, se toma
   como un carácter literal. Por ejemplo, {,6} no es un cuantificador,
   sino una cadena literal de cuatro caracteres.
  </para>
  <para>
   El cuantificador {0} está permitido, lo que provoca que la expresión se
   comporte como si el elemento anterior y el cuantificador no estuvieran
   presentes.
  </para>
  <para>
   Por conveniencia (y compatibilidad histórica) los tres
   cuantificadores más comunes tiene como abreviatura un carácter simple:
   
   <table>
    <title>Cuantificadores de carácter simple</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry><literal>*</literal></entry>
       <entry>equivale a <literal>{0,}</literal></entry>
      </row>
      <row>
       <entry><literal>+</literal></entry>
       <entry>equivale a <literal>{1,}</literal></entry>
      </row>
      <row>
       <entry><literal>?</literal></entry>
       <entry>equivale a <literal>{0,1}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   Es posible construir bucles infinitos mediante un
   sub-patrón que pueda no coincidir con caracteres, seguido de un cuantificador
   que no tenga límite superior, por ejemplo:
   
   <literal>(a?)*</literal>
  </para>
  <para>
   Versiones anteriores de Perl y PCRE solían dar un error en
   tiempo de ejecución para tales patrones. Sin embargo, ya que hay
   casos donde esto puede ser útil, tales patrones se aceptan ahora,
   pero si cualquier repetición de un sub-patrón de hecho no coincide
   con caracteres, el bucle se abandona a la fuerza.
  </para>
  <para>
   Por defecto, los cuantificadores son "codiciosos", es decir, comparan
   todo lo posible (hasta el número máximo de veces permitido),
   sin provocar que el resto del patrón falle.
   El ejemplo clásico de cómo esto da problemas es al
   intentar coincidir comentarios de programas en C. Éstos aparecen entre
   las secuencias /* y */ y dentro de la secuencia, pueden aparecer
   caracteres * y / individuales. Un intento de coincidir comentarios en C
   aplicando el patrón
   
   <literal>/\*.*\*/</literal>
   
   a la cadena
   
   <literal>/* primer comentario */  no comentado  /* segundo comentario */</literal>
   
   falla, ya que coincide con la cadena completa debido a
   que el elemento .* es codicioso.
  </para>
  <para>
   Sin embargo, si un cuantificador es seguido por un signo de interrogación,
   entonces se convierte en perezoso, coincidiendo el mínimo número
   de veces posible, así el patrón
   
   <literal>/\*.*?\*/</literal>
   
   funciona de forma correcta con los comentarios en C. Por lo demás,
   el significado de los diferentes cuantificadores no varía, sólo el número
   de coincidencias preferidas. No confunda este uso del
   signo de interrogación con su uso como un cuantificador por derecho propio.
   Ya que tiene dos usos, puede aparecer a veces doble, como
   en
   
   <literal>\d??\d</literal>
   
   que coincide con un dígito preferentemente, pero puede coincidir con dos si
   esa es la única manera de que el resto del patrón coincida.
  </para>
  <para>
   Si la opción <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>  
   se establece (una opción que no está
   disponible en Perl), los cuantificadores no son codiciosos por
   defecto, pero puede hecérselos codiciosos si les sigue
   un signo de interrogación. En otras palabras, invierte el
   comportamiento por defecto.
  </para>
  <para>
   Los cuantificadores seguidos de <literal>+</literal> son "posesivos". Consumen
   tantos caracteres como les es posible y no retornan para coincidir con el resto del
   patrón. Así, <literal>.*abc</literal> coincide con "aabc" pero
   <literal>.*+abc</literal> no, ya que <literal>.*+</literal> consume la
   cadena entera. Se pueden usar los cuantificadores posesivos
   para acelerar el procesamiento.
  </para>
  <para>
   Cuando un sub-patrón entre paréntesis es cuantificado con un mínimo
   de cuenta de repeticiones que es mayor que 1 o con un máximo limitado,
   se necesita más capacidad de almacenamiento para el patrón compilado, en
   proporción al tamaño del mínimo o máximo.
  </para>
  <para>
   Si un patrón comienza con .* o .{0,} y la opción <link 
   linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> 
   (equivalente a la de Perl /s) está establecida, así permitiendo al . (punto)
   coincidir con nuevas líneas, entonces el patrón está implícitamente anclado,
   ya que cualquier cosa que haya a continuación se seguirá intentando comparar
   con cada posición de carácter en la cadena objetivo, por lo que no sirve de nada
   volver a intentar la comparación completa desde cualquier posición después de la primera.
   PCRE trata estos patrones como si estuvieran precedidos por \A.
   En los casos donde se sabe que la cadena objetivo no contiene
   nuevas líneas, vale la pena establecer <link 
   linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> cuando el
   patrón comienza con .* para
   obtener esta optimización, o
   alternativamente, usar ^ para indicar explícitamente el anclado.
  </para>
  <para>
   Cuando se repite un sub-patrón de captura, el valor capturado
   es la sub-cadena que coincide con la iteración final. Por ejemplo, después de que
   
   <literal>(tweedle[dume]{3}\s*)+</literal>
   
   se haya comparado con "tweedledum tweedledee" el valor del sub-patrón de
   captura es "tweedledee". Sin embargo, si hay sub-patrones de captura
   anidados, los valores capturados correspondientes
   pueden haber sido establecidos en iteraciones previas. Por ejemplo,
   después de que
   
   <literal>/(a|(b))+/</literal>
   
   se compare con "aba", el valor del segundo sub-patrón de captura es
   "b".
  </para>
 </section>
 
 <section xml:id="regexp.reference.back-references">
  <title>Retro-referencias</title>
  <para>
   Fuera de una clase carácter, una barra invertida seguida por un dígito
   mayor que 0 (y posiblemente más dígitos) es una retro-referencia
   a un sub-patrón de captura anterior (esto es a su izquierda)
   del patrón, siempre que hayan habido tantas capturas entre
   paréntesis previas a la izquierda.
  </para>
  <para>
   Sin embargo, si el número decimal que sigue a la barra invertida es
   menor que 10, siempre es tomado como una retro-referencia, y
   produce un error sólo si no hay tantas capturas
   anteriores entre paréntesis en el patrón completo. En otras palabras, los
   paréntesis que son referenciados no necesitan estar a la izquierda de
   la referencia para números menores que 10.
   Una "retro-referencia hacia adelante" puede tener sentido cuando está involucrada
   una repetición y el sub-patrón de la derecha ha participado
   en una iteración anterior. Véase la sección anterior
   titulada "Barra invertida" para más detalles acerca del manejo de
   los dígitos que siguen a una barra invertida.
  </para>
  <para>
   Una retro-referencia coincide con cualquier cosa que en realidad haya coincidido
   con el sub-patrón de captura en la cadena objetivo actual, más que con
   cualquier cosa que coincida en el sub-patrón mismo. Así, el patrón
   
   <literal>(abraz|apreci)o de un \1ador</literal>
   
   coindice con "abrazo de un abrazador" y con "aprecio de un apreciador",
   pero no con "abrazo de un apreciador". Si la coincidencia sensible a
   mayúsculas-minúsculas está en vigor en el momento de la retro-referencia,
   la distinción de letras es relevante. Por ejemplo,
   
   <literal>((?i)bla)\s+\1</literal>
   
   coincide con "bla bla" y "BLA BLA", pero no con "BLA bla", incluso
   si el patrón de captura original es comparado de forma insensible a
   mayúsculas-minúsculas.
  </para>
  <para>
   Puede haber más de una retro-referencia hacia el mismo sub-patrón.
   Si un sub-patrón no ha sido usado en realidad en una
   coincidencia en particular, cualquier retro-referencia a él siempre
   falla. Por ejemplo, el patrón
   
   <literal>(a|(bc))\2</literal>
   
   siempre falla si comienza coincidiendo con "a" en vez de con "bc".
   Ya que puede haber hasta 99 retro-referencias, todos los dígitos
   que siguen a la barra invertida se toman como parte de un número
   posible de retro-referencias. Si el patrón continúa con un carácter
   dígito, entonces se deben usar algunos delimitadores para finalizar la
   retro-referencia. Si la opción <link 
   linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> está
   establecida, éste puede ser un espacio en blanco. De otra manera se puede usar un comentario vacío.
  </para>
  <para>
   Una retro-referencia que sucede dentro de los paréntesis a los cuales
   se refiere, falla cuando el sub-patrón se usa primero, así, por
   ejemplo, (a\1) nunca coincide. Sin embargo, tales referencias pueden
   ser útiles dentro de sub-patrones repetidos. Por ejemplo, el patrón
   
   <literal>(a|b\1)+</literal>
   
   coincide con cualquier número de "a"es y tambíen con "aba", "ababba", etc. En
   cada iteración del subpatrón, la retro-referencia coincide con
   el cadena correspondiente a la iteración anterior.
   Para que esto funcione, el patrón debe ser tal
   que la primera iteración no necesite coincidir con la retro-referencia.
   Esto se puede lograr usando alternancia, como en el
   ejemplo anterior, o mediante un cuantificador con un mínimo de cero.
  </para>
  <para>
   A partir de PHP 5.2.2, la secuencia de escape <literal>\g</literal> se puede
   usar para referenciar subpatrones de forma absoluta y relativa.
   Esta secuencia de escape debe estar seguida por un número sin signo o un número
   negativo, opcionalmente encerrado entre llaves. Las secuencias <literal>\1</literal>,
   <literal>\g1</literal> y <literal>\g{1}</literal> son sinónimas
   unas de otras. El uso de este patrón con un número sin signo puede
   ayudar a eliminar la ambigüedad inherente al usar dígitos seguidos de una
   barra invertida. La secuencia ayuda a distinguir retro-referencias de caracteres
   octales y también hace más fácil tener una retro-referencia seguida
   por un número literal, p.ej. <literal>\g{2}1</literal>.
  </para>
  <para>
   El uso de la secuencia <literal>\g</literal> con un número negativo
   significa una referencia relativa. Por ejemplo, <literal>(foo)(bar)\g{-1}</literal>
   coincidiría con la secuencia "foobarbar" y <literal>(foo)(bar)\g{-2}</literal>
   coincidiría con "foobarfoo". Esto puede ser útil en patrones largos como una alternativa
   de seguir la pista del número de subpatrones para referenciar
   un subpatrón previo específico.
  </para>
  <para>
   Las retro-referencias a sub-patrones nominados se pueden lograr mediante
   <literal>(?P=nombre)</literal> o, desde PHP 5.2.2, también mediante
   <literal>\k&lt;nombre&gt;</literal> o <literal>\k'nombre'</literal>.
   Además, PHP 5.2.4 añadió soporte para <literal>\k{nombre}</literal>
   y <literal>\g{nombre}</literal>.
  </para>
 </section>
 
 <section xml:id="regexp.reference.assertions">
  <title>Declaraciones</title>
  <para>
   Una declaración es una comprobación de los caracteres siguientes o
   anteriores al punto de coincidencia actual que en realidad no
   consumen carácter alguno. Las declaraciones simples codificadas como \b,
   \B, \A, \Z, \z, ^ y $ están descritas anteriormente. Las declaraciones
   más complicadas están codificadas como sub-patrones. Hay dos tipos:
   aquéllas que <emphasis>buscan hacia delante</emphasis> desde punto actual de la
   cadena objetivo, y aquéllas que <emphasis>buscan hacia atrás</emphasis> desde él.
  </para>
  <para>
   Un patrón declaración es comparado de la forma habitual, excepto
   que no causa que la posición actual de coincidencia
   cambie. Las declaraciones de <emphasis>búsqueda hacia delante</emphasis> comienzan con
   (?= para declaraciones positivas y con (?! para declaraciones negativas. Por ejemplo,
   
   <literal>\w+(?=;)</literal>
   
   coincide con una palabra seguida de un punto y coma, pero no incluye
   el punto y coma en la coincidencia, y
   
   <literal>foo(?!bar)</literal>
   
   coincide con cualquier incidencia de "foo" que no esté seguida de
   "bar". Observe que el patrón aparentemente similar
   
   <literal>(?!foo)bar</literal>
   
   no encuentra una incidencia de "bar" que esté precedida por
   algo distinto de "foo"; no encuentra ninguna incidencia de "bar"
   en absoluto, ya que la declaración (?!foo) es siempre &true;
   cuando los tres caracteres siguientes son "bar". Se necesita una
   declaración de búsqueda hacia atrás para conseguir este efecto.
  </para>
  <para>
   Las declaraciones de <emphasis>búsqueda hacia atrás</emphasis> comienzan con (?&lt;=
   para declaraciones positivas y con (?&lt;! para declaraciones negativas. Por ejemplo,
   
   <literal>(?&lt;!foo)bar</literal>
   
   encuentra una incidencia de "bar" que no esté precedida por
   "foo". El contenido de una declaración de búsqueda hacia atrás está restringido
   de tal manera que todas las cadenas que se comparen con ella deben tener una longitud
   fija. Sin embargo, si hay varias alternativas, no es necesario que
   tengan todas la misma longitud fija. Así,
   
   <literal>(?&lt;=buey|burro)</literal>
   
   está permitido, pero
   
   <literal>(?&lt;!toros?|vacas?)</literal>
   
   produce un error en tiempo de compilación. Las ramas que se comparan con cadenas
   de diferente longitud están permitidas sólo en el nivel superior de
   una declaración de búsqueda hacia atrás. Esto es una extensión comparado con
   Perl 5.005, la cual requiere que todas las ramas a comparar tengan la misma
   longitud de cadena. Una declaración como
   
   <literal>(?&lt;=ab(c|de))</literal>
   
   no está permitida porque su rama del nivel superior puede
   coincidir con dos longitudes diferentes, pero es aceptable si se reescribe
   para usar dos ramas del nivel superior:
   
   <literal>(?&lt;=abc|abde)</literal>
   
   La implementación de las declaraciones de búsqueda hacia atrás es, para cada
   alternativa, retroceder temporalmente la posición actual
   por el ancho fijo y después intentar coincidir. Si no hay
   suficientes caracteres antes de la posición actual, la
   comparación está condenada a fallar. Las declaraciones de búsqueda hacia atrás junto
   con los sub-patrones de una sóla aplicación pueden ser particularmente útiles para
   comparaciones con los finales de las cadenas; se da un ejemplo al final de la
   sección de sub-patrones de una sóla aplicación.
  </para>
  <para>
   Varias declaraciones (de cualquier tipo) pueden producirse en suceción.
   Por ejemplo,
   
   <literal>(?&lt;=\d{3})(?&lt;!999)foo</literal>
   
   coincide con "foo" precedido de tres dígitos que no sean "999".
   Nótese que cada una de las declaraciones es aplicada
   en el mismo punto de la cadena objetivo. Primero, se
   verifica que los tres caracteres previos son todos dígitos,
   depués se verifica que esos mismos tres caracteres no sean
   "999". Este patrón no coincide con "foo" precedido de seis
   caracteres, los primeros de los cuales son dígitos y los tres últimos
   de éllos no son "999". Por ejemplo, no coincide con
   "123abcfoo". Un patrón que hace eso es
   
   <literal>(?&lt;=\d{3}...)(?&lt;!999)foo</literal>
  </para>
  <para>
   Esta vez, la primera declaración examina los seis caracteres
   precedentes, verificando que los tres primeros son dígitos, y
   después, la segunda declaración verifica que los tres caracteres
   anteriores no son "999".
  </para>
  <para>
   Las declaraciones pueden estar anidadas en cualquier combianción. Por ejemplo,
   
   <literal>(?&lt;=(?&lt;!foo)bar)baz</literal>
   
   coincide con una incidencia de "baz" que está precedida por "bar",
   la cual a su vez no está precedida por "foo", mientras que
   
   <literal>(?&lt;=\d{3}...(?&lt;!999))foo</literal>
   
   es otro patrón que coincide con "foo" precedido por tres
   dígitos y otros tres caracteres cualesquiera que no sean "999".
  </para>
  <para>
   Los sub-patrones declarativos no son sub-patrones de captura, y no
   se pueden repetir, ya que no tiene sentido declarar la misma
   cosa varias veces. Si cualquier tipo de declaración contiene
   sub-patrones de captura dentro de ella, éstos son contados con el
   propósito de numerar los sub-patrones de captura en el patrón
   completo. Sin embargo, la captura de sub-cadenas se realiza sólo
   para declaraciones positivas, ya que no tiene sentido para
   declaraciones negativas.
  </para>
  <para>
   Las declaraciones cuentan para el máximo de 200 sub-patrones
   entre paréntesis.
  </para>
 </section>
 
 <section xml:id="regexp.reference.onlyonce">
  <title>Sub-patrones de una sóla aplicación</title>
  <para>
   Con las repeticiones maximizadoras y minimizadoras, el fallo de
   lo que se encuentra a continuación causa normalmente que la repetición del elemento sea
   re-evaluada para ver si un número diferente de repeticiones permite que el
   resto del patrón coincida. A veces es útil prevenir
   esto, tanto para cambiar la naturaleza de la comparación, como
   para ocasionar que falle antes (ya que de otra manera ocurriría el fallo después)
   cuando el autor del patrón sabe que no tiene sentido seguir.
  </para>
  <para>
   Considere, por ejemplo, el patrón \d+foo cuando se aplica a
   la línea objetivo
   
   <literal>123456bar</literal>
  </para>
  <para>
   Después de coincidir los 6 dígitos y luego fallar al coincidir con "foo",
   la acción habitual del comparador es volver a intentarlo con sólo 5
   dígitos, coincidiendo con el elemento \d+, y después con 4, y así sucesivamente,
   antes de que, por último, falle. Los sub-patrones de una sóla aplicación proporcionan el
   medio para especificar que una vez que una porción del patrón ha
   coincidido, no será re-evaluado de esta forma, por lo que el
   comparador se rendirá inmediatamente al fallar la comparación de "foo"
   la primera vez. La notación es otro tipo de paréntesis
   especiales, comenzando con (?&gt; como en este ejemplo:
   
   <literal>(?&gt;\d+)bar</literal>
  </para>
  <para>
   Este tipo de paréntesis "bloquea" la parte del patrón
   que lo contiene una vez haya coincidido, y un fallo dentro
   del patrón evita que éste retroceda sobre sí mismo.
   El retroceso hacia elementos previos al sub-patrón funciona normalmente, después de todo.
  </para>
  <para>
   Una descripción alternativa es que un sub-patrón de este tipo
   coincide con la cadena de caracteres que coincidiría con un patrón
   idéntico independiente, si está anclado en el punto actual
   de la cadena objetivo.
  </para>
  <para>
   Los sub-patrones de una sóla aplicación no son sub-patrones de captura. Los casos
   sencillos como el anterior se pueden tomar como una repetición
   maximizadora que debe tragar todo lo que pueda. Así,
   mientras que \d+ y \d+? están preparados para adaptarse al número de
   dígitos que comparan para hacer que el resto del patrón coincida,
   (?&gt;\d+) sólo puede conincidir una secuencia completa de dígitos.
  </para>
  <para>
   Esta construcción puede, por supuesto, contener arbitrariamente sub-patrones
   complicados, y pueden estar anidados.
  </para>
  <para>
   Los sub-patrones de una sóla aplicación se pueden usar junto con
   declaraciones de búsqueda hacia atrás para especificar una comparación eficiente
   al final de la cadena objetivo. Considere un simple patrón como
   
   <literal>abcd$</literal>
   
   cuando se aplica a una cadena larga la cual no coincide. Ya que
   la comparación se lleva a cabo de izquierda a derecha, PCRE buscará
   cada "a" en el sujeto y después mirará si lo siguiente coincide con el
   resto del patrón. Si el patrón se especifica así
   
   <literal>^.*abcd$</literal>
   
   el .* inicial coincide con la cadena entera primero, pero
   cuando esto falla (debido a que no hay una "a" siguiente),
   retrocede para comparar todos los caracteres excepto el último, después todos
   excepto los dos últimos, y así sucesivamente. Una vez más la búsqueda
   de "a" cubre la cadena entera, de derecha a izquierda, por lo que
   no estamos en mejores circunstancias. Sin embargo, si el patrón se escribe así
   
   <literal>^(?>.*)(?&lt;=abcd)</literal>
   
   entonces no puede haber retroceso para el elemento .* ; sólo puede
   coincidir con la cadena entera. La subsiguiente declaración de búsqueda
   hacia atrás realiza una única comprobación sobre los últimos cuatro caracteres. Si
   falla, la comparación falla inmediatamente. Para cadenas largas,
   este enfoque produce una diferencia significativa en el tiempo de procesamiento.
  </para>
  <para>
   Cuando un patrón contiene una repetición ilimitada dentro de un sub-patrón
   que puede repetirse un número ilimitado de veces,
   el uso de un sub-patrón de una sóla aplicación es la única manera de
   evitar que algunas comparaciones fallidas tomen mucho tiempo.
   El patrón
   
   <literal>(\D+|&lt;\d+>)*[!?]</literal>
   
   compara un número ilimitado de sub-cadenas que consisten
   en algo que no sea un dígito, o dígitos encerrados entre &lt;>, seguido de
   ! o ?. Cuando coincide, se ejecuta rápidamente. Sin embargo, si
   se aplica a
   
   <literal>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</literal>
   
   toma mucho tiempo antes de informar del fallo. Esto es
   porque la cadena puede ser dividida entre las dos repeticiones de
   muchas maneras, y todo tiene que ser probado. (En el ejemplo
   se usó [!?] en vez de un carácter único al final,
   ya que PCRE y Perl están optimizados de forma que permiten
   que se falle rápidamente cuando se usa un carácter único. Ambos
   recuerdan el último carácter único que se requiere para una
   coincidencia, y falla antes si no está presente en la cadena.)
   Si el patrón se cambia a
   
   <literal>((?>\D+)|&lt;\d+>)*[!?]</literal>
   
   las secuencias de los "no-dígitos" no pueden romperse, y el fallo ocurre rápidamente.
  </para>
 </section>
 
 <section xml:id="regexp.reference.conditional">
  <title>Sub-patrones condicionales</title>
  <para>
   Es posible hacer que el proceso de comparación obedezca a un sub-patrón
   condicionalmente o que elija entre dos sub-patrones
   alternativos, dependiendo del resultado de una declaración o
   de si un sub-patrón de captura previo coincidió o no. Las
   dos formas posibles de un sub-patrón condicional son
  </para>
  
  <informalexample>
   <programlisting>
<![CDATA[
(?(condición)patrón-sí)
(?(condición)patrón-sí|patrón-no)
]]>
   </programlisting>
  </informalexample>
  <para>
   Si la condición es satisfecha, se usa el patrón-sí; de otro modo
   se usa el patrón-no (si está presente). Si hay más
   de dos alternativas en el sub-patrón, se producirá un error en
   tiempo de compilación.
  </para>
  <para>
   Hay dos tipos de condiciones. Si el texto entre los
   paréntesis consisite en una secuencia de dígitos, la
   condición es satisfecha si el sub-patrón de captura de ese
   número ha coincidido anteriormente. Considere el siguiente patrón,
   el cual contiene espacios en blanco no significativos para hacerlo
   más legible (se asume la opción <link 
   linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>)
   y para dividirlo en tres partes para facilitar su discusión:
   
   <literal>( \( )?    [^()]+    (?(1) \) )</literal>
  </para>
  <para>
   La primera parte compara un paréntesis de apertura opcional, y
   si el carácter está presente, lo establece como la primera sub-cadena
   capturada. La segunda parte compara uno o más caracteres
   que no sean paréntesis. La tercera parte es un patrón
   condicional que examina el primer conjunto de paréntesis
   coincididos o no. Si lo fueron, es decir, si el sujeto comenzó
   con un paréntesis de apertura, la condición es &true;, y así
   el patrón-sí se ejecuta y es requerido un paréntesis de
   cierre. De otra manera, ya que el patrón-no no está presente, el
   subpatrón no coincidirá con nada. En otras palabras, este patrón
   coincide con una secuencia que no tenga paréntesis, opcionalmente encerrada
   entre paréntesis.
  </para>
  <para>
   Si la condición es la cadena <literal>(R)</literal>, se satisface si
   ha sido hecha una llamada recursiva al patrón o sub-patrón. En el "nivel
   superior", la condición es falsa.
  </para>
  <para>
   Si la condición no es una secuencia de dígitos o (R), debe de ser una
   declaración. Ésta puede ser una declaración de búsqueda hacia delante o
   hacia atrás, negativa o positiva. Considere este patrón, conteniendo de nuevo
   espacios en blanco no significativos, y con dos alternativas en la segunda
   línea:
  </para>
  
  <informalexample>
   <programlisting>
<![CDATA[
(?(?=[^a-z]*[a-z])
\d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )
]]>
   </programlisting>
  </informalexample>
  <para>
   La condición es una declaración de búsqueda hacia delante positiva que compara
   una secuencia opcional de algo que no sean letras seguida de una letra. En
   otras palabras, comprueba la presencia de al menos una
   letra en el sujeto. Si se encuentra una letra, el sujeto se
   compara con la primera alternativa; de otro modo se compara
   con la segunda. Este patrón coincide con cadenas en
   una de las dos formas dd-aaa-dd o dd-dd-dd, donde aaa son
   letras y dd son dígitos.
  </para>
 </section>
 
 <section xml:id="regexp.reference.comments">
  <title>Comentarios</title>
  <para>
   La secuencia (?#  marca el inicio de un comentario que
   continúa hasta el siguiente paréntesis de cierre. Los paréntesis
   anidados no están permitidos. Los caracteres que componen un
   comentario no toman parte a la hora de una comparación del patrón.
  </para>
  <para>
   Si la opción <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>  
   está establecida, un carácter # sin escapar fuera de una clase carácter
   inicia un comentario que continúa hasta el siguiente carácter de nueva línea
   del patrón.
  </para>
 </section>
 
 <section xml:id="regexp.reference.recursive">
  <title>Patrones recursivos</title>
  <para>
   Considere el problema de comparar una cadena entre paréntesis,
   permitiendo paréntesis anidados ilimitados. Sin el uso de
   la recursividad, lo mejor que se puede hacer es usar un patrón
   que compare hasta alguna profundidad fija de anidamiento. No es
   posible manejar una profundidad de anidamiento arbitraria. Perl 5.6 ha
   proporcionado una herramienta experimental que permite a las expresiones
   regulares actuar recursivamente (entre otras cosas). El elemento
   especial (?R) es proporcionado para el caso específico de la recursividad. 
   Este patrón de PCRE soluciona el problema de los paréntesis (se asume que la
   opción <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
   está establecida por lo que los espacios en blanco se
   ignoran):
   
   <literal>\( ( (?>[^()]+) | (?R) )* \)</literal>
  </para>
  <para>
   Primero se compara un paréntesis de apertura. Después compara cualquier
   número de sub-cadenas que pueden ser tanto una secuencia de algo que no sean
   paréntesis como una comparación recursiva del patrón mismo
   (esto es, una sub-cadena con los paréntesis correctos). Finalmente hay
   un paréntesis de cierre.
  </para>
  <para>
   Este patrón de ejemplo en particular contiene repeticiones anidadas
   ilimitadas, y así, el uso de un sub-patrón de una sóla aplicación para comparar
   cadenas que no contengan paréntesis es importante cuando se aplica
   el patrón a cadenas que no coinciden. Por ejemplo, cuando
   se aplica a
   
   <literal>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</literal>
   
   produce "no hay conicidencias" rápidamente. Sin embargo, si no se usa un sub-patrón 
   de una sóla aplicación, la comparación se ejecuta realmente durante
   mucho tiempo ya que hay muchas maneras diferentes de que las repeticiones + y *
   se puedan repartir el sujeto, y todas tienen que ser comprobadas
   antes de que se informe del fallo.
  </para>
  <para>
   El conjunto de valores para cualquier sub-patrón de captura son aquellos del
   nivel último de la recursión en el cual el valor del sub-patrón
   es establecido. Si el patrón anterior se compara con
   
   <literal>(ab(cd)ef)</literal>
   
   el valor del paréntesis de captura es "ef", el cual es
   el último valor tomado en el nivel superior. Si se añaden
   paréntesis adicionales, dando lugar a
   
   <literal>\( ( ( (?>[^()]+) | (?R) )* ) \)</literal>
   entonces la cadena que capturan
   es "ab(cd)ef", el contenido de los paréntesis del nivel superior. Si
   hay más de 15 paréntesis de captura en un patrón,
   PCRE ha de obtener memoria extra para almacenar la información durante una
   recursión, lo cual hace usando pcre_malloc, liberándola
   mediante pcre_free después. Si no se puede obtener memoria, se
   guarda la información para los primeros 15 paréntesis de captura sólamente, ya que
   no hay manera de otorgar un error "out-of-memory" desde dentro de una
   recursión.
  </para>
  
  <para>
   Se puede usar también <literal>(?1)</literal>, <literal>(?2)</literal>
   y así sucesivamente, para los sub-patrones recursivos. Tamién es posible usar sub-patrones
   nominados: <literal>(?P&gt;nombre)</literal> o 
   <literal>(?&amp;nombre)</literal>.
  </para>
  <para>
   Si la sintaxis para la referencia de un sub-patrón recursivo (tanto como número o
   como nombre) se usa fuera de los paréntesis a los que hace referencia, opera
   como una sub-rutina de un lenguaje de programación. Un ejemplo mostrado
   anteriormente, tal que el patrón
   <literal>(abraz|apreci)o de un \1ador</literal>
   coincide con "abrazo de un abrazador" y con "aprecio de un apreciador", pero
   no con "abrazo de un apreciador". Si en su lugar se usa
   <literal>(abraz|apreci)o de un (?1)ador</literal>,
   coincide con "abrazo de un apreciador" así como con las otras
   dos cadenas. Tales referencias deben, sin embargo, seguir al sub-patrón al
   que hacen referencia.
  </para>
  
  <para>
   La longitud máxima de una cadena objetivo es el número positivo más grande
   que una variable tipo integer pueda tener. Sin embargo, PCRE usa la recursividad para
   tratar sub-patrones y repetición indefinida. Esto significa que el espacio
   de pila disponible puede limitar el tamaño de una cadena objetivo que puede ser
   procesada por ciertos patrones.
  </para>
  
 </section>
 
 <section xml:id="regexp.reference.performance">
  <title>Rendimiento</title>
  <para>
   Ciertos elementos que pueden aparecer en patrones son más eficientes
   que otros. Es más eficiente usar una clase carácter
   como [aeiou] en vez de un conjunto de alternativas como (a|e|i|o|u).
   En general, la construcción más simple que proporciona el
   comportamiento requerido es normalmente la más eficiente. El libro
   de Jeffrey Friedl contiene muchas discusiones sobre la optimización de
   expresiones regulares para un rendimiento eficiente.
  </para>
  <para>
   Cuando un patrón comienza con .* y la opción <link 
   linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> está
   establecida, el patrón es anclado implícitamente por PCRE, ya que
   sólo puede coincidir con el inicio de una cadena objetivo. Sin embargo, si
   <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>   
   no está establecido, PCRE no puede realizar esta optimización,
   ya que el meta-carácter . no coincide entonces con una nueva línea,
   y si la cadena objetivo contine nuevas líneas, el patrón puede
   coincidir con el carácter inmediatemente siguiente a ellas
   en vez de con el inicio absoluto. Por ejemplo, el patrón
   
   <literal>(.*) segundo</literal>
   
   coincide con el sujeto "primero\ny segundo" (donde \n significa
   un carácter de nueva línea), siendo "y" la primera sub-cadena capturada.
   Para llevar a cabo esto, PCRE ha de re-intentar la comparación
   comenzando después de cada nueva línea del sujeto.
  </para>
  <para>
   Si está usando un patrón similar con cadenas objetivo que no
   contienen nuevas líneas, el mejor rendimiento se obtiene
   estableciendo <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
   o comenzando el patrón con ^.* para
   indicar el anclado explícito. Esto salva a PCRE de tener que
   escanear el sujeto buscando una nueva línea desde donde reiniciar.
  </para>
  <para>
   Tenga cuidado con los patrones que contienen repeticiones anidadas indefinidas.
   Éstos pueden tomar mucho tiempo al ejecutarse cuando se aplican a cadenas
   que no coinciden. Considere el fragmento de patrón
   
   <literal>(a+)*</literal>
  </para>
  <para>
   Esto puede coincidir con "aaaa" de 33 maneras diferentes, y este número
   se incrementa muy rápidamente mientras la cadena se hace más larga. (La
   repetición * puede coincidir 0, 1, 2, 3, o 4 veces, y para cada uno de
   estos casos distintos de 0, las repeticiones de + pueden coincidir diferente
   número de veces.) Cuando el resto del patrón es tal
   que la comparación completa falla, PCRE tiene como principio
   el intentar cada posible variación, y esto puede tomar un
   tiempo extremadamente largo.
  </para>
  <para>
   Una optimización toma algunos de los casos más simples como
   
   <literal>(a+)*b</literal>
   
   donde sigue un carácter literal. Antes de emprender el
   procedimiento de comparación estándar, PCRE verifica que hay una "b"
   posterior en la cadena objetivo, y si no la hay, falla
   la comparación inmediatamente. Sin embargo, cuando no hay un literal
   siguiente, no se puede usar esta optimización. Puede ver la
   diferencia comparando el comportamiento de
   
   <literal>(a+)*\d</literal>
   
   con el patrón anterior. El primero otorga un fallo casi
   instantáneamente cuando se aplica a una línea llena de caracteres "a",
   mientras que el segundo toma un tiempo apreciable con cadenas
   con más de de 20 caracteres.
  </para>
 </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
