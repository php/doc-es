<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: n/a Maintainer: lboshell Status: ready -->
<refentry xml:id="function.fscanf" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>fscanf</refname>
  <refpurpose>Procesa la entrada desde un archivo de acuerdo a un
  formato</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>fscanf</methodname>
   <methodparam><type>resource</type><parameter>gestor</parameter></methodparam>
   <methodparam><type>string</type><parameter>formato</parameter></methodparam>
   <methodparam choice="opt"><type>mixed</type><parameter role="reference">...</parameter></methodparam>
  </methodsynopsis>
  <para>
   La función <function>fscanf</function> es similar a
   <function>sscanf</function>, pero toma su entrada desde un archivo
   asociado con <parameter>gestor</parameter> e interpreta la entrada de
   acuerdo al <parameter>formato</parameter> especificado, el cual es
   descrito en la documentación de <function>sprintf</function>.
  </para>
  <para>
   Cualquier espacio en blanco en la cadena de formato crea una
   correspondencia con cualquier espacio en blanco en la secuencia de
   entrada. Esto quiere decir que incluso una tabulación
   <literal>\t</literal> en la cadena de formato puede coincidir con un
   caracter de espacio sencillo en la secuencia de entrada.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>gestor</parameter></term>
     <listitem>
      &fs.file.pointer;
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>formato</parameter></term>
     <listitem>
      <para>
       El formato especificado tal como se describe en la documentación de
       <function>sprintf</function>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>...</parameter></term>
     <listitem>
      <para>
       Los valores opcionales asignados.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Si sólo se pasan dos parámetros a esta función, los valores procesados
   serán devueltos como una matriz. De otro modo, si se pasan parámetros
   opcionales, la función devolverá el número de valores asignados. Los
   parámetros opcionales deben ser pasados por referencia.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>4.3.0</entry>
       <entry>
        Antes de esta versión, el máximo número de caracteres leídos desde
        el archivo era 512 (o hasta el primer \n, lo que primero ocurriera).
        Ahora se leerán y analizarán líneas de longitudes arbitrariamente
        grandes.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Ejemplo de <function>fscanf</function></title>
    <programlisting role="php">
<![CDATA[
<?php
$gestor = fopen("usuarios.txt","r");
while ($info_usuario = fscanf($gestor, "%s\t%s\t%s\n")) {
    list ($nombre, $profesion, $cod_pais) = $info_usuario;
    //... hacer algo con los valores
}
fclose($gestor);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Contenido de usuarios.txt</title>
    <programlisting role="txt">
<![CDATA[
javier  argonauta       pe
hiroshi escultor        jp
robert  desempleado     us
luigi   florista        it
]]>
    </programlisting>
   </example>
  </para>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>fread</function></member>
    <member><function>fgets</function></member>
    <member><function>fgetss</function></member>
    <member><function>sscanf</function></member>
    <member><function>printf</function></member>
    <member><function>sprintf</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
