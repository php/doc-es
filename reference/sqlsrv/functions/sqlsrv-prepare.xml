<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: c758e862cf7648f657acb9e073bcc657f368a701 Maintainer: PhilDaiguille Status: ready -->
<!-- Reviewed: no -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="function.sqlsrv-prepare">
 <refnamediv>
  <refname>sqlsrv_prepare</refname>
  <refpurpose>Prepara una consulta para su ejecución</refpurpose>
 </refnamediv>
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>sqlsrv_prepare</methodname>
   <methodparam><type>resource</type><parameter>conn</parameter></methodparam>
   <methodparam><type>string</type><parameter>sql</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>params</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>options</parameter></methodparam>
  </methodsynopsis>
  <simpara>
   Prepara una consulta para su ejecución. Esta función es ideal para
   preparar una consulta que será ejecutada varias veces con diferentes
   valores de argumentos.
  </simpara>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <variablelist>
   <varlistentry>
    <term><parameter>conn</parameter></term>
    <listitem>
     <simpara>
      Un recurso de conexión devuelto por la función
      <function>sqlsrv_connect</function>.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>sql</parameter></term>
    <listitem>
     <simpara>
      La cadena que define la consulta a preparar y ejecutar.
     </simpara>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>params</parameter></term>
    <listitem>
     <para>
      Un array especificando la información de los argumentos al ejecutar
      una consulta que contiene argumentos. Los elementos del array pueden
      ser cualquiera de los siguientes:
      <simplelist>
       <member>Un valor literal</member>
       <member>Una variable PHP</member>
       <member>Un array con la siguiente estructura:
       array($value [, $direction [, $phpType [, $sqlType]]])</member>
      </simplelist>
      La tabla siguiente describe los elementos de la estructura del array anterior:
      </para>
      <table>
      <title>Estructura del array</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Elemento</entry>
         <entry>Descripción</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>$value</entry>
         <entry>Un valor literal, una variable PHP o una variable PHP pasada por referencia.</entry>
        </row>
        <row>
         <entry>$direction (opcional)</entry>
         <entry>Una de las constantes SQLSRV siguientes, utilizadas para indicar la
          dirección del argumento: SQLSRV_PARAM_IN, SQLSRV_PARAM_OUT, SQLSRV_PARAM_INOUT.
          El valor por defecto es SQLSRV_PARAM_IN.
         </entry>
        </row>
        <row>
         <entry>$phpType (opcional)</entry>
         <entry>Una constante SQLSRV_PHPTYPE_* que especifica el tipo de datos PHP
          del valor devuelto.</entry>
        </row>
        <row>
         <entry>$sqlType (opcional)</entry>
         <entry>Una constante SQLSRV_SQLTYPE_* que especifica el tipo de datos
          del servidor SQL del valor de entrada.</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>options</parameter></term>
    <listitem>
     <simpara>
      Un array especificando las opciones de propiedades de la consulta.
      Las claves soportadas se describen en la tabla siguiente:
     </simpara>
     <table>
      <title>Opciones de la consulta</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Clave</entry>
         <entry>Valores</entry>
         <entry>Descripción</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>QueryTimeout</entry>
         <entry>Un valor entero positivo.</entry>
         <entry>Define el tiempo máximo de ejecución de la consulta, en segundos.
          Por defecto, el controlador esperará indefinidamente los resultados.</entry>
        </row>
        <row>
         <entry>SendStreamParamsAtExec</entry>
         <entry>&true; o &false; (por defecto, &true;)</entry>
         <entry>Configura el controlador para enviar los datos del flujo a la ejecución (&true;),
          o enviar los datos del flujo por partes (&false;). Por defecto, el valor
          está definido a &true;. Para más información, consulte la función
          <function>sqlsrv_send_stream_data</function>.</entry>
        </row>
        <row>
         <entry>Scrollable</entry>
         <entry>SQLSRV_CURSOR_FORWARD, SQLSRV_CURSOR_STATIC, SQLSRV_CURSOR_DYNAMIC,
         o SQLSRV_CURSOR_KEYSET</entry>
         <entry>Ver la sección sobre <link xlink:href="&url.sqlsrv.specify.cursortype;">la
          especificación de un tipo de cursor y la selección de filas</link> de la documentación
          Microsoft SQLSRV.</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <simpara>
   Devuelve un recurso de consulta en caso de éxito, o &false; si ocurre un error.
  </simpara>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <example>
   <title>Ejemplo con <function>sqlsrv_prepare</function></title>
   <simpara>
    Este ejemplo muestra cómo preparar una consulta con la función
    <function>sqlsrv_prepare</function> y su re-ejecución varias veces
    (con diferentes valores de argumentos) utilizando la función
    <function>sqlsrv_execute</function>.
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
$serverName = "serverName\sqlexpress";
$connectionInfo = array( "Database"=>"dbName", "UID"=>"username", "PWD"=>"password");
$conn = sqlsrv_connect( $serverName, $connectionInfo);
if( $conn === false) {
    die( print_r( sqlsrv_errors(), true));
}

$sql = "UPDATE Table_1
        SET OrderQty = ?
        WHERE SalesOrderID = ?";

// Inicializa los argumentos y prepara la consulta.
// Las variables $qty y $id están ligadas a la consulta $stmt.
$qty = 0; $id = 0;
$stmt = sqlsrv_prepare( $conn, $sql, array( &$qty, &$id));
if( !$stmt ) {
    die( print_r( sqlsrv_errors(), true));
}

// Define la información SalesOrderDetailID y OrderQty.
// Este array liga el orden de los IDs con el orden de las cantidades con pares clave=>valor.
$orders = array( 1=>10, 2=>20, 3=>30);

// Ejecuta la consulta para cada orden.
foreach( $orders as $id => $qty) {
    // Debido a que $id y $qty están ligados a $stmt1,
    // sus valores actualizados se utilizan en cada ejecución
    // de la consulta.
    if( sqlsrv_execute( $stmt ) === false ) {
          die( print_r( sqlsrv_errors(), true));
    }
}
?>
]]>
   </programlisting>
  </example>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <simpara>
   Cuando se prepara una consulta que utiliza variables como argumentos,
   las variables están ligadas a la consulta. Esto significa que si se actualizan
   los valores de estas variables, la próxima ejecución de la consulta tomará
   en cuenta estos nuevos valores. Para las consultas que se prevé ejecutar
   solo una vez, utilice la función
   <function>sqlsrv_query</function>.
  </simpara>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <simplelist>
   <member><function>sqlsrv_execute</function></member>
   <member><function>sqlsrv_query</function></member>
  </simplelist>
 </refsect1>
</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
