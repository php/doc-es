<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: e94533ab352a237c3bc0902f27b66087c49a8a1e Maintainer: seros Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="mysqlnd.stats" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Estadísticas</title>
 <para>
  <emphasis role="bold">Usar datos estadísticos</emphasis>
 </para>
 <para>
  El Controlador Nativo de MySQL soporta la obtención de estadísticas sobre la
  comunicación entre el cliente y el servidor. Las estadísticas obtenidas
  son de tres tipos principales:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    Estadísticas del cliente
   </para>
  </listitem>
  <listitem>
   <para>
    Estadísticas de conexión
   </para>
  </listitem>
  <listitem>
   <para>
    Estadísticas de la caché Zval
   </para>
  </listitem>
 </itemizedlist>
 <para>
  Si se está usando la extensión <literal>mysqli</literal>, estas
  estadísticas se pueden obtener a través de tres llamadas a la API:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <function>mysqli_get_client_stats</function>
   </para>
  </listitem>
  <listitem>
   <para>
    <function>mysqli_get_connection_stats</function>
   </para>
  </listitem>
  <listitem>
   <para>
    <function>mysqli_get_cache_stats</function>
   </para>
  </listitem>
 </itemizedlist>
 <note>
  <para>
   Las estadísticas son acumuladas entre todas las extensiones que usan el Controlador Nativo de
   MySQL. Por ejemplo, al compilar <literal>ext/mysql</literal>
   y <literal>ext/mysqli</literal> con el Controlador Nativo de MySQL, las
   llamadas a las funciones de <literal>ext/mysql</literal> y
   <literal>ext/mysqli</literal> cambiarán las estadísticas. No existe ninguna
   forma de averiguar cuanto ha impactado una cierta llamada a la API de una extensión que ha
   sido compilada con el Controlador Nativo de MySQL en una cierta
   estadística. Se puede configurar el Controlador PDO MySQL,
   <literal>ext/mysql</literal> y <literal>ext/mysqli</literal> para que
   opcionalmente usen el Controlador Nativo de MySQL. Cuando se hace esto, las tres
   extensiones cambiarán las estadísticas.
  </para>
 </note>
 <para>
  <emphasis role="bold">Acceder a las estadísticas del cliente</emphasis>
 </para>
 <para>
  Para acceder a las estadísticas del cliente se necesita llamar a
  <function>mysqli_get_client_stats</function>. La llamada a la función
  no necesita ningún parámetro.
 </para>
 <para>
  La función devuelve un array asociativo que contiene el nombre de
  la estadística como clave y los datos de la estadística como valor.
 </para>
 <para>
  A las estadísticas del cliente también se pueden acceder llamando a la
  función <function>phpinfo</function>.
 </para>
 <para>
  <emphasis role="bold">Acceder a las estadísticas de conexión</emphasis>
 </para>
 <para>
  Para acceder a las estadísticas de conexión se ha de llamar a
  <function>mysqli_get_connection_stats</function>. Esta toma el
  gestor de conexión de la base de datos como parámetro.
 </para>
 <para>
  La función devuelve un array asociativo que contiene el nombre de
  la estadística como clave y los datos de la estadística como valor.
 </para>
 <para>
  <emphasis role="bold">Acceder a las estadísticas de la caché Zval</emphasis>
 </para>
 <para>
  El Controlador Nativo de MySQL también reúne estadísticas de su caché
  Zval interna. A estas estadísticas se puede acceder llamando a
  <function>mysqli_get_cache_stats</function>.
 </para>
 <para>
  Las estadísticas de la caché Zval obtenidas pueden conducir a un ajuste de
  las configuraciónes de <filename>php.ini</filename> relacionadas con la caché Zval,
  resultando en un mejor rendimiento.
 </para>
 <para>
  <emphasis role="bold">Conjuntos de resultados almacenados y no almacenados en buffer</emphasis>
 </para>
 <para>
  Los conjuntos de resultados puede ser almacenados o no almacenados en buffer. Al usar la configuración predeterminada,
  <literal>ext/mysql</literal> y <literal>ext/mysqli</literal> trabajan
  con conjuntos de resultados almacenados en buffer para consultas normales (sentencia no preparada).
  Los conjuntos de resultados almacenados en buffer son almacenados en la caché del cliente. Después de la ejecución
  de una consulta, todos los resultados son traidos desde el Servidor MySQL y almacenados en
  una caché del cliente. La gran ventaja de los conjuntos de resultados almacenados en buffer es
  que permiten al servidor liberar todos los recursos asignados a un conjunto de
  resultados, una vez que los resultados han sido obtenidos por el cliente.
 </para>
 <para>
  Por otra parte, los conjuntos de resultados no almacenados en buffer se mantienen mucho más tiempo en el
  servidor. server. Si se quiere reducir el consumo de memoria del cliente, aunque
  incrementando la carga del servidor, se han de usar conjunto de resultados no almacenados en buffer. Si se experimenta
  una alta carga del servidor y las cigras de los conjuntos de resultados no almacenados en buffer son
  altas, se debería considerar trasladar la carga a los cliente. Estos
  normalmente escalan mejor que los servidores. La <quote>carga</quote> no solamente
  se refiere a los buffers de memoria - el servidor también necesita mantener otros recursos
  abiertos, como por ejemplo, gestores de ficheros e hilos, antes de que un conjunto
  de resultados sea liberado.
 </para>
 <para>
  Las Sentencias Preparadas usan conjuntos de resultados no almacenados en buffer de manera predeterminada.
  Sin embargo, se puede usar <function>mysqli_stmt_store_result</function> para habilitar
  los conjuntos de resultados almacenados en buffer.
 </para>
 <para>
  <emphasis role="bold">Estadísticas devueltas por el Controlador Nativo de
   MySQL</emphasis>
 </para>
 <para>
  Las siguientes tablas muestran una lista de las estadísticas devueltas por las funciones
  <function>mysqli_get_client_stats</function>,
  <function>mysqli_get_connection_stats</function> y
  <function>mysqli_get_cache_stats</function>.
 </para>
 <table>
  <title>Estadísticas devueltas de mysqlnd: Red</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Estadística</entry>
     <entry>Ámbito</entry>
     <entry>Descrpción</entry>
     <entry>Notas</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>bytes_sent</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de bytes enviados desde PHP al servidor MySQL</entry>
     <entry>Se puede usar para comprobar la eficiencia del protocolo de compresión</entry>
    </row>
    <row>
     <entry><literal>bytes_received</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de bytes recibidos desde el servidor MySQL</entry>
     <entry>Se puede usar para comprobar la eficiencia del protocolo de compresión</entry>
    </row>
    <row>
     <entry><literal>packets_sent</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes enviados del protocolo Cliente Servidor de MySQL</entry>
     <entry>Usado para la depuración de la implementación del protoclo Cliente Servidor</entry>
    </row>
    <row>
     <entry><literal>packets_received</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes recividos del protocolo Cliente Servidor de MySQL</entry>
     <entry>Usado para la depuración de la implementación del protoclo Cliente Servidor</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_in</literal></entry>
     <entry>Conexión</entry>
     <entry>MySQL Client Server protocol overhead in bytes for incoming traffic.
      Currently only the Packet Header (4 bytes) is considered as
      overhead. protocol_overhead_in = packets_received * 4</entry>
     <entry>Used for debugging Client Server protocol implementation</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_out</literal></entry>
     <entry>Conexión</entry>
     <entry>Carga adicional de protocolo Cliente Servidor de MySQL en bytes para el tráfico saliente.
      Actualmente, sólo el Paquete de Cabecera (4 bytes) se considera como
      carga adicional. protocol_overhead_out = packets_sent * 4</entry>
     <entry>Usado para la depuración de la implementación del protoclo Cliente Servidor</entry>
    </row>
    <row>
     <entry><literal>bytes_received_ok_packet</literal></entry>
     <entry>Conexión</entry>
     <entry>Tamaño total en bytes de los paquetes OK recibidos del protocolo Cliente Servidor de MySQL.
      Los paquetes OK pueden contener un mensaje de estado. La longitud del mensaje de
      estado puede variar y, por lo tanto, el tamaño del paquete OK no es fijo.</entry>
     <entry>Usado para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>packets_received_ok</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes OK recibidos del protocolo Cliente Servidor de MySQL.</entry>
     <entry>Usado para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_eof_packet</literal></entry>
     <entry>Conexión</entry>
     <entry>Tamaño total en bytes de los paquetes OEF recibidos del protocolo Cliente Servidor de
      MySQL. EOF puede variar de tamaño dependiendo de la versión del servidor.
      También, EOF puede transportar un mensaje de error.</entry>
     <entry>Usado para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>packets_received_eof</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes EOF del del protocolo Cliente Servidor de MySQL. Al igual que otras
      estadísticias de paquetes, el número de paquetes se incrementará incluso si
      PHP no recibe el paquete esperado, sino, por ejemplo, un
      mensaje de error.</entry>
     <entry>Usado para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_header_packet</literal></entry>
     <entry>Conexión</entry>
     <entry>Tamaño total en bytes de los paquetes de cabecera de conjuntos de resultados del protocolo Cliente Servidor de
      MySQL. El tamaño de los paquetes varía dependiendo de la carga útil
      (<literal>LOAD LOCAL INFILE</literal>, <literal>INSERT</literal>,
      <literal>UPDATE</literal>, <literal>SELECT</literal>, mensaje
      de error).</entry>
     <entry>Usado para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_header</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes de cabecera de conjuntos de resultados del protocolo Cliente Servidor de MySQL.</entry>
     <entry>Usado para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_field_meta_packet</literal></entry>
     <entry>Conexión</entry>
     <entry>Tamaño total en bytes de los paquetes de metadatos (información de campos) de conjuntos de resultados del protocolo
      Cliente Servidor de MySQL. Por supuesto, el tamaño total vaía con los
      campos del conjunto de resultados. El paquete también puede transportar un error
      o un paquete EOF en el caso de COM_LIST_FIELDS.</entry>
     <entry>Solamente útil para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_field_meta</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes de metadatos (información de campos) de conjuntos de resultados del protocolo
      Cliente Servidor de MySQL.</entry>
     <entry>Solamente útil para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_row_packet</literal></entry>
     <entry>Conexión</entry>
     <entry>Tamaño total en bytes de los paquetes de datos de fila de conjuntos de resultados del protocolo
      Cliente Servidor de MySQL. El paquete también puede transportar un error o un paquete EOF.
      Se puede obtener el número de error y los paquetes EOF
      restando <literal>rows_fetched_from_server_normal</literal>
      y <literal>rows_fetched_from_server_ps</literal> de
      <literal>bytes_received_rset_row_packet</literal>.</entry>
     <entry>Solamente útil para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_row</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes de datos de fila de conjuntos de datos del protocolo Cliente Servidor de MySQL y
      su tamaño total en bytes.</entry>
     <entry>Solamente útil para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_prepare_response_packet</literal></entry>
     <entry>Conexión</entry>
     <entry>Tamaño total de los paquetes OK para la Inicialización de Sentencias Preparadas del protocolo
      Cliente Servidor de MySQL (paquetes init de sentencias
      preparadas). El paquete también puede transportar un error. El tamaño del paquete
      depende de la versión de: 9 bytes con MySQL 4.1 y 12 bytes
      desde MySQL 5.0. No existe una manera segura de conocer cuántos errores han
      sucedido. Se puede suponer que ha sucedido un error si,
      por ejemplo, si siempre se conecta a MySQL 5.0 o superior y
      <literal>bytes_received_prepare_response_packet</literal> !=
      <literal>packets_received_prepare_response</literal> * 12. Véase
      también <literal>ps_prepared_never_executed</literal>,
      <literal>ps_prepared_once_executed</literal>.</entry>
     <entry>Solamente útil para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>packets_received_prepare_response</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes OK para la Inicialización de Sentencias Preparadas del protocolo
      Cliente Servidor de MySQL (paquetes init de sentencias preparadas).</entry>
     <entry>Solamente útil para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_change_user_packet</literal></entry>
     <entry>Conexión</entry>
     <entry>Tamaño total en bytes de los paquetes COM_CHANGE_USER del protocolo Cliente Servidor de
      MySQL. El paquete también puede transportar un error o EOF.</entry>
     <entry>Solamente útil para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>packets_received_change_user</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de paquetes COM_CHANGE_USER del protocolo Cliente Servidor de MySQL</entry>
     <entry>Solamente útil para la implementación de protocolo CS. Observe que el tamaño total
      en bytes incluye el tamaño del paquete de cabecera (4 bytes, véase
      la carga adicional del protocolo - protocol_overhead_*).</entry>
    </row>
    <row>
     <entry><literal>packets_sent_command</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de comandos enviados del protocolo Cliente Servidor de MySQL desde PHP a MySQL.
      No hay forma de conocer los comandos específicos ni cuántos
      han sido enviados. En el mejor de los casos, se puede usar para comprobar si PHP
      ha enviado cualquier comando a MySQL para saber si se puede considerar
      deshabilitar el soporte para MySQL en el binario de PHP. Tampoco hay forma de
      obtener el número de errores que pueden haber ocurrido mientras
      se envían datos a MySQL. El único error que se registra es
      command_buffer_too_small (véase abajo).</entry>
     <entry>Solamente útil para la implementación de protocolo CS.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_normal</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de bytes de carga útil obtenidos por el cliente de PHP desde
      <literal>mysqlnd</literal> usando el protocolo de texto.</entry>
     <entry>Es el tamaño de los datos reales contenidos en conjuntos de resultados que no
      son originados desde sentencias preparadas y que han sido obtenidos por
      el cliente de PHP. Observe que aunque un conjunto de resultados completo puede haber sido
      obtenido desde MySQL por <literal>mysqlnd</literal>, esta estadística
      únicamente cuenta los datos reales obtenidos desde <literal>mysqlnd</literal> por
      el cliente de PHP. Un ejemplo de una secuencia de código que incrementará
      el valor es el siguiente:
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->fetch_assoc();
$res->close();
]]>
      </programlisting>
      <para>
       Cada operación de obtención incrementará el valor.
      </para>
      
      <para>
       La estadística no se incrementará si el conjunto de resultados sólo se almancena
       en buffer en el cliente, pero no se obtiene, como en el siguiente
       ejemplo:
      </para>
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->close();
]]>
      </programlisting>
      <para>
       Esta estadística está disponible a partir de la versión 5.3.4 de PHP.
      </para></entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_ps</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de bytes de la carga útil obtenida por el cliente de PHP desde
      <literal>mysqlnd</literal> usando el protocolo de sentencias preparadas.</entry>
     <entry>Es el tamaño de los datos reales contenidos en conjuntos de resultados que no
      son originados desde sentencias preparadas y que han sido obtenidos por
      el cliente de PHP. El valor no será incrementado si el conjunto de resultados
      no es leído subsiguientemente por el cliente de PHP. Observe que aunque un
      un conjunto de resultados completo puede haber sido obtenido desde MySQL por
      <literal>mysqlnd</literal>, esta estadística únicamente cuenta los datos reales
      obtenidos desde <literal>mysqlnd</literal> por el cliente de PHP. Véase también
      <literal>bytes_received_real_data_normal</literal>. Esta estadística
      está disponible a partir de la versión 5.3.4 de PHP.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Conjuntos de Resultados</emphasis>
 </para>
 <table>
  <title>Estadísticas devueltas de mysqlnd: Conjunto de Resultados</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Estadística</entry>
     <entry>Ámbito</entry>
     <entry>Descrpción</entry>
     <entry>Notas</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>result_set_queries</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de consultas que han generado un conjunto de resultados. Ejemplos de consultas
      que generan un conjunto de resultados: <literal>SELECT</literal>,
      <literal>SHOW</literal>. La estadística no será incrementada si
      hay un error al leer el paquete de cabecera del conjunto de resultados desde la
      línea.</entry>
     <entry>Se puede usar como una medida indirecta del número de consultas que PHP ha
      enviado a MySQL, por ejemplo, para identificar un cliente que causa una
      carga alta de base de datos.</entry>
    </row>
    <row>
     <entry><literal>non_result_set_queries</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de consultas que no generan un conjunto de resultados. Ejemplos de
      consultas que no generan un conjunto de resultados:
      <literal>INSERT</literal>, <literal>UPDATE</literal>,
      <literal>LOAD DATA</literal>, <literal>SHOW</literal>. La
      estadística no será incrementada si hay un error al leer el
      paquete de cabecera del conjunto de resultados desde la línea.</entry>
     <entry>Se puede usar como una medida indirecta del número de consultas que PHP ha
      enviado a MySQL, por ejemplo, para identificar un cliente que causa una
      carga alta de base de datos.</entry>
    </row>
    <row>
     <entry><literal>no_index_used</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de consultas que ha generado un conjunto de resultados pero que no usan un
      índice (véase también la opción de inicio de mysqld
      –log-queries-not-using-indexes). Si se desea que estas consultas sean
      reportadas, se puede usar mysqli_report(MYSQLI_REPORT_INDEX) para hacer que
      ext/mysqli lance una excepción. Si se prefiere una advertencia en lugar de
      una excepción, use mysqli_report(MYSQLI_REPORT_INDEX ^
      MYSQLI_REPORT_STRICT).</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>bad_index_used</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de consultas que han generado un conjunto de resultados y que no usan un
      índice bueno (véase también la opción de inicio de mysqld –log-slow-queries).</entry>
     <entry>Si se desea que estas consultas sean reportadas, se puede usar
      mysqli_report(MYSQLI_REPORT_INDEX) para hacer que ext/mysqli lance una
      excepción. Si se prefiere que se emita una advertencia en lugar de una excepción, use
      mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT)</entry>
    </row>
    <row>
     <entry><literal>slow_queries</literal></entry>
     <entry>Conexión</entry>
     <entry>Senetencias SQL que toman más de <literal>long_query_time</literal>
      segundos para ejecutarse y que requieren al menos
      <literal>min_examined_row_limit</literal> filas para ser examinadas.</entry>
     <entry>No reportadas a través de <function>mysqli_report</function></entry>
    </row>
    <row>
     <entry><literal>buffered_sets</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de conjuntos de resultados almacenados en buffer mediante consultas
      <quote>normales</quote>. <quote>Normal</quote> significa <quote>sentencia no
      preparada</quote> en las siguientes notas.</entry>
     <entry>Ejemplos de llamada a la API que almacenarán en buffer conjuntos de resultados en el cliente:
      <function>mysql_query</function>,
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function>,
      <function>mysqli_stmt_get_result</function>. Al almacenar en buffer conjuntos de resultados
      en el cliente se asegura que los recursos del servidor sean liberados tan pronto como sea
      posible y hace que el desplazamiento del conjunto de resultados sea más sencillo. El inconveniente es
      el consumo adicional de memoria en el cliente para almacenar en buffer
      datos. Observe que mysqlnd (a diferencia de la Biblioteca Cliente de MySQL) respeta
      el límite de memoria de PHP debido a que utiliza las funciones de gestión de memoria
      internas de PHP para asignar memoria. Ésta también es la razón
      de por qué <function>memory_get_usage</function> informa de un consumo de
      memoria al usar mysqlnd en lugar de la Bliblioteca Cliente de
      MySQL. <function>memory_get_usage</function> no mide en absoluto
      el consumo de memoria de la Bliblioteca Cliente de MySQL debido a que
      ¡la Biblioteca Cliente de MySQL no usa las funciones de gestión de memoria
      internas de PHP monitorizadas por la función!</entry>
    </row>
    <row>
     <entry><literal>unbuffered_sets</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de conjuntos de resultados no almacenados en buffer devueltos por consultas
      normales (sentencia no preparada).</entry>
     <entry>Ejemplos de llamadas a la API que no almacenan en buffer conjuntos de resultados en el clilente:
      <function>mysqli_use_result</function></entry>
    </row>
    <row>
     <entry><literal>ps_buffered_sets</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de conjuntos de resultados almacenados en buffer devueltos por sentencias preparadas. Por
      defecto, las sentencias preparadas no se almacenan en buffer.</entry>
     <entry>Ejemplos de llamadas a la API que no almacenarán en buffer conjuntos de resultados en el cliente:
      <literal>mysqli_stmt_store_result</literal></entry>
    </row>
    <row>
     <entry><literal>ps_unbuffered_sets</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de conjuntos de resultados no almacenados en buffer devueltos por sentencias preparadas.</entry>
     <entry>Por defecto, las sentencias preparadas no se almacenan en buffer.</entry>
    </row>
    <row>
     <entry><literal>flushed_normal_sets</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de conjuntos de resultados de consultas normales (sentencia no preparada) con
      datos no leídos que han sido volcados de manera silenciosa. El volcado
      sucede solamente con conjuntos de resultados no almacenados en buffer.</entry>
     <entry>Los conjuntos de resultados no almacenados en buffer deben ser obtenidos completamente antes de que una nueva consulta
      pueda ser ejecutada en la conexión, si no, MySQL lanzará un error. Si
      la aplicación no obtiene todas las filas de un conjunto de resultados no almacenado en
      buffer, mysqlnd obtendrá implícitamente el conjunto de resultados para limpiar la
      línea. Véase también <literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal>. Algunas posibles causas de un
      volcado implícito:
      <itemizedlist>
       <listitem>
        <para>
         Aplicación cliente defectuosa
        </para>
       </listitem>
       <listitem>
        <para>
         El cliente para de leer después de que encuentre que lo que estaba buscando,
         pero ha hecho que MySQL calcule más registros que los necesarios
        </para>
       </listitem>
       <listitem>
        <para>
         La aplicación cliente se ha detenido de improviso
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>flushed_ps_sets</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de conjuntos de resultados de sentencias preparadas con datos no leídos que
      han sido volcados de forma silenciosa.  El volcado sucede solamente con
      conjuntos de resultados no almacenados en buffer.</entry>
     <entry>Los conjuntos de resultados no almacenados en buffer deben ser obtenidos completamente antes de que una nueva consulta
      pueda ser ejecutada en la conexión, si no, MySQL lanzará un error. Si
      la aplicación no obtiene todas las filas de un conjunto de resultados no almacenado en
      buffer, mysqlnd obtendrá implícitamente el conjunto de resultados para limpiar la
      línea. Véase también <literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal>. Algunas posibles causas de un
      volcado implícito:
      <itemizedlist>
       <listitem>
        <para>
         Aplicación cliente defectuosa
        </para>
       </listitem>
       <listitem>
        <para>
         El cliente para de leer después de que encuentre que lo que estaba buscando,
         pero ha hecho que MySQL calcule más registros que los necesarios
        </para>
       </listitem>
       <listitem>
        <para>
         La aplicación cliente se ha detenido de improviso
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>ps_prepared_never_executed</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de sentencias preparadas pero nunca ejecutadas.</entry>
     <entry>Las sentencias preparadas ocupan recursos del servidor. No se debería preparar una
      sentencia si no se planea ejecutarla.</entry>
    </row>
    <row>
     <entry><literal>ps_prepared_once_executed</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de sentencias preparadas ejecutadas una única vez.</entry>
     <entry>Una de las ideas detrás de las sentencias preparadas es que la misma consulta se
      ejecuta una y otra vez (con diferentes parámetros) y así se puede
      ahorrar algo de análisis y otros trabajos de preparación, si la ejecución
      de la sentencia se divide en diferentes fases de preparación y ejecución. La
      idea es preparar una vez y <quote>almacenar en caché</quote> los resultados, por
      ejemplo, el árbol de análisis a ser reutilizado durante la ejecución de sentencias
      múltiples. Si se ejecuta una sentencia prearada una sola vez, los dos
      procesamientos de las fases pueden ser ineficientes comparados con
      consultas <quote>normales</quote>, ya que todo el almacenamiento en caché significa trabajo
      extra y toma recursos (limitados) del servidor para mantener la información almacenada
      en caché. Consecuentemente, las sentencias preparadas que son ejecutadas
      una sola vez pueden causar daños al rendimiento.</entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_server_normal</literal>,
      <literal>rows_fetched_from_server_ps</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de conjuntos de resultados obtenidos con éxito de MySQL
      sin considerar si la aplicación cliente los ha consumido o no.
      Algunas filas pueden no haber sido obtenidas por la aplicación
      cliente aunque hayan sido volcadas implícitamente.</entry>
     <entry>Véase también <literal>packets_received_rset_row</literal></entry>
    </row>
    <row>
     <entry><literal>rows_buffered_from_client_normal</literal>,
      <literal>rows_buffered_from_client_ps</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de filas almacenadas en buffer con éxito originadas desde una consulta
      "normal" o una sentencia preparada. Este es el número de filas que
      han sido obtenidas de MySQL y almacenadas en buffer en el cliente. Observe que
      existen dos estadísticas distintas de filas que has sido almacenadas en buffer
      (MySQL al buffer internto de mysqlnd) y filas almacenadas en buffer que han
      sido obtenidas por la aplicación cliente (buffer interno de mysqlnd a
      la aplicación cliente). Si el número de filas almacenadas en buffer es mayor que
      el número de filas almacenadas en buffer obtenidas, puede significar que la aplicación
      cliente ejecuta consultas que originan conjuntos de resultados grandes que necesitan
      resultar en filas no leídas por el cliente.</entry>
     <entry>Ejemplos de consultas que almacenarán en buffer resultados:
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_buffered</literal>,
      <literal>rows_fetched_from_client_ps_buffered</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de filas obtenidas por el cliente desde un conjunto de resultados almacenado en buffer
      creado por una consulta normal o una sentencia preparada.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_unbuffered</literal>,
      <literal>rows_fetched_from_client_ps_unbuffered</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de filas obtenidas por el cliente desde un conjunto de resultados no almacenado en buffer
      creado por una consulta "normal" o una sentencia no preparada.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_ps_cursor</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de filas obtenidas por el cliente desde un cursor creado por una
      sentencia preparada.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal></entry>
     <entry>Conexión</entry>
     <entry>Reservado para un uso futuro (actualmente no soportado)</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>copy_on_write_saved</literal>,
      <literal>copy_on_write_performed</literal></entry>
     <entry>Proceso</entry>
     <entry>Con mysqlnd, las variables devueltas por las extensiones apuntan a los buffers de resultados
      de red internos de mysqlnd. Si no se cambian las variables,
      los datos obtenidos serán conservados en memoria una sola vez. Si se
      cambian las variables, mysqlnd tiene que realizar una copia mientras se escribe para
      proteger los buffers de resultados de red internos de ser cambiados.
      Con la Biblioteca Clientes de MySQL siempre se conservan dos veces en memoria
      los datos obtenidos. Una en los buffers internos de la Biblioteca Cliente de MySQL y
      otra en las variables devueltas por las extensiones. En teoría,
      mysqlnd puede ahorrar hasta un 40% de memoria, Sin embargo, observe que el ahorro de
      memoria no puede ser medido usando
      <function>memory_get_usage</function>.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>explicit_free_result</literal>,
      <literal>implicit_free_result</literal></entry>
     <entry>Conexión, Processo (sólo durante la limpieza de sentencias preparadas)</entry>
     <entry>Número de total de conjuntos de resultados liberados.</entry>
     <entry>La liberación es considerada siempres explícita excepto para conjuntos de resultados creados por un
      comando init, por ejemplo,
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal></entry>
    </row>
    <row>
     <entry><literal>proto_text_fetched_null</literal>,
      <literal>proto_text_fetched_bit</literal>,
      <literal>proto_text_fetched_tinyint</literal>
      <literal>proto_text_fetched_short</literal>,
      <literal>proto_text_fetched_int24</literal>,
      <literal>proto_text_fetched_int</literal>
      <literal>proto_text_fetched_bigint</literal>,
      <literal>proto_text_fetched_decimal</literal>,
      <literal>proto_text_fetched_float</literal>
      <literal>proto_text_fetched_double</literal>,
      <literal>proto_text_fetched_date</literal>,
      <literal>proto_text_fetched_year</literal>
      <literal>proto_text_fetched_time</literal>,
      <literal>proto_text_fetched_datetime</literal>,
      <literal>proto_text_fetched_timestamp</literal>
      <literal>proto_text_fetched_string</literal>,
      <literal>proto_text_fetched_blob</literal>,
      <literal>proto_text_fetched_enum</literal>
      <literal>proto_text_fetched_set</literal>,
      <literal>proto_text_fetched_geometry</literal>,
      <literal>proto_text_fetched_other</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de columnas de un cierto tipo obtenidas de una consulta normal
      (protocolo de texto de MySQL).</entry>
     <entry>Referencia de los tipos de metadatos de la API de C / MySQL para el nombre de la estadística:
      <itemizedlist>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_NULL</literal> - proto_text_fetched_null
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_BIT</literal> - proto_text_fetched_bit
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY</literal> - proto_text_fetched_tinyint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SHORT</literal> - proto_text_fetched_short
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_INT24</literal> - proto_text_fetched_int24
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONG</literal> - proto_text_fetched_int
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONGLONG</literal> -
         proto_text_fetched_bigint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DECIMAL</literal>,
         <literal>MYSQL_TYPE_NEWDECIMAL</literal> -
         proto_text_fetched_decimal
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_FLOAT</literal> - proto_text_fetched_float
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DOUBLE</literal> -
         proto_text_fetched_double
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATE</literal>,
         <literal>MYSQL_TYPE_NEWDATE</literal> - proto_text_fetched_date
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_YEAR</literal> - proto_text_fetched_year
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIME</literal> - proto_text_fetched_time
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATETIME</literal> -
         proto_text_fetched_datetime
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIMESTAMP</literal> -
         proto_text_fetched_timestamp
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_STRING</literal>,
         <literal>MYSQL_TYPE_VARSTRING</literal>,
         <literal>MYSQL_TYPE_VARCHAR</literal> -
         proto_text_fetched_string
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY_BLOB</literal>,
         <literal>MYSQL_TYPE_MEDIUM_BLOB</literal>,
         <literal>MYSQL_TYPE_LONG_BLOB</literal>,
         <literal>MYSQL_TYPE_BLOB</literal> - proto_text_fetched_blob
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_ENUM</literal> - proto_text_fetched_enum
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SET</literal> - proto_text_fetched_set
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_GEOMETRY</literal> -
         proto_text_fetched_geometry
        </para>
       </listitem>
       <listitem>
        <para>
         Any <literal>MYSQL_TYPE_*</literal> no listado antes (no
         debería ser ninguno) - proto_text_fetched_other
        </para>
       </listitem>
      </itemizedlist>
      <para>
       Observe que las constantes MYSQL_*-type pueden no estar asociadas con
       los mismos tipos de columnas SQL en cada versión de MySQL.
      </para></entry>
    </row>
    <row>
     <entry><literal>proto_binary_fetched_null</literal>,
      <literal>proto_binary_fetched_bit</literal>,
      <literal>proto_binary_fetched_tinyint</literal>
      <literal>proto_binary_fetched_short</literal>,
      <literal>proto_binary_fetched_int24</literal>,
      <literal>proto_binary_fetched_int</literal>,
      <literal>proto_binary_fetched_bigint</literal>,
      <literal>proto_binary_fetched_decimal</literal>,
      <literal>proto_binary_fetched_float</literal>,
      <literal>proto_binary_fetched_double</literal>,
      <literal>proto_binary_fetched_date</literal>,
      <literal>proto_binary_fetched_year</literal>,
      <literal>proto_binary_fetched_time</literal>,
      <literal>proto_binary_fetched_datetime</literal>,
      <literal>proto_binary_fetched_timestamp</literal>,
      <literal>proto_binary_fetched_string</literal>,
      <literal>proto_binary_fetched_blob</literal>,
      <literal>proto_binary_fetched_enum</literal>,
      <literal>proto_binary_fetched_set</literal>,
      <literal>proto_binary_fetched_geometry</literal>,
      <literal>proto_binary_fetched_other</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de columnas de un cierto tipo obtenidas desde una sentencia
      preparada (protocolo binario de MySQL).</entry>
     <entry>Para la referenciacición de tipos, véase <literal>proto_text_*</literal> descrito en el
      texto anterior.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table>
  <title>Estadísticas devueltas de mysqlnd: Conexión</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Estadística</entry>
     <entry>Ámbito</entry>
     <entry>Descrpción</entry>
     <entry>Notas</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>connect_success</literal>, <literal>connect_failure</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de intentos de conexión con éxito/falladas.</entry>
     <entry>Están incluidas las conexiones rechazadas y los demás tipos de conexiones.</entry>
    </row>
    <row>
     <entry><literal>reconnect</literal></entry>
     <entry>Proceso</entry>
     <entry>Número total de intentos de conexión verdadera (real_) hechas sobre un gestor de conexión
      ya abierto.</entry>
     <entry>La secuencia de código <literal>$enlace = new mysqli(...);
      $enlace-&gt;real_connect(...)</literal> ocasionará una reconexión. Pero
      <literal>$link = new mysqli(...); $enlace-&gt;connect(...)</literal>
      no lo hará ya que <literal>$enlca-&gt;connect(...)</literal>
      cerrará explícitamente la conexión existente antes de que se establezca una
      nueva conexión.</entry>
    </row>
    <row>
     <entry><literal>pconnect_success</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de intentos de conexión persistente realizados con éxito.</entry>
     <entry>Observe que <literal>connect_success</literal> contiene la suma de intentos de
      conexión persistente y no persistente realizados con éxito. El número de
      intentos de conexión no persistente realizados con éxito es
      <literal>connect_success</literal> -
      <literal>pconnect_success</literal>.</entry>
    </row>
    <row>
     <entry><literal>active_connections</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de conexiones persistentes y no persistentes activas.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>active_persistent_connections</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de conexiones persistentes activas.</entry>
     <entry>El número total de conexiones no persistentes activas es
      <literal>active_connections</literal> -
      <literal>active_persistent_connections</literal>.</entry>
    </row>
    <row>
     <entry><literal>explicit_close</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de conexiones cerradas explícitamente (sólo ext/mysqli).</entry>
     <entry>Ejemplos de trozos de código que causan un cierre explícito :
      <programlisting>
<![CDATA[
$enlace = new mysqli(...); $enlace->close(...)
$enlace = new mysqli(...); $enlace->connect(...)
]]>
      </programlisting></entry>
    </row>
    <row>
     <entry><literal>implicit_close</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de conexiones cerradas implícitamente (sólo ext/mysqli).</entry>
     <entry>Ejemplos de trozos de código que causan un cierre implícito :
      <itemizedlist>
       <listitem>
        <para>
         <literal>$enlace = new mysqli(...);
          $enlace-&gt;real_connect(...)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>unset($enlace)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Conexión persistente: conexión almacenada en caché que ha sido creada con
         real_connect y que puede poseer un conjunto de opciones desconocidas - cerrar
         implícitamente para evitar devolver una conexión con opciones desconocidas
        </para>
       </listitem>
       <listitem>
        <para>
         Conexión persistente: ping/change_user falla y ext/mysqli
         cierra la conexión
        </para>
       </listitem>
       <listitem>
        <para>
         fin de la ejecución de un script: cierra la conexiones que no han sido
         cerradas por el usuario
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>disconnect_close</literal></entry>
     <entry>Conexión</entry>
     <entry>Fallos de conexión indicados por la llamada a la API en C de
      <function>mysql_real_connect</function> durante un intento de
      establecer una conexión.</entry>
     <entry>Es llamada <literal>disconnect_close</literal> porque el gestor de
      conexión pasado a la llamada a la API en C será cerrado.</entry>
    </row>
    <row>
     <entry><literal>in_middle_of_command_close</literal></entry>
     <entry>Proceso</entry>
     <entry>Una conexión ha sido cerrada en mitad de la ejecución de un comando
      (conjuntos de resultados pendientes no obtenidos, después de enviar una consulta y
      antes de obtener una respuesta, mientras se obtienen los datos, mientras
      se transfieren datos con LOAD DATA).</entry>
     <entry>A menos que se usen consultas asíncronas, esto únicamente debería ocurrir si el
      script se detiene inesperadamente y PHP cierra las conexiones por sí
      solo.</entry>
    </row>
    <row>
     <entry><literal>init_command_executed_count</literal></entry>
     <entry>Conexión</entry>
     <entry>Número totas de ejecuciones de comandos init, por ejemplo,
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal>.</entry>
     <entry>El número de ejecuciones realizadas con éxito es
      <literal>init_command_executed_count</literal> -
      <literal>init_command_failed_count</literal>.</entry>
    </row>
    <row>
     <entry><literal>init_command_failed_count</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de comnados init fallados.</entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table>
  <title>Estadísticas devueltas de mysqlnd: Comando COM_*</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Estadística</entry>
     <entry>Ámbito</entry>
     <entry>Descrpción</entry>
     <entry>Notas</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>com_quit</literal>, <literal>com_init_db</literal>,
      <literal>com_query</literal>, <literal>com_field_list</literal>,
      <literal>com_create_db</literal>, <literal>com_drop_db</literal>,
      <literal>com_refresh</literal>, <literal>com_shutdown</literal>,
      <literal>com_statistics</literal>,
      <literal>com_process_info</literal>,
      <literal>com_connect</literal>,
      <literal>com_process_kill</literal>, <literal>com_debug</literal>,
      <literal>com_ping</literal>, <literal>com_time</literal>,
      <literal>com_delayed_insert</literal>,
      <literal>com_change_user</literal>,
      <literal>com_binlog_dump</literal>,
      <literal>com_table_dump</literal>,
      <literal>com_connect_out</literal>,
      <literal>com_register_slave</literal>,
      <literal>com_stmt_prepare</literal>,
      <literal>com_stmt_execute</literal>,
      <literal>com_stmt_send_long_data</literal>,
      <literal>com_stmt_close</literal>,
      <literal>com_stmt_reset</literal>,
      <literal>com_stmt_set_option</literal>,
      <literal>com_stmt_fetch</literal>, <literal>com_daemon</literal></entry>
     <entry>Conexión</entry>
     <entry>Número total de intentos de enviar un cierto comando COM_* desde PHP a
      MySQL.</entry>
     <entry><para>
      Las estadísticas son incrementadas después de comprobar la línea e
      inmediatamente antes de enviar el paquete de protocolo cliente-servidor de
      MySQL correspondiente. Si mysqlnd falla al enviar el paquete sobre el
      cable, las estadísticas no serán incrementadas. En case de fallo,
      mysqlnd emite una advertencia de PHP <quote>Error while sending %s packet.
      PID=%d.</quote>
      </para>
      
      <para>
       Ejemplos de uso:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         Comprobar si PHP eviía ciertos comandos a MySQL, por ejemplo,
         comprobar si un cliente envía <literal>COM_PROCESS_KILL</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Calcuar el promedio de ejecuciones de sentencias preparadas
         comparando <literal>COM_EXECUTE</literal> con
         <literal>COM_PREPARE</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Comprobar si PHP ha ejecuato cualquier sentencia SQL no preparada
         comprobando si <literal>COM_QUERY</literal> es cero
        </para>
       </listitem>
       <listitem>
        <para>
         Identificar los scripts de PHP que ejecutan un número excesivo de
         sentencias SQL comprobando <literal>COM_QUERY</literal> y
         <literal>COM_EXECUTE</literal>
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Miscelánea</emphasis>
 </para>
 <table>
  <title>Estadísticas devueltas de mysqlnd: Miscelánea</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Estadística</entry>
     <entry>Ámbito</entry>
     <entry>Descrpción</entry>
     <entry>Notas</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>explicit_stmt_close</literal>,
      <literal>implicit_stmt_close</literal></entry>
     <entry>Proceso</entry>
     <entry>Número total de sentencias preparadas cerradas.</entry>
     <entry>Un cierre siempre es considerado explícito excepto para una preparación fallida.</entry>
    </row>
    <row>
     <entry><literal>mem_emalloc_count</literal>,
      <literal>mem_emalloc_ammount</literal>,
      <literal>mem_ecalloc_count</literal>,
      <literal>mem_ecalloc_ammount</literal>,
      <literal>mem_erealloc_count</literal>,
      <literal>mem_erealloc_ammount</literal>,
      <literal>mem_efree_count</literal>,
      <literal>mem_malloc_count</literal>,
      <literal>mem_malloc_ammount</literal>,
      <literal>mem_calloc_count</literal>,
      <literal>mem_calloc_ammount</literal>,
      <literal>mem_realloc_count</literal>,
      <literal>mem_realloc_ammount</literal>,
      <literal>mem_free_count</literal></entry>
     <entry>Proceso</entry>
     <entry>Llamadas de gestión de memoria.</entry>
     <entry>Solamente desarrollo.</entry>
    </row>
    <row>
     <entry><literal>command_buffer_too_small</literal></entry>
     <entry>Conexión</entry>
     <entry>Número de extensiones de buffer de comandos de red mientras se envían
      comando desde PHP a MySQL.</entry>
     <entry><para>
      mysqlnd asigna un buffer de comandos/red interno de
      <literal>mysqlnd.net_cmd_buffer_size</literal>
      (<filename>php.ini</filename>) bytes para cada conexión. Si un
      comando del protocolo Cliente Servidor de MySQL, por ejemplo,
      <literal>COM_QUERY</literal> (consulta normal), no se ajusta al
      buffer, mysqlnd will aumentará el buffer lo que sea necesario para
      enviar el comando. Siempre que el buffer se extienda para una
      conexión, <literal>command_buffer_too_small</literal> será
      incrementado en uno.
      </para>
      
      <para>
       Si mysqlnd tiene que aumentar el buffer más allá de su tamaño inicial de
       <literal>mysqlnd.net_cmd_buffer_size</literal>
       (<filename>php.ini</filename>) bytes para casi todas las conexiones,
       se debería considerar aumentar el tamaño predeterminado para evitar
       reasignaciones.
      </para>
      
      <para>
       El tamaño predeterminado del buffer es de 2048 bytes en PHP 5.3.0. En futuras
       versiones, el tamaño predeterminado serán de 4kB o más. Se puede cambiar el valor
       predeterminado a través de <filename>php.ini</filename> estableciendo
       <literal>mysqlnd.net_cmd_buffer_size</literal> o usando
       <literal>mysqli_options(MYSQLI_OPT_NET_CMD_BUFFER_SIZE, int
        tamaño)</literal>.
      </para>
      
      <para>
       Se recomienda establecer el tamaño de buffer a no menos de 4096
       bytes debido a que mysqlnd también lo utiliza al leer ciertos
       paquete de comunicación desde MySQL. En PHP 5.3.0, mysqlnd no
       aumentará el buffer si MySQL envía un paquete que es más grande que el
       tamaño actual del buffer. Como consecuencia, mysqlnd no es capaz de
       decodificar el paquete y la aplicación cliente obtendrá un error.
       Solamente hay dos situacioines en las que un paquete es más grande que
       los 2048 bytes predeterminados de
       <literal>mysqlnd.net_cmd_buffer_size</literal> en PHP 5.3.0: el
       paquete transporta un mensaje de error muy grande, o el paquete contiene
       los metadatos de columnas de <literal>COM_LIST_FIELD</literal>
       (<function>mysql_list_fields</function>) y los metadatos provienen
       de una columna de cadena con un valor predeterminado muy grande (>1900
       bytes). No existe reporte de errores sobre esto - debería ocurrir raramente.
      </para>
      
      <para>
       A partir de PHP 5.3.2, mysqlnd no permite establecer buffers menores
       que 4096 bytes.
      </para></entry>
    </row>
    <row>
     <entry><literal>connection_reused</literal></entry>
     <entry></entry>
     <entry></entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
