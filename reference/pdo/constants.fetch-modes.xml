<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 86d3fb841e0206e2588896ad3c21432333535848 Maintainer: Marqitos Status: ready -->
<!-- Reviewed: no -->
<section xmlns="http://docbook.org/ns/docbook" xml:id="pdo.constants.fetch-modes">
 <title>Modos de recuperación</title>

 <simpara>
  Véase <link linkend="pdo.constants.cursors">constantes de cursor</link> para las
  constantes de cursor <literal>PDO::FETCH_ORI_*</literal>.
 </simpara>

 <section xml:id="pdo.fetch-modes.basic" annotations="chunk:false">
  <title>Modos básicos de recuperación</title>
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Modo de recuperación</entry>
      <entry>Resumen</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_DEFAULT</constant>
      </entry>
      <entry>
       Valor especial para usar el modo de recuperación por omisión actual.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_ASSOC</constant>
      </entry>
      <entry>
       Array indexado solo por el nombre de la columna.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_BOTH</constant> (Default)
      </entry>
      <entry>
       Array indexado tanto por el número de columna como por el nombre.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NAMED</constant>
      </entry>
      <entry>
       Variante de <constant>PDO::FETCH_ASSOC</constant> que conserva las
       columnas duplicadas.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NUM</constant>
      </entry>
      <entry>
       Array indexado solo por el número de columna.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_COLUMN</constant>
      </entry>
      <entry>
       Una sola columna.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_KEY_PAIR</constant>
      </entry>
      <entry>
       Pares clave-valor, indexados por la primera columna.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_FUNC</constant>
      </entry>
      <entry>
       Una una función para crear el valor de retorno.
       (solamente con <methodname>PDOStatement::fetchAll</methodname>)
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_OBJ</constant>
      </entry>
      <entry>
       Objeto anónimo (<classname>stdClass</classname>).
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASS</constant>
      </entry>
      <entry>
       Un objeto de la clase especificada.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.class-flags" annotations="chunk:false">
  <title>Opciones de PDO::FETCH_CLASS</title>

  <simpara>
   Estos modos se utilizan para implementar opciones al usar
   <constant>PDO::FETCH_CLASS</constant>.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Modo de recuperación</entry>
      <entry>Resumen</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASSTYPE</constant>
      </entry>
      <entry>
       Usa la primera columna como nombre de la clase.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_PROPS_LATE</constant>
      </entry>
      <entry>
       Llama al constructor antes de establecer las propiedades.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_SERIALIZE</constant>
      </entry>
      <entry>
       Usa datos serializados de PHP. Obsoleto a partir de PHP 8.1.0.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.single" annotations="chunk:false">
  <title>Modos de resultado único</title>

  <simpara>
   Los siguientes modos no pueden ser utilizados con
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Modo de recuperación</entry>
      <entry>Resumen</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_BOUND</constant>
      </entry>
      <entry>
       Asigna valores a las variables especificadas.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_INTO</constant>
      </entry>
      <entry>
       Actualiza un objeto existente.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_LAZY</constant>
      </entry>
      <entry>
       Recuperación diferida mediante <classname>PDORow</classname> para acceso
       similar a arrays y objetos.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.grouped" annotations="chunk:false">
  <title>
   Flags de comportamiento especiales para <methodname>PDOStatement::fetchAll</methodname>
  </title>

  <simpara>
   Los siguientes modos especiales para resultados múltiples solo funcionan con
   <methodname>PDOStatement::fetchAll</methodname> y no funcionan con algunos otros
   modos de recuperación. Consulta la documentación completa para más detalles.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Modo de recuperación</entry>
      <entry>Resumen</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_GROUP</constant>
      </entry>
      <entry>
       Los resultados se agrupan por la primera columna.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_UNIQUE</constant>
      </entry>
      <entry>
       Los resultados se indexan (únicamente) por la primera columna.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.duplicate-names" annotations="chunk:false">
  <title>Manejo de nombres duplicados de columnas</title>
  <simpara>
   Es posible que los resultados contengan varias columnas con el mismo nombre.
   Por ejemplo, al combinar dos tablas que contienen una columna con el mismo
   nombre.
  </simpara>
  <simpara>
   Debido a que las estructuras de PHP, como los arrays y los objetos, no admiten varias claves
   o propiedades con el mismo nombre, el array o el objeto devuelto contendrá
   solo uno de los valores con el mismo nombre.
  </simpara>
  <simpara>
   El valor que se devuelve para un nombre duplicado determinado debe considerarse
   indefinido.
  </simpara>
  <simpara>
   Para evitar este problema, asigne nombres explícitos a las columnas mediante un alias. Por ejemplo:
  </simpara>
  <informalexample>
   <programlisting role="sql">
<![CDATA[
SELECT table1.created_at AS t1_created_at,
       table2.created_at AS t2_created_at
FROM table1
JOIN table2 ON table1.table2id = table2.id
]]>
   </programlisting>
  </informalexample>
  <simpara>
   Véase también <constant>PDO::FETCH_NAMED</constant>,
   <constant>PDO::ATTR_FETCH_TABLE_NAMES</constant> y
   <constant>PDO::ATTR_FETCH_CATALOG_NAMES</constant>.
  </simpara>
 </section>

 <section xml:id="pdo.fetch-modes.default" annotations="chunk:false">
  <title>Estableciendo el modo de recuperación predeterminado</title>
  <simpara>
   Es posible establecer el modo de recuperación predeterminado para todas las consultas usando
   <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant> con
   <methodname>PDO::__construct</methodname> o
   <methodname>PDO::setAttribute</methodname>.
  </simpara>
  <simpara>
   El modo de recuperación predeterminado para una sentencia específica se puede establecer usando
   <methodname>PDOStatement::setFetchMode</methodname>.
   Esto afecta a la reutilización como sentencia preparada y a la iteración (usando
   &foreach;).
  </simpara>
  <caution>
   <simpara>
    <methodname>PDOStatement::setAttribute</methodname> no se puede usar para establecer el
    modo de recuperación predeterminado. Solo acepta atributos específicos del controlador y, de forma silenciosa,
    ignora los atributos que no reconoce.
   </simpara>
  </caution>
 </section>

 <section xml:id="pdo.constants.fetch-default" annotations="chunk:false">
  <title>PDO::FETCH_DEFAULT (<type>int</type>)</title>
  <simpara>
   Disponible a partir de PHP 8.0.7.
  </simpara>
  <simpara>
   Este es un valor especial que utiliza el modo de recuperación predeterminado actual para un
   <classname>PDOStatement</classname>. Es especialmente útil como valor predeterminado
   para los parámetros de método al extender
   <classname>PDOStatement</classname> para su uso con
   <constant>PDO::ATTR_STATEMENT_CLASS</constant>.
  </simpara>
  <simpara>
   Este valor no se puede usar con
   <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant>.
  </simpara>
 </section>

 <section xml:id="pdo.constants.fetch-assoc" annotations="chunk:false">
  <title>PDO::FETCH_ASSOC (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_ASSOC</constant> devuelve un array indexada únicamente por
   nombre de columna.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-both" annotations="chunk:false">
  <title>PDO::FETCH_BOTH (<type>int</type>)</title>
  <simpara>
   Este es el modo de recuperación predeterminado.
  </simpara>
  <simpara>
   <constant>PDO::FETCH_BOTH</constant> devuelve un array indexada tanto por número
   de columna como por nombre. Esto significa que cada valor devuelto se duplica para cada
   fila de resultados.
  </simpara>
  <simpara>
   El número de columna comienza en 0 y se determina por el orden de las columnas de
   la consulta, no (por ejemplo) por el orden en que se definen las columnas en la tabla.
  </simpara>
  <note>
   <simpara>
    No se recomienda utilizar el índice de columna numérico, ya que esto puede cambiar cuando
    se cambie la consulta, o cuando se cambie el esquema de la tabla al usar
    <literal>SELECT *</literal>.
   </simpara>
  </note>
  <note>
   <simpara>
    Es posible que el número de entradas indexadas por nombre no coincida con el número de entradas indexadas
    por número en los casos en que varias columnas devueltas utilicen el mismo
    nombre.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_BOTH);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [id] => 104,
    [0] => 104,
    [name] => Chris,
    [1] => Chris,
    [country] => Ukraine,
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-named" annotations="chunk:false">
  <title>PDO::FETCH_NAMED (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_NAMED</constant> devuelve resultados en el mismo formato que
   <constant>PDO::FETCH_ASSOC</constant> excepto que, cuando varias columnas usan
   el mismo nombre, todos los valores se devuelven como una lista.
  </simpara>
  <simpara>
   Para obtener más información sobre el manejo de nombres de columnas duplicados y alternativas,
   consulte la sección <link linkend="pdo.fetch-modes.duplicate-names">manejo de
   nombres duplicados</link> anterior.
  </simpara>
  <simpara>
   El orden en el que se devuelven los valores duplicados debe considerarse
   indefinido. No hay forma de saber de dónde proviene cada valor.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query(
    "SELECT users.*, referrer.name
     FROM users
     LEFT JOIN users AS referrer ON users.referred_by = referrer.userid
     WHERE userid = 109"
);
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 109
    [name] => Array
        (
            [0] => Toni
            [1] => Chris
        )
    [country] => Germany
    [referred_by] = 104
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-num" annotations="chunk:false">
  <title>PDO::FETCH_NUM (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_NUM</constant> devuelve un array indexada únicamente por número
   de columna. El número de columna comienza en 0 y se determina por el orden de las columnas de resultados en
   la consulta, no (por ejemplo) por el orden en que se definen las columnas en la tabla.
  </simpara>
  <note>
   <simpara>
    No se recomienda utilizar el índice de columna numérico, ya que esto puede cambiar cuando
    se cambie la consulta, o cuando se cambie el esquema de la tabla al usar
    <literal>SELECT *</literal>.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => 104
    [1] => Chris
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-column" annotations="chunk:false">
  <title>PDO::FETCH_COLUMN (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_COLUMN</constant> devuelve los valores de una sola columna.
   Utilice el segundo argumento de <methodname>PDOStatement::setFetchMode</methodname>
   o <methodname>PDOStatement::fetchAll</methodname> para especificar la columna que
   se devuelve.
  </simpara>
  <simpara>
   Si la columna especificada no existe, se lanzará un
   <classname>ValueError</classname>.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN);
print_r($row);

$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN, 1);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Chris
    [1] => Jamie
    [2] => Robin
)

Array
(
    [0] => Ukraine
    [1] => England
    [2] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-key-pair" annotations="chunk:false">
  <title>PDO::FETCH_KEY_PAIR (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_KEY_PAIR</constant> devuelve pares de valores, indexados por
   la primera columna. Los resultados deben contener solo dos columnas. Este modo de recuperación
   solo tiene sentido con <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <note>
   <simpara>
    Si la primera columna no es única, se perderán valores. Qué valor(es) se
    perderán debe considerarse indefinido.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_KEY_PAIR);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Chris] => Ukraine
    [Jamie] => England
    [Robin] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-func" annotations="chunk:false">
  <title>PDO::FETCH_FUNC (<type>int</type>)</title>
  <simpara>
   Especifique una función para crear el valor devuelto. Este modo solo se puede usar
   con <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   La función recibe los valores como parámetros.
   No es posible recuperar el nombre de la columna a la que estaba asociado un valor dado.
   Es crucial asegurarse de que el orden de las columnas en la consulta coincida con el
   orden de los parámetros de la función.
  </simpara>
  <note>
   <simpara>
    Los efectos de <constant>PDO::FETCH_GROUP</constant> y
    <constant>PDO::FETCH_UNIQUE</constant> se aplican a los resultados antes de
    que se llame a la función.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function valueCreator($col1, $col2, $col3)
{
    return [
        'col1' => $col1,
        'col2' => strtoupper($col2),
        'col3' => $col3,
        'customKey' => 'customValue',
    ];
}

$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_FUNC, valueCreator(...));
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [col1] => 104
            [col2] => SAM
            [col3] => Ukraine
            [customKey] => customValue
        )

    [1] => Array
        (
            [col1] => 105
            [col2] => JAMIE
            [col3] => England
            [customKey] => customValue
        )

    [2] => Array
        (
            [col1] => 107
            [col2] => ROBIN
            [col3] => Germany
            [customKey] => customValue
        )

)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-obj" annotations="chunk:false">
  <title>PDO::FETCH_OBJ (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_OBJ</constant> devuelve un objeto
   <classname>stdClass</classname>.
  </simpara>
  <simpara>
   Véase también <methodname>PDOStatement::fetchObject</methodname> y
   <constant>PDO::FETCH_CLASS</constant>.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_OBJ);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
stdClass Object
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-class" annotations="chunk:false">
  <title>PDO::FETCH_CLASS (<type>int</type>)</title>
  <simpara>
   Devuelve un objeto de una clase específica. Para conocer comportamientos adicionales, consulte las
   <link linkend="pdo.fetch-modes.class-flags">opciones flags</link>.
  </simpara>
  <simpara>
   Si una propiedad no existe con el nombre de una columna devuelta, se
   declarará dinámicamente. Este comportamiento está obsoleto y provocará un error
   a partir de PHP 9.0.
  </simpara>
  <simpara>
   Véase también <methodname>PDOStatement::fetchObject</methodname>.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? Yes
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-classtype" annotations="chunk:false">
  <title>PDO::FETCH_CLASSTYPE (<type>int</type>)</title>
  <simpara>
   Este modo de recuperación solo se puede usar combinado con
   <constant>PDO::FETCH_CLASS</constant> (y
   <link linkend="pdo.fetch-modes.class-flags">sus otras opciones</link>).
  </simpara>
  <simpara>
   Cuando se utiliza este modo de recuperación, PDO utilizará la primera columna devuelta como
   nombre de la clase que se devolverá.
  </simpara>
  <simpara>
   Si no se encuentra la clase especificada, se devolverá un objeto
   <classname>stdClass</classname>, sin advertencia ni error.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT 'TestEntity', userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_CLASSTYPE);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? Yes
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-props-late" annotations="chunk:false">
  <title>PDO::FETCH_PROPS_LATE (<type>int</type>)</title>
  <simpara>
   Este modo de recuperación solo se puede usar combinado con
   <constant>PDO::FETCH_CLASS</constant> (y
   <link linkend="pdo.fetch-modes.class-flags">sus otras opciones</link>).
  </simpara>
  <simpara>
   Cuando se utiliza este modo de recuperación, se llamará al constructor antes de
   que se establezcan las propiedades.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? No
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-serialize" annotations="chunk:false">
  <title>PDO::FETCH_SERIALIZE (<type>int</type>)</title>
  &warn.deprecated.feature-8-1-0;
  <simpara>
   Este modo de recuperación solo se puede usar combinado con
   <constant>PDO::FETCH_CLASS</constant> (y
   <link linkend="pdo.fetch-modes.class-flags">sus otras opciones</link>).
  </simpara>
  <simpara>
   Cuando se utiliza este modo de recuperación, la clase especificada debe ser
   <interfacename>Serializable</interfacename>.
  </simpara>
  <caution>
   <simpara>
    Esta función no admite un string que contenga un objeto serializado completo
    (con <function>serialize</function>).
   </simpara>
  </caution>
  <caution>
   <simpara>
    Este modo de recuperación no llama al constructor.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity implements Serializable
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor llamado con " . count(func_get_args()) . " argumentos\n";
        print "¿Propiedades establecidas cuando se llama al constructor? "
            . (isset($this->name) ? 'Sí' : 'No') . "\n";
    }

    public function serialize()
    {
        return join(
            "|",
            [$this->userid, $this->name, $this->country, $this->referred_by_userid]
        );
    }

    public function unserialize(string $data)
    {
        $parts = explode("|", $data);
        $this->userid = (int) $parts[0];
        $this->name = $parts[1];
        $this->country = $parts[2];

        $refId = $parts[3];
        $this->referred_by_userid = ($refId === "" ? null : (int) $refId);
    }
}

print "Establecer registro (constructor llamado manualmente):\n";
$db->exec(
    "CREATE TABLE serialize (
        sdata TEXT
    )"
);

$origObj = new TestEntity();
$origObj->userid = 200;
$origObj->name = 'Seri';
$origObj->country = 'Syria';
$origObj->referred_by_userid = null;

$insert = $db->prepare("INSERT INTO serialize (sdata) VALUES (:sdata)");
$insert->execute(['sdata' => $origObj->serialize()]);

print "\nObtener resultados:\n";
$query = "SELECT sdata FROM serialize";
$stmt = $db->query($query);
// NOTA: El constructor nunca se llama!
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_SERIALIZE, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Deprecated: TestEntity implements the Serializable interface, which is deprecated. Implement __serialize() and __unserialize() instead (or in addition, if support for old PHP versions is necessary) in Standard input code on line 2
Establecer registro (constructor llamado manualmente):
Constructor llamado con 0 argumentos
¿Propiedades establecidas cuando se llama al constructor? No

Obtener resultados:
Deprecated: PDOStatement::setFetchMode(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 58

Deprecated: PDOStatement::fetch(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 59
object(TestEntity)#5 (4) {
  ["userid"]=>
  int(200)
  ["name"]=>
  string(4) "Seri"
  ["country"]=>
  string(5) "Syria"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-bound" annotations="chunk:false">
  <title>PDO::FETCH_BOUND (<type>int</type>)</title>
  <simpara>
   Este modo de recuperación no se puede utilizar con
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Este modo de recuperación no devuelve directamente un resultado, sino que asigna valores a
   las variables especificadas con <methodname>PDOStatement::bindColumn</methodname>. El
   método de recuperación llamado devuelve &true;.
  </simpara>
  <note>
   <simpara>
    Cuando se utilizan sentencias preparadas, para que funcionen correctamente, las variables deben enlazarse
    después de que se ejecute la consulta.
   </simpara>
  </note>
  <programlisting role="php">
<![CDATA[
<?php
$query = "SELECT users.userid, users.name, users.country, referrer.name
    FROM users
    LEFT JOIN users AS referrer ON users.referred_by_userid = referrer.userid";
$stmt = $db->prepare($query);
$stmt->execute();

$stmt->bindColumn('userid', $userId);
$stmt->bindColumn('name', $name);
$stmt->bindColumn('country', $country);
// Se utiliza la posición de la columna para resolver nombres de columna duplicados.
// Para evitar que esto falle si se modifica la consulta, se recomienda usar un alias SQL.
// Por ejemplo: referrer.name AS referrer_name
$stmt->bindColumn(4, $referrerName);

while ($stmt->fetch(\PDO::FETCH_BOUND)) {
    print join("\t", [$userId, $name, $country, ($referrerName ?? 'NULL')]) . "\n";
}
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
104	Chris	Ukraine	NULL
105	Jamie	England	NULL
107	Robin	Germany	Chris
108	Sean	Ukraine	NULL
109	Toni	Germany	NULL
110	Toni	Germany	NULL
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-into" annotations="chunk:false">
  <title>PDO::FETCH_INTO (<type>int</type>)</title>
  <simpara>
   Este modo de recuperación no se puede utilizar con
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Este modo de recuperación actualiza las propiedades del objeto especificado. El objeto se
   devuelve si la operación se realiza correctamente.
  </simpara>
  <simpara>
   Si una propiedad no existe con el nombre de una columna devuelta, se
   declarará dinámicamente. Este comportamiento está obsoleto y provocará un error
   a partir de PHP 9.0.
  </simpara>
  <simpara>
   Las propiedades deben ser <literal>public</literal> y no pueden ser
   <literal>readonly</literal>.
  </simpara>
  <caution>
   <simpara>
    No hay forma de cambiar el objeto que se va a actualizar sin usar
    <methodname>PDOStatement::setFetchMode</methodname> entre la recuperación de cada
    registro.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;
}

$obj = new TestEntity();
$stmt->setFetchMode(\PDO::FETCH_INTO, $obj);

$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-lazy" annotations="chunk:false">
  <title>PDO::FETCH_LAZY (<type>int</type>)</title>
  <simpara>
   Este modo de recuperación no se puede utilizar con
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Este modo de obtención recuperación un objeto <classname>PDORow</classname> que proporciona acceso
   a los valores tanto como arrays como objetos (es decir, combina el comportamiento de
   <constant>PDO::FETCH_BOTH</constant> y
   <constant>PDO::FETCH_OBJ</constant>), recuperados de forma diferida.
  </simpara>
  <simpara>
   Esto permite un acceso eficiente en memoria (en el lado de PHP) a los resultados sin almacenar
   en búfer en el servidor de la base de datos. El uso o no de almacenamiento en búfer del lado del cliente por parte
   de PDO depende del controlador específico de la base de datos que se utilice (y de su configuración).
  </simpara>
  <caution>
   <simpara>
    <classname>PDORow</classname> devolverá <literal>NULL</literal> sin
    mostrar ningún error ni advertencia al acceder a propiedades o claves no definidas.
    Esto puede dificultar la detección y depuración de errores como erratas o consultas que
    no devuelven los datos esperados.
   </simpara>
  </caution>
  <caution>
   <simpara>
    El objeto <classname>PDORow</classname> devuelto se actualiza cada vez que
    se recupera un resultado.
   </simpara>
  </caution>
  <programlisting role="php">
<![CDATA[
<?php
$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch(\PDO::FETCH_LAZY);

print "ID: ". $result[0] ."\n";
print "Nombre: {$result->name}\n";
print "País: " . $result['country'] ."\n";
// Devuelve NULL. No se genera ninguna advertencia ni error.
print "No existe: " . var_export($result->does_not_exist, true) . "\n";

$differentResult = $stmt->fetch(\PDO::FETCH_LAZY);
// El PDOrow recuperado previamente ahora apunta al resultado recién recuperado.
print "ID: ". $result[0] ."\n";

]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
ID: 104
Nombre: Chris
País: Ukraine
No existe: NULL
ID: 105
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-group" annotations="chunk:false">
  <title>PDO::FETCH_GROUP (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_GROUP</constant> devuelve listas de arrays asociativos,
   indexados por una columna (no única). Este modo de obtención solo funciona con
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Cuando se combina con <constant>PDO::FETCH_UNIQUE</constant>, ambos modos
   utilizarán la misma columna, lo que hace que la combinación de estos modos sea inútil.
  </simpara>
  <simpara>
   Esta recuperación debe combinarse con una de
   <constant>PDO::FETCH_ASSOC</constant>, <constant>PDO::FETCH_BOTH</constant>,
   <constant>PDO::FETCH_NAMED</constant>, <constant>PDO::FETCH_NUM</constant>,
   <constant>PDO::FETCH_COLUMN</constant> o
   <constant>PDO::FETCH_FUNC</constant>.
  </simpara>
  <simpara>
   Si no se proporciona ningún modo de recuperación de la lista anterior, se utilizará
   el modo de recuperación predeterminado actual para <classname>PDOStatement</classname>.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT country, userid, name FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                )
        )
)
]]>
   </screen>
  </informalexample>
  <simpara>
   En el ejemplo anterior, cabe señalar que la primera columna se omite del
   array en cada fila y solo está disponible como clave. Se puede incluir
   repitiendo la columna, como en el siguiente ejemplo:
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT country, userid, name, country FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                    [country] => Ukraine
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                    [country] => Ukraine
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                    [country] => England
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                    [country] => Germany
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                    [country] => Germany
                )
        )
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-unique" annotations="chunk:false">
  <title>PDO::FETCH_UNIQUE (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_UNIQUE</constant> utiliza la primera columna para indexar los registros,
   devolviendo un registro por cada valor de índice. Este modo de recuperación solo funciona con
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Cuando se combina con <constant>PDO::FETCH_GROUP</constant>, ambos modos utilizarán
   la misma columna, lo que hace que la combinación de estos modos sea inútil.
  </simpara>
  <simpara>
   Esta recuperación debe combinarse con uno de
   <constant>PDO::FETCH_ASSOC</constant>, <constant>PDO::FETCH_BOTH</constant>,
   <constant>PDO::FETCH_NAMED</constant>, <constant>PDO::FETCH_NUM</constant>,
   <constant>PDO::FETCH_COLUMN</constant> o
   <constant>PDO::FETCH_FUNC</constant>.
  </simpara>
  <simpara>
   Si no se proporciona ningún modo de recuperación de la lista anterior, se utilizará
   el modo de recuperación predeterminado actual para <classname>PDOStatement</classname>.
  </simpara>
  <simpara>
   Cuando se utiliza con una columna que se sabe que es única (como el ID del registro), este
   modo proporciona la capacidad de devolver rápidamente resultados indexados por ese valor.
  </simpara>
  <note>
   <simpara>
    Si la primera columna no es única, se perderán valores. Qué valor(es) se
    perderán se considera indefinido.
   </simpara>
  </note>
  <caution>
   <simpara>
    Siempre que sea posible, se recomienda filtrar los registros mediante SQL. La base de datos
    utilizará índices para optimizar este proceso y devolver únicamente los registros necesarios.
    Seleccionar más registros de los necesarios puede aumentar significativamente
    el uso de memoria y el tiempo de consulta para conjuntos de resultados grandes.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
  <simpara>
   En el ejemplo anterior, cabe señalar que la primera columna se omite del
   array en cada fila y solo está disponible como clave. Se puede incluir
   repitiendo la columna, como en el siguiente ejemplo:
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [userid] => 104
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [userid] => 105
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [userid] => 107
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
 </section>

</section>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
