<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 4e23ca434384b5973f80f1a89e1bd3699a2f2f67 Maintainer: chuso Status: ready -->

<section xml:id="mongo.writes" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Escrituras</title>

 <section>
  <title>Operaciones Seguras</title>
  <para>
   Por omisión, el driver no espera a que la base de datos responda para realizar las escrituras
   (inserciones, actualizaciones, y eliminacioens). Esto significa que las escrituras pueden llevars a cabo
   extremadamente rápido, pero no puede saberse si realmente han tenido o no éxito.
   Existen varias razones para que una escritura falle: si hay problemas de red, si
   el servidor de bases de datos se cae, o simplemente que la escritura era inválida (p.ej., 
   escribir en una colección del sistema).
  </para>
  <para>
   Para obtener una respuesta de la base de datos, utilice la opción <literal>safe</literal>,
   disponible en todos los tipos de escritura. Esta opción se asegura de que la base de datos
   realiza la escritura antes de notificar del éxito. Si la escritura falla,
   emitirá una excepción <function>MongoCursorException</function>, explicando
   la razón del fallo.
  </para>
  <para>
   Durante la etapa de desarrollo, deben usarse siempre escrituras seguras (para prevenir
   errores involuntarios, como errores de claves duplicadas y similares). En el entorno
   de producción, pueden usarse escrituras no seguras sobre datos "no importantes". Los datos no
   importantes dependen de la aplicación, pero se suele tratar de datos automáticos (en lugar de
   datos generados por el usuario), como un contador de clics o las coordenadas GPS, donde se
   puede obtener miles de registros por segundo.
  </para>
  <para>
   Para llevar a cabo escrituras seguras sin que ello suponga un impacto en el rendimiento,
   se recomienda realizar la escritura segura al finalizar una serie de escrituras.
   Por ejemplo:
  </para>
  <programlisting role="php">
<![CDATA[

$collection->insert($someDoc);
$collection->update($criteria, $newObj);
$collection->insert($somethingElse);
$collection->remove($something, array("safe" => true));

]]>
  </programlisting>
  <para>
   De este modo, si la última escritura lanza una excepción, sabrá que hay un
   problema con la base de datos.
  </para>
  <para>
   Hay más opciones disponible para asegurar la seguridad de las escrituras. Puede
   especificarse <literal>"fsync" =&gt; true</literal> para forzar a la base de datos a
   fsync (sincronizar) todas las escrituras en disco realizadas hasta ahora (por omisión,
   MongoDB sincroniza en disco las escrituras una vez por minuto).
  </para>
  <para>
   La forma más segura de realizar una escritura consiste en usar réplicas y en especificar
   el número de servidores en que se harán las escrituras antes de obtener el éxito. (En producción
   siempre deben usarse réplicas, revise la sección de Conexión para más información sobre
   conjuntos de réplicas.)
  </para>
  <programlisting role="php">
<![CDATA[

$collection->insert($someDoc, array("safe" => 3));

]]>
  </programlisting>
  <para>
   Si indica <literal>"safe" =&gt; N</literal>, el servidor MongoDB se asegurará
   de que al menos <literal>N</literal> servidores tienen una copia de la escritura
   antes de notificar el éxito. De modo que, si <literal>N</literal> es 3, el maestro y al menos
   2 esclavos deben haber realizado las escrituras.
  </para>
 </section>

 <section>
  <title>Actualizando Objetos Anidados</title>

  <para>
   Supogamos que queremos cambiar el nombre del autor de un comentario en este documento:

   <programlisting>
<![CDATA[
{ 
    "_id" : ObjectId("4b06c282edb87a281e09dad9"), 
    "content" : "this is a blog post.",
    "comments" : 
    [
        {
            "author" : "Mike",
            "comment" : "I think that blah blah blah...",
        },
        {
            "author" : "John",
            "comment" : "I disagree."
        }
    ]
}
]]>
   </programlisting>

   Para cambiar un campo interno, usamos $set (de manera que el resto de campos no
   se eliminen) con el índice del comentario a cambiar:

   <programlisting role="php">
<![CDATA[
<?php

$blog->update($criteria, array('$set' => array("comments.1" => array("author" => "Jim"))));

?>
]]>
   </programlisting>
  </para>
 </section>

 <section>
  <title>El Operador Posicional</title>
  <para>
   El operador posicional <literal>$</literal> es útil a la hora de actualizar objetos
   en arrays. En el ejemplo anterior, por ejemplo, podríamos no conocer el índice del comentario
   que necesitamos modificar, sólo sabemos que queremos cambiar "John" a "Jim". Podemos usar
   <literal>$</literal> para lograrlo.
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$blog->update(
    array("comments.author" => "John"), 
    array('$set' => array('comments.$.author' => "Jim")));

?>
]]>
  </programlisting>
 </section>
</section>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

