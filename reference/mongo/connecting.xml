<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: bc129e08ecf1d8d2a1505c6305a77aecfad62b2b Maintainer: seros Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mongo.connecting" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Conexión</title>
 
 <para>
  La conexión a MongoDB es tan fácil como usar <literal>new MongoClient</literal>,
  pero hay muchas más opciones y configuraciones adicionales. La documentación
  para <function>Mongo::__construct</function> cubre todas las opciones de la API,
  pero está página ofrece más detalles y consejos para casos de uso
  prácticos.
 </para>
 
 <section xml:id="mongo.connecting.auth">
  <title>Autenticación</title>
  <para>
   Si MongoDB se inicia con las opciones <literal>--auth</literal> o
   <literal>--keyFile</literal>, se debe autenticar antes de poder realizar
   cualquier operación con el controlador. Se podría autenticar una conexión
   especificando el nombre de usuario y la contraseña, o bien en el URI de conexión, o bien
   en las opciones <literal>"username"</literal> y <literal>"password"</literal> de
   <function>MongoClient::__construct</function>.
  </para>
  <example xml:id="mongo.connecting.auth-example">
   <title>Autenticación en la base de datos "admin"</title>
   <programlisting role="php">
<![CDATA[
<?php
// Especificar el nombre de usuario y la contraseña en el URI de conexión (preferido)
$m = new MongoClient("mongodb://${username}:${password}@localhost");

// Especificar el nombre de usuario y la contraseña mediante el arrar de opciones (alternativa)
$m = new MongoClient("mongodb://localhost", array("username" => $username, "password" => $password));
?>
]]>
   </programlisting>
  </example>
  <para>
   Por omisión, el controlador autenticará en la base de datos <literal>admin</literal>.
   Se podría autenticar en una base de datos diferente especificándola
   en el URI de conexión o en la opción <literal>"db"</literal> de
   <function>MongoClient::__construct</function>.
  </para>
  <example xml:id="mongo.connecting.auth-db-example">
   <title>Autenticación en bases de datos normales</title>
   <programlisting role="php">
<![CDATA[
<?php
// Especificar la base de datos de autenticación en la URI de conexión (preferido)
$m = new MongoClient("mongodb://${username}:${password}@localhost/myDatabase");

// Especificar la base de datos de autenticación mediante el arrar de opciones (alternativa)
$m = new MongoClient("mongodb://${username}:${password}@localhost", array("db" => "myDatabase"));
?>
]]>
   </programlisting>
  </example>
  <para>
   Si la conexión se your connection is dropped, the driver will automatically attempt to
   reconnect and reauthenticate you.
  </para>
 </section>
 
 <section xml:id="mongo.connecting.rs">
  <title>Conjuntos de réplicas</title>
  <para>
   Para conectarse a un grupo réplica, se debe especificar uno o más miembros del grupo usando
   la opción <literal>replicaSet</literal>. Se pueden delimitar múltiples servidores
   mediante comas.
  </para>
  <example xml:id="mongo.connecting.rs-example">
   <title>Lista de semillas de ReplicaSet</title>
   <programlisting role="php">
<![CDATA[
<?php
// Usar múltiples servidores como lista de semillas (preferido)
$m = new MongoClient("mongodb://rs1.example.com:27017,rs2.example.com:27017/?replicaSet=myReplSetName"));

// Usar un servidor como lista de semillas
$m = new MongoClient("mongodb://rs1.example.com:27017", array("replicaSet" => "myReplSetName"));

// Usar múltiples servidores como lista de semillas
$m = new MongoClient("mongodb://rs1.example.com:27017,rs2.example.com:27017", array("replicaSet" => "myReplSetName"));
?>
]]>
   </programlisting>
  </example>
  <para>
   El driver de PHP hará una petición al servidor(es) de base de datos listados para determinar el
   primario.  Mientras se pueda conectar almenos a uno de los servidores listados y pueda encontrar un 
   primario, la conexión se establecerá con éxito. Si no se puede realizar una conexión a ninguno de
   los servidores listados o no puede encontrar un primario, será lanzada una
   <classname>MongoConnectionException</classname>.
  </para>
  <tip>
   <para>
    Se debería proporcionar siempre una lista de semillas con más de un miembro del
    ReplicaSet. Para una mayor disponibilidad se debería sembrar con al menos un
    servidor de cada centro de datos.
   </para>
  </tip>
  <warning>
   <para>
    Los nombres de host que se especifiquen aquí <emphasis>deben</emphasis> coincidir con
    los nombres dados en la configuración del conjunto de réplica debido a que el controlador usa el
    nombre como se especifica en la configuración del conjunto de réplica como identificador en su
    correspondencia interna. Especificar (por ejemplo) la dirección IP en lugar del nombre
    de host configurado hará que el controlador mantenga una conexión tanto para el
    nombre del host como para su dirección IP acompañante.
   </para>
  </warning>
  <para>
   Si el primario no está disponible, se hará una elección y se promoverá
   un secundario al rol de primario (a menos que no se pueda establecer
   un voto mayoritario). Durante este tiempo
   (<link xlink:href="&url.mongodb.replica.failover;">20-60 segundos</link>), la
   conexión no podrá ralizar ninguna operación de escritura, por lo que intentarlo
   resultará en una excepción. Las conexiones a secundarios aún podrán
   realizar lecturas.
  </para>
  <note>
   <para>
    La <link linkend="mongo.readpreferences">Preferencias de lectura</link> predeterminada
    solamente es para leer desde el primario. Durante el proceso de elección no hay
    primario, por lo que todas las lecturas fallarán.
   </para>
   <para>
    Se recomienda usar la preferencia de lectura
    <constant>MongoClient::RP_PRIMARY_PREFERRED</constant> para
    aplicaciones que requieren una alta disponibilidad de lecturas, ya que las lecturas solamente
    serán ejecutadas en los secundarios cuando simplemente no haya un primario
    disponible.
   </para>
  </note>
  <para>   
   Una vez que el primario es elegido, el intento de realizar una lectura o escritura
   permitirá al controlador detectar el nuevo primario. El controlador hará de esta su conexión
   de bases de datos primaria y continuará operando normalmente.
  </para>
  <para>
   La salud y el estado de un secundario se comprueba cada 5 segundos
   (configurable con
   <link linkend="ini.mongo.ping-interval">mongo.ping_interval</link>)
   o cuando la siguiente operación ocurra después de 5 segundos. También recomprobará
   la configuración cuando el controlador tenga un problema al llegar al servidor.
  </para>
  <para>
   La tolerancia a fallos del conjunto de réplicas se verifica cada 60 segundos (configurable con
   <link linkend="ini.mongo.is-master-interval">mongo.is_master_interval</link>),
   y siempre que una operación de escritura falle cuando se utilicen escrituras aceptadas.
  </para>
  
  <caution>
   <para>
    Los secundarios podrían estar detrás del primario en las operaciones, por lo que
    la aplicación debe poder manejar datos desactualizados cuando se usan preferencias
    de lectura distintas de <constant>MongoClient::RP_PRIMARY</constant>.
   </para>
  </caution>
  
  <para>
   Para obtener más información acerca de conjuntos de réplica, consulte la 
   <link xlink:href="&url.mongodb.replica;">documentación del núcleo</link>.
  </para>
  
  <simplesect role="seealso">
   &reftitle.seealso;
   <simplelist>
    <member><xref linkend="mongo.readpreferences" /></member>
    <member><xref linkend="mongo.writeconcerns" /></member>
   </simplelist>
  </simplesect>
  
  <simplesect role="changelog">
   &reftitle.changelog;
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>1.0.9</entry>
       <entry>
        Se añadió el soporte para conexiones a ReplicaSet y tolerancia a fallos automática.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </simplesect>
  
 </section>
 
 <section xml:id="mongo.connecting.mongos">
  <title>Fragmentación</title>
  <para>
   Para conectarse a un clúster fragmentado se ha de especificar la dirección de una o más
   instancias de <literal>mongos</literal> en la cadena de conexión. Se pueden delimitar
   múltiples servidores mediante comas.
  </para>
  <example xml:id="mongo.connecting.mongos-example">
   <programlisting role="php">
<![CDATA[
<?php
// Usar un servidor como lista de semillas
$m = new MongoClient("mongodb://mongos1.example.com:27017");

// Usar múltiples servidores como lista de semillas
$m = new MongoClient("mongodb://mongos1.example.com:27017,mongos2.example.com:27017"));
?>
]]>
   </programlisting>
  </example>
  <para>
   Independientemente de si cada fragmento es un servidor <literal>mongod</literal>
   independiente o un conjunto de réplicas complemto, el proceso de conexión del controlador es el mismo.
   Toda comunicación con la base de datos será enviada a través de <literal>mongos</literal>.
  </para>
  <para>
   Para más información sobre la fragmentación con MongoDB, véase la
   <link xlink:href="&url.mongodb.docs.sharding;">documentación de fragmentación</link>.
  </para>
 </section>
 
 <section xml:id="mongo.connecting.uds">
  <title>Soporte de Socket de dominio</title>
  
  <para>
   MongoDB posee un soporte interno para socket de dominio Unix y abrirá el
   socket al inicio, por omisión unicado en <filename>/tmp/mongodb-&lt;port&gt;.sock.</filename>.
  </para>
  
  <para>
   Para conectarse al fichero socket, especifique la ruta de la conexión
   MongoDB:
  </para>
  
  <example xml:id="mongo.connecting.uds-example">
   <programlisting role="php">
<![CDATA[
<?php
$m = new MongoClient("mongodb:///tmp/mongo-27017.sock");
?>
]]>
   </programlisting>
  </example>
  
  <para>
   Si se quisiera autenticarse en una base de datos (como está descrito arriba)
   con un fichero de socket, se debe especificar un puerto de <literal>0</literal>, y así
   el analizador de cadenas de conexiones podrá detectar el final de la ruta del socket.
   Alternativamente, se pueden usar las opciones del constructor.
  </para>
  
  <example xml:id="mongo.connecting.uds-auth-example">
   <programlisting role="php">
<![CDATA[
<?php
$m = new MongoClient("mongodb://username:password@/tmp/mongo-27017.sock:0/foo");
?>
]]>
   </programlisting>
  </example>
  
  <simplesect role="changelog">
   &reftitle.changelog;
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>1.0.9</entry>
       <entry>
        Se añadió el soporte para sockets de domicio Unix.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </simplesect>
  
 </section>
 
 <section xml:id="mongo.connecting.pools">
  <title>Agrupación de conexiones (versión 1.2.0-1.2.12 *solamente*)</title>
  <note>
   <para>
    Esta sección ya no tiene relevancia a partir de la versión 1.3.0 del controlador
    y únicamente sirve como información histórica de cómo solía funcionar la
    agrupación.
   </para>
   <para>
    Las últimas versiones del controlador ya no posee el concepto de agrupación, por lo que
    solamente mantendrá una conexión por proceso, para cada tipo de conexión
    (ReplicaSet/standalone/mongos), para cada combinación de credenciales.
   </para>
  </note>
  <para>
   La creación de conexiones es uno de las cosas más pesada que el driver 
   realiza. Puede tomar miles de milisegundos establecer una conexión correcta,
   incluso en una red rápida.  Por lo tanto, el driver intentará reducir el número de nuevas
   conexiones creadas mediante la reutilización del pool de conexiones.
  </para>
  <para>
   Cuando un usuario crea una nueva instancia de <classname>MongoClient</classname>, todas
   las conexiones necesarias serán tomadas por el pool (un conjunto de replicas de conexiones 
   pueden requerir conexiones múltiples). Cuando la instancia de
   <classname>MongoClient</classname> se sale del ámbito, las conexiones se
   retornarán al pool.  Cuando el proceso en PHP termine, todas las conexiones en el
   pools serán cerrados.
  </para>
  <section>
   <title>"¿Por qué tengo tantas conexiones abiertas?"</title>
   <para>
    Las conexiones en el pool pueden generar un gran número de estas. Esto es
    normal y, con un poco de aritmética, es posible averiguar la cantidad de conexiones
    que se crearán.  Hay tres factores que determinan el número total de
    conexiones:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>
       connections_per_pool
      </literal>
     </para>
     <para>
      Cada pool creará, por omisión, un número ilimitado de
      conexiones. Uno puede suponer que este es un problema: si puede crear un
      número ilimitado de conexiones, no se podría crear miles y el
      servidor se quedaría sin descriptores de ficheros. En la práctica, es poco probable,
      ya que las conexiones no utilizadas son devueltas al pool para usarlos luego, Así las futuras
      conexiones van a utilizar la misma conexión en lugar de crear uno nuevo.
      A menos que cree miles de conexiones a la vez sin que ninguna este 
      fuera del ámbito, el número de conexiones abiertas deben permanecer en un 
      número razonable.
     </para>
     <para>
      Puede verse cuantas conexiones se tiene en el pool utilizando la función
      <function>MongoPool::info</function>.  Agregue los campos "in use" y
      "in pool" de un servidor determinado.  Ese será el número total de
      conexiones de ese pool.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>
       pools_per_process
      </literal>
     </para>
     <para>
      Cada dirección del servidor MongoDB al cual se va a conectar contiene su propio
      pool de conexiones.  Por ejemplo, si el hostname local es "example.net", connectarse
      a "example.net:27017", "localhost:27017", y "/tmp/mongodb-27017.sock"
      creará tres grupos pools de conexiones.  Puede ver como muchos grupos pools de conexiones
      tienes abiertas usando <function>MongoPool::info</function>.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>
       processes
      </literal>
     </para>
     <para>
      Cada proceso PHP tiene un conjunto independiente de pools.  PHP-FPM y Apache
      generalmente crean entre 6 y un par de docenas de PHP worker children. Compruebe
      su configuración y vea cuál es el máximo número de procesos de PHP que se pueden
      procesar.
     </para>
     <para>
      Si está usando PHP-FPM, la estimación del número de conexiones puede ser 
      difícil porque este puede procesar más workers de PHP-FPM y así volver pesado la carga. Para estar
      en lado de la seguro, mire en parámetro <literal>max_children</literal> o sume
      <literal>spare_servers</literal> + <literal>start_servers</literal>
      (elegir el número más alto). Esto indicará cuántos procesos de PHP
      (es decir, conjuntos de agrpuaciones) se deberían planificar.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Las tres variables de arriba se pueen multiplicar juntas para obtener el número
    máximo de conexiones esperadas:
    <literal>connections_per_pool</literal> *
    <literal>pools_per_process</literal> *
    <literal>processes</literal>. Observe que
    <literal>connections_per_pool</literal> puede ser diferente para diferentes
    agrupaciones, por lo que <literal>connections_per_pool</literal> debería ser el máximo.
   </para>
   <para>
    Por ejemplo, supongamos que se recibe 30 conexiones por pool, 10 pools por
    procesos en PHP, y 128 procesos PHP.  Entonces podemos esperar 38400 conexiones desde
    esta máquina.  Por lo tanto, debemos establecer el límite del descriptor del fichero para
    ser lo suficientemente alto para manejar todas las conexiones o pueda ejecutarse los ficheros
    de descriptores.
   </para>
   <para>
    See <classname>MongoPool</classname> para obtener más información sobre la conexión
    pooling.
   </para>
  </section>
 </section>
 
 <section xml:id="mongo.connecting.persistent">
  <title>Connexiones persistentes (versiones hasta 1.1.4 *solamente*</title>
  <note>
   <para>
    Esta sección no es relevante para 1.2.0+. En 1.2.0+, siempre las conexiones
    que son persistentes son administradas automáticamente por el driver. Si se utiliza
    una versión 1.2.x (pero no 1.3.x o posterior), véase
    <classname>MongoPool</classname> para más información sobre agrupaciones.
   </para>
  </note>
  
  <para>
   Crear una nueva conexión cada vez a la base de datos es muy lento.  Para minimizar el número
   de conexiones que se necesite, se pueden usar las conexiones persistentes.  Una 
   conexión persistente es guardada por PHP, para que pueda usarse la misma conexión en
   múltiples peticiones.
  </para>
  
  <para>
   Por ejemplo, este simple programa para conectarse 1000 veces a la base de datos:
  </para>
  
  <example xml:id="mongo.connecting.no-persistent-example">
   <programlisting role="php">
<![CDATA[
<?php

for ($i=0; $i<1000; $i++) {
  $m = new MongoClient();
}

?>
]]>
   </programlisting>
  </example>
  
  <para>
   Esto tarda apróximadamente 18 segundos en ejecutarse. Pero si lo cambiamos para que utilice 
   una conexión persistente:
  </para>
  
  <example xml:id="mongo.connecting.persistent-example">
   <programlisting role="php">
<![CDATA[
<?php

for ($i=0; $i<1000; $i++) {
  $m = new MongoClient("localhost:27017", array("persist" => "x"));
}

?>
]]>
   </programlisting>
  </example>
  
  <para>
   ...tardará menos de 0.02 segundos en ejecutarse, ya que solo se realiza una sola conexión
   a la base de datos.
  </para>
  
  <para>
   Las conexiones persistentes necesitan indicarse usando la variable de identificación (tal y como se muestra "x" 
   en el ejemplo anterior).  Para que la conexión persistente pueda usarse,
   el hostname, puerto, variable persist y las credenciales de autenticación (nombre de usuario,
   contraseña y base de datos) debe coincidir con una conexión persistente ya existente.
   De lo contrario, se creará una nueva conexión
   los datos proporcionados.
  </para>
  <para>
   Las conexiones persistentes son <emphasis>altamente recomendables</emphasis> y se deberían
   usar siempre en producción a no ser que exista una razón con fundamento para hacer lo contrario.  
   La mayoría de razones por las cuales no son recomendadas para bases de datos relacionales
   son totalmente irrelevantes para MongoDB.
  </para>
 </section>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
