<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: af4410a7e15898c3dbe83d6ea38246745ed9c6fb Maintainer: yago Status: ready -->

<chapter xml:id="memcached.callbacks" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Llamadas de retorno</title>

 <section xml:id="memcached.callbacks.result">
  <title>Resultado de llamadas de retorno</title>
  <para>
   El resultado de las <type>callbacks</type> están invocados por los métodos
   <methodname>Memcached::getDelayed</methodname> o
   <methodname>Memcached::getDelayedBykey</methodname> por cada ítem del 
   resultado. La llamada de retorno es pasada al objeto Memcached y el array
   con la información de cada ítem. La llamada de retorno en sí, no devuelve nada.
  </para>
  <example>
   <title>Ejemplo de resultado de llamada de retorno</title>
   <programlisting role="php">
<![CDATA[
<?php
$m = new Memcached();
$m->addServer('localhost', 11211);
$items = array(
    'key1' => 'value1',
    'key2' => 'value2',
    'key3' => 'value3'
);
$m->setMulti($items);
$m->getDelayed(array('key1', 'key3'), true, 'result_cb');

function result_cb($memc, $item)
{
    var_dump($item);
}
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
array(3) {
  ["key"]=>
  string(4) "key1"
  ["value"]=>
  string(6) "value1"
  ["cas"]=>
  float(49)
}
array(3) {
  ["key"]=>
  string(4) "key3"
  ["value"]=>
  string(6) "value3"
  ["cas"]=>
  float(50)
}
]]>
   </screen>
  </example>
 </section>

 <section xml:id="memcached.callbacks.read-through">
  <title>Lectura de caché de llamadas de retorno</title>
  <para>
   La lectura de caché de llamadas de retorno se invoca cuando un ítem no puede ser obtenido
   de un servidor. La llamada de retorno es pasada al objecto Memcached junto con la petición de la 
   clave y el valor de la variable por referencia. La llamada de retorno se encarga de
   definir el valor y devolver true o false. Si la llamada de retorno devuelve true,
   Memcached guardará el valor en el servidor y lo devolverá en la 
   llamada de la función original <methodname>Memcached::get</methodname> y
   <methodname>Memcached::getByKey</methodname> soportan llamadas de retorno,
   ya que el protocolo memcache no provee información sobre las claves
   que no fueron encontradas en una petición múltiple.
  </para>
  <example>
   <title>Ejemplo de lectura de llamada de retorno</title>
   <programlisting role="php">
<![CDATA[
<?php
$m = new Memcached();
$m->addServer('localhost', 11211);

$profile_info = $m->get('user:'.$user_id, 'user_info_cb');

function user_info_cb($memc, $key, &$value)
{
    $user_id = substr($key, 5);
    /* busca el profile en la BD */
    /* ... */
    $value = $profile_info;
    return true;
}
?>
]]>
   </programlisting>
  </example>
 </section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
