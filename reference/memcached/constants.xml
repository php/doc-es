<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: af4410a7e15898c3dbe83d6ea38246745ed9c6fb Maintainer: yago Status: ready -->

<appendix xml:id="memcached.constants" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 &reftitle.constants;
 &extension.constants;
 <variablelist>

  <varlistentry xml:id="memcached.constants.opt-compression">
   <term><constant>Memcached::OPT_COMPRESSION</constant></term>
   <listitem>
    <para>Activa o desactiva la compresión del contenido. Cuando está activado,
     los valores de los ítems mayores de cierto umbral (actualmente 100 bytes)
     serán comprimidos durante el almacenamiento y descomprimidos durante su 
     obtención de forma transparente.</para>
    <para>Tipo: <literal>boolean</literal>, predeterminado: &true;.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-serializer">
   <term><constant>Memcached::OPT_SERIALIZER</constant></term>
   <listitem>
    <para>
     Especifica el serializador a usar para serializar valores no escalares.
     Los serializadores válidos son <constant>Memcached::SERIALIZER_PHP</constant>
     o <constant>Memcached::SERIALIZER_IGBINARY</constant>. Este último solo es
     soportado cuando memcached es configurado con la opción
     <literal>--enable-memcached-igbinary</literal> y la extensión
     <literal>igbinary</literal> está disponible.
    </para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <constant>Memcached::SERIALIZER_PHP</constant>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.serializer-php">
   <term><constant>Memcached::SERIALIZER_PHP</constant></term>
   <listitem>
    <para>El serializador PHP por defecto.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.serializer-igbinary">
   <term><constant>Memcached::SERIALIZER_IGBINARY</constant></term>
   <listitem>
    <para>El serializador <link xlink:href="&url.igbinary;">igbinary</link>.
     En lugar de tener una representación textual guarda esctructuras de datos PHP de
     forma binaria, lo que resulta en mejoras de espacio y tiempo.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.serializer-json">
   <term><constant>Memcached::SERIALIZER_JSON</constant></term>
   <listitem>
    <para>El serializador JSON. Requiere PHP 5.2.10+.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-prefix-key">
   <term><constant>Memcached::OPT_PREFIX_KEY</constant></term>
   <listitem>
    <para>
     Puede ser usado para crear un "dominio" para tus claves ítem. El valor
     especificado será usado para prefijar cada una de las claves. No puede ser
     más mayor que <literal>128</literal> caracteres y reducirá el 
     tamaño máximo para el tamaño de la clave. El prefijo será usado solamente en las
     claves de los ítem, no en claves de servidores.</para>
    <para>Tipo: <literal>string</literal>, predeterminado: <literal>""</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-hash">
   <term><constant>Memcached::OPT_HASH</constant></term>
   <listitem>
    <para>Especifica el algoritmo hash utilizado por las claves ítem. Los valores
     válidos se proporcionan mediante las constantes del tipo <constant>Memcached::HASH_*</constant>.
     Cada algoritmo hash tiene sus ventajas y desventajas. Usar el
     valor por defecto si no se tiene conocimiento o no tiene relevancia.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <constant>Memcached::HASH_DEFAULT</constant></para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-default">
   <term><constant>Memcached::HASH_DEFAULT</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves por defecto (Jenkins una-a-la-vez).</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-md5">
   <term><constant>Memcached::HASH_MD5</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves MD5.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-crc">
   <term><constant>Memcached::HASH_CRC</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves CRC.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-fnv1-64">
   <term><constant>Memcached::HASH_FNV1_64</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves FNV1_64.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-fnv1a-64">
   <term><constant>Memcached::HASH_FNV1A_64</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves FNV1_64A.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-fnv1-32">
   <term><constant>Memcached::HASH_FNV1_32</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves FNV1_32.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-fnv1a-32">
   <term><constant>Memcached::HASH_FNV1A_32</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves FNV1_32A.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-hsieh">
   <term><constant>Memcached::HASH_HSIEH</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves Hsieh.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.hash-murmur">
   <term><constant>Memcached::HASH_MURMUR</constant></term>
   <listitem>
    <para>Algoritmo de hash para claves Murmur</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-distribution">
   <term><constant>Memcached::OPT_DISTRIBUTION</constant></term>
   <listitem>
    <para>Especifica el método para distribuir claves ítem en los servidores.
     Actualmente los métodos soportados son Modulo y hash consistente. Hash consistente
     proporciona una mejor distribución y permite que los servidores sean añadidos
     al cluster con el mínimo de pérdidas cache.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <constant>Memcached::DISTRIBUTION_MODULA.</constant></para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.distribution-modula">
   <term><constant>Memcached::DISTRIBUTION_MODULA</constant></term>
   <listitem>
    <para>Algoritmo de distribución de claves basado en Modulo.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.distribution-consistent">
   <term><constant>Memcached::DISTRIBUTION_CONSISTENT</constant></term>
   <listitem>
    <para>Algoritmo de distribución de claves hash consistente (basado en libketama).</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-libketama-compatible">
   <term><constant>Memcached::OPT_LIBKETAMA_COMPATIBLE</constant></term>
   <listitem>
    <para>Activa o desactiva la compatibilidad con el comportamiento de libketama. Cuando
     está activado, el algoritmo hash de clave ítem es defindo a MD5 y su distribución
     es definida a balance de distribución hash consistente. Esto es útil
     porque otros clientes basados en libketama (Python, Ruby, etc.) con la misma
     configuración serán capaces de acceder a las claves de forma transparente.
    </para>
    <note>
     <para>
      Es muy recomendable activar esta opción si se quiere usar
      hash consistente y seguramente estará activado por defecto en 
      futuras versiones.
     </para>
    </note>
    <para>Tipo: <literal>boolean</literal>, predeterminado: &false;.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-buffer-writes">
   <term><constant>Memcached::OPT_BUFFER_WRITES</constant></term>
   <listitem>
    <para>
     Activa o desactiva el buffer E/S. Activar el buffer E/S hace
     que los comandos de almacenamiento usen el "buffer" en lugar de ser enviados directamente. Cualquier acción que
     obtenga datos hacen que la información del buffer sea enviada a la conexión remota.
     El salir o cerrar la conexión también hará que el
     los datos del buffer sean enviados a la conexión remota.</para>
    <para>Tipo: <literal>boolean</literal>, predeterminado: &false;.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-binary-protocol">
   <term><constant>Memcached::OPT_BINARY_PROTOCOL</constant></term>
   <listitem>
    <para>Activa el uso del protocolo binario. Por favor nótese que no se puede
     cambiar esta opción cuando la conexión está abierta.</para>
    <para>Tipo: <literal>boolean</literal>, predeterminado: &false;.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-no-block">
   <term><constant>Memcached::OPT_NO_BLOCK</constant></term>
   <listitem>
    <para>Activa o desactiva escritura E/S no-sincrona. Esta es la manera más rápida
     disponible para funciones de almacenamiento.</para>
    <para>Tipo: <literal>boolean</literal>, predeterminado: &false;.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-tcp-nodelay">
   <term><constant>Memcached::OPT_TCP_NODELAY</constant></term>
   <listitem>
    <para>Activa o desactiva la opción de no-retraso para conectar a sockets (puede
     que sea más rápida en algunos entornos).</para>
    <para>Tipo: <literal>boolean</literal>, predeterminado: &false;.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-socket-send-size">
   <term><constant>Memcached::OPT_SOCKET_SEND_SIZE</constant></term>
   <listitem>
    <para>El número máximo de envíos de socket en bytes.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: varía según la plataforma/configuración
     del kernel.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-socket-recv-size">
   <term><constant>Memcached::OPT_SOCKET_RECV_SIZE</constant></term>
   <listitem>
    <para>El número máximo de recepción de socket en bytes.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: varía según la plataforma/configuración
     del kernel.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-connect-timeout">
   <term><constant>Memcached::OPT_CONNECT_TIMEOUT</constant></term>
   <listitem>
    <para>En el modo no-bloqueo este valor establece el tiempo de espera durante la conexión al
     socket, en milisengundos.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <literal>1000</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-retry-timeout">
   <term><constant>Memcached::OPT_RETRY_TIMEOUT</constant></term>
   <listitem>
    <para>La cantidad de tiempo en segundos, a esperar para reintentar la conexión
     en caso que haya fallado.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <literal>0</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-send-timeout">
   <term><constant>Memcached::OPT_SEND_TIMEOUT</constant></term>
   <listitem>
    <para>Tiempo de espera para el envío al socket, en microsegundos. En los casos donde no se puede
     usar no-bloqueo de E/S esta opción permitirá tener tiempos de espera al
     enviar datos.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <literal>0</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-recv-timeout">
   <term><constant>Memcached::OPT_RECV_TIMEOUT</constant></term>
   <listitem>
    <para>Tiempo de espera para la lectura del socket, en microsegundos. En los casos donde no se puede
     usar no-bloqueo E/S esta opción permitirá tener tiempos de espera al
     leer datos.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <literal>0</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-poll-timeout">
   <term><constant>Memcached::OPT_POLL_TIMEOUT</constant></term>
   <listitem>
    <para>Tiempo de espera para la conexión al polling, en milisegundos.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <literal>1000</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-cache-lookups">
   <term><constant>Memcached::OPT_CACHE_LOOKUPS</constant></term>
   <listitem>
    <para>Activa o desactiva caché para resoluciones DNS.</para>
    <para>Tipo: <literal>boolean</literal>, predeterminado: &false;.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.opt-server-failure-limit">
   <term><constant>Memcached::OPT_SERVER_FAILURE_LIMIT</constant></term>
   <listitem>
    <para>Especifica el límite de fallos para los intentos de conexión al servidor. El
     servidor será eliminado después del número indicado para los continuos fallos de 
     conexión.</para>
    <para>Tipo: <literal>integer</literal>, predeterminado: <literal>0</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.have-igbinary">
   <term><constant>Memcached::HAVE_IGBINARY</constant></term>
   <listitem>
    <para>Indica cuando está disponible el soporte para el serializador igbinary.</para>
    <para>Tipo: <literal>boolean</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.have-json">
   <term><constant>Memcached::HAVE_JSON</constant></term>
   <listitem>
    <para>Indica cuando está disponible el soporte para el serializador JSON.</para>
    <para>Tipo: <literal>boolean</literal>.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.get-preserve-order">
   <term><constant>Memcached::GET_PRESERVE_ORDER</constant></term>
   <listitem>
    <para>Opción para <function>Memcached::getMulti</function> y
     <function>Memcached::getMultiByKey</function> para asegurarse que las claves son devueltas
     en el mismo orden que fueron solicitadas. Las claves no existentes
     obtienen el valor por defecto null.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-success">
   <term><constant>Memcached::RES_SUCCESS</constant></term>
   <listitem>
    <para>La operación se completó satisfactoriamente.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-failure">
   <term><constant>Memcached::RES_FAILURE</constant></term>
   <listitem>
    <para>La operación falló de algún modo.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-host-lookup-failure">
   <term><constant>Memcached::RES_HOST_LOOKUP_FAILURE</constant></term>
   <listitem>
    <para>Falló la resolución DNS.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-unknown-read-failure">
   <term><constant>Memcached::RES_UNKNOWN_READ_FAILURE</constant></term>
   <listitem>
    <para>Falló al leer datos de la red.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-protocol-error">
   <term><constant>Memcached::RES_PROTOCOL_ERROR</constant></term>
   <listitem>
    <para>Comando erróneo del protocolo memcached.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-client-error">
   <term><constant>Memcached::RES_CLIENT_ERROR</constant></term>
   <listitem>
    <para>Error en el lado cliente.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-server-error">
   <term><constant>Memcached::RES_SERVER_ERROR</constant></term>
   <listitem>
    <para>Error en el lado servidor.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-write-failure">
   <term><constant>Memcached::RES_WRITE_FAILURE</constant></term>
   <listitem>
    <para>Fallo al escribir datos en la red.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-data-exists">
   <term><constant>Memcached::RES_DATA_EXISTS</constant></term>
   <listitem>
    <para>Falló al comparar e intercambiar: el ítem que se quiere guardar ha sido modificado
     desde la última vez que se obtuvo.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-notstored">
   <term><constant>Memcached::RES_NOTSTORED</constant></term>
   <listitem>
    <para>El ítem no fue guardado: pero no a causa de un error. Normalmente
     significa que no se cumplió la condición para "add" o "replace"
     o que el ítem está en la cola para ser eliminado.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-notfound">
   <term><constant>Memcached::RES_NOTFOUND</constant></term>
   <listitem>
    <para>No se encontró el ítem con esta clave (mediante la operación "get" 
     o "cas").</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-partial-read">
   <term><constant>Memcached::RES_PARTIAL_READ</constant></term>
   <listitem>
    <para>Error parcial de lectura en la red.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-some-errors">
   <term><constant>Memcached::RES_SOME_ERRORS</constant></term>
   <listitem>
    <para>Algunos errores sucedieron durante multi-get.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-no-servers">
   <term><constant>Memcached::RES_NO_SERVERS</constant></term>
   <listitem>
    <para>La lista de servidores está vacía.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-end">
   <term><constant>Memcached::RES_END</constant></term>
   <listitem>
    <para>Final de la lista de resultados.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-errno">
   <term><constant>Memcached::RES_ERRNO</constant></term>
   <listitem>
    <para>Error del sistema.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-buffered">
   <term><constant>Memcached::RES_BUFFERED</constant></term>
   <listitem>
    <para>La operación fue puesta en el buffer.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-timeout">
   <term><constant>Memcached::RES_TIMEOUT</constant></term>
   <listitem>
    <para>Se agotó el tiempo de espera para la operación.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-bad-key-provided">
   <term><constant>Memcached::RES_BAD_KEY_PROVIDED</constant></term>
   <listitem>
    <para>Clave errónea.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-connection-socket-create-failure">
   <term><constant>Memcached::RES_CONNECTION_SOCKET_CREATE_FAILURE</constant></term>
   <listitem>
    <para>Falló al crear el socket de red.</para>
   </listitem>
  </varlistentry>

  <varlistentry xml:id="memcached.constants.res-payload-failure">
   <term><constant>Memcached::RES_PAYLOAD_FAILURE</constant></term>
   <listitem>
    <para>Error de carga: no se pudo comprimir/descomprimir o serializar/deserializar el valor.</para>
   </listitem>
  </varlistentry>

 </variablelist>
</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

