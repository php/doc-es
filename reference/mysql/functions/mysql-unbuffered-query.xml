<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 4cb4824d5044a9bfefaf2b5932b60df25892e23e Maintainer: andresdzphp Status: ready -->
<!-- Reviewed: no -->
<refentry xml:id="function.mysql-unbuffered-query" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>mysql_unbuffered_query</refname>
  <refpurpose>Envía una consulta SQL a MySQL, sin recuperar ni colocar en búfer las filas de resultado</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>resource</type><methodname>mysql_unbuffered_query</methodname>
   <methodparam><type>string</type><parameter>query</parameter></methodparam>
   <methodparam choice="opt"><type>resource</type><parameter>link_identifier</parameter><initializer>NULL</initializer></methodparam>
  </methodsynopsis>
  <para>
   <function>mysql_unbuffered_query</function> envía la <parameter>query</parameter> SQL a MySQL,
   sin recuperar ni colocar en búfer las filas de resultado automáticamente, como
   <function>mysql_query</function> lo hace. Por una parte, esto ahorra una considerable
   cantidad de memoria con las consultas SQL que producen conjuntos grandes de resultados
   y se puede empezar a trabajar con el conjunto de resultado inmediatamente después de que la
   primera fila ha sido recuperada: no necesita esperar hasta que la consulta SQL completa
   haya sido ejecutada. Para usar <function>mysql_unbuffered_query</function> cuando se usan
   múltiples conexiones con la BD, se necesita indicar el parámetro opcional
   <parameter>link_identifier</parameter> para identificar que conexión se desea 
   utilizar.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>query</parameter></term>
     <listitem>
      <para>
       La consulta SQL a ejecutar.
      </para>
      <para>
       Los datos dentro del query deben estar <link
       linkend="function.mysql-real-escape-string">propiamente escapados</link>.
      </para>
     </listitem>
    </varlistentry>
    &mysql.linkid.description;
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Para sentencias SELECT, SHOW, DESCRIBE o EXPLAIN,
   <function>mysql_unbuffered_query</function> devuelve un valor
   <type>resource</type> en caso de éxito, o &false; si ocurre
   un error.
  </para>
  <para>
   Para otro tipo de sentencias SQL, UPDATE, DELETE, DROP, etc,
   <function>mysql_unbuffered_query</function> devuelve &true; en caso
   de éxito o &false; si ocurre un error.
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <note>
   <para>
    Los beneficios de <function>mysql_unbuffered_query</function> tienen
    un precio: No se puede usar <function>mysql_num_rows</function> ni
    <function>mysql_data_seek</function> en un conjunto de resultados devuelto por
    <function>mysql_unbuffered_query</function>, hasta que todas las filas sean recuperadas.
    También se tendrá que recuperar todas las filas de resultado de una consulta SQL sin búfer
    antes de poder enviar una nueva consulta SQL a MySQL, usando el mismo 
    <parameter>link_identifier</parameter>.
   </para>
  </note>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>mysql_query</function></member>
   </simplelist>
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
