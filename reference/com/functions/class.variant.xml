<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 96c9d88bad9a7d7d44bfb7f26c226df7ee9ddf26 Maintainer: seros Status: ready -->
<refentry xml:id="class.variant" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>VARIANT</refname>
  <refpurpose>La clase VARIANT</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
 <synopsis>$vVar = new <classname>VARIANT</classname>($var)</synopsis>
 </refsynopsisdiv>
 <refsect1 xml:id="class.variant.class">
  <title>Descripción</title>
  <simpara>
   VARIANT es el equivalente COM de zval de PHP; es una estructura que
   puede contener un valor con un rango de diferentes tipos posibles. La clase VARIANT
   porporcionada por la extensión COM permite tener más control sobre
   la forma en que PHP pasa valores a y desde COM.
  </simpara>
 </refsect1>
 <refsect1 xml:id="class.variant.constructor">
  <title>Métodos</title>
  <methodsynopsis>
   <type>object</type><methodname>VARIANT::VARIANT</methodname>
   <methodparam choice="opt"><type>mixed</type><parameter>value</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>type</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>codepage</parameter></methodparam>
  </methodsynopsis>
  <para>
   Constructor de la clase VARIANT. Parámetros:
   <variablelist>
   <varlistentry><term>value</term>
   <listitem>
    <simpara>
     valor inicial. si se omite o se establece a &null; se crea un objeto VT_EMPTY.
    </simpara>
   </listitem>
   </varlistentry>
   <varlistentry><term>type</term>
   <listitem>
    <simpara>
     especifica el tipo de contenido del objeto VARIANT. Los valores posibles son
     uno de los <constant>VT_XXX</constant> <xref
     linkend="com.constants"/>.
    </simpara>
    <simpara>
     En versiones de PHP anteriores a PHP 5 se podría forzar a PHP a pasar un objeto
     variante por referencia usando OR entre <constant>VT_BYREF</constant>
     y <parameter>type</parameter>. En PHP 5, esta forma no está
     soportada; en su lugar, PHP 5 puede detectar parámetros pasados por referencia
     automáticamente; incluso no necesitan ser pasados como objetos VARIANT.
    </simpara>
    <simpara>
     Consulte la biblioteca <acronym>MSDN</acronym> para información adicional
     sobre el tipo VARIANT.
    </simpara>
   </listitem>
   </varlistentry>
   <varlistentry><term>codepage</term>
   <listitem>
    <simpara>
     especifica la página de código que se usa para convertir cadenas a
     unicode. Véase el parámetro con el mismo nombre en la
     clase <xref linkend="class.com"/> para más información.
    </simpara>
   </listitem>
   </varlistentry>
   </variablelist>
  </para>
  <para>
   Las versiones de PHP anteriores a PHP 5 definen un número de (no documentado) propiedades virtuales
   para instancias de la clase VARIANT; todas estas propiedades han sido eliminadas en
   PHP 5 a favor de su sintaxis más natural; estas diferencias se remarcan
   mejor con un ejemplo:
  </para>
  <para>
   <example xml:id="com.variant.example.php4">
    <title>Ejemplo de Variant, estilo PHP 4.x</title>
    <programlisting role="php">
<![CDATA[
<?php
$v = new VARIANT(42);
print "El tipo es " . $v->type . "<br/>";
print "El valor es " . $v->value . "<br/>";
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example xml:id="com.variant.example.php5">
    <title>Ejemplo de Variant, estilo PHP 5</title>
    <programlisting role="php">
<![CDATA[
<?php
$v = new VARIANT(42);
print "El tipo es " . variant_get_type($v) . "<br/>";
print "El valor es " . $v . "<br/>";
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   La razón de este cambio es que, internamente, la extensión COM ve
   VARIANT, las clases COM y DOTNET son la misma cosa, y la filosofía
   de diseño de estas clases es que todas los accesos a propiedades y miembros son
   pasados a través de COM sin interferencia. La nueva sintaxis es más
   natural y menos costosa, y la mayoría de las propiedades virtuales eliminadas no
   tienen sentido en un contexto de PHP en ningún caso.
  </para>
  <note>
   <para>
    PHP 5 toma una aproximación mucho más sencilla para manejar VARIANTs; cuando se devuelve
    un valor o se trae una propiedad variante, la variante es convertida a un valor
    de PHP sólo cuando es un mapeado directo entre los tipos que
    no resultarían en una pérdida de información. En los demás casos, el resultado es
    devuelto como una instancia de la clase VARIANT. Se puede forzar a PHP a
    convertir o evaluar la variante como un tipo nativo de PHP usando un operador cast
    explícitamente, o implícitamente converitirla (cast) a una cadena usando
    <function>print</function>. Se puede usar el amplio rango de funciones de
    variantes para realizar operaciones aritméticas sobre variantes sin forzar una
    conversión o tener riesgo de perder información.
   </para>
  </note>
  <para>
   Véase también <function>variant_get_type</function>.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
