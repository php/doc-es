<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 04beb00111b3b243522aaa3cc85d53954656732b Maintainer: seros Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="mysqlnd-ms.quickstart" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Guía rápida y ejemplos</title>
 <para>
  El complemento de equilibrado de carga y replicación de mysqlnd es fácil de usar.
  Esta guía rápida mostrará los casos de uso típicos, y proporcionará consejos sobre cómo
  empezar a utilizarlo.
 </para>
 <para>
  Se recomienda leer las secciones de referencia además de esta guía
  rápida. Aquí se intenta evitar tratar con conceptos teóricos
  y limitaciones. En su lugar, se enlazará con las secciones de referencia. Es seguro
  comenzar con esta guía rápida. Sin embargo, antes de usar el complemento en entornos de objetivos
  críticos, le animamos a que lea también la información de fondo de las
  secciones de referencia.
 </para>
 <para>
  El enfoque es usar mysqlnd_ms de PECL para trabajar con clústeres MySQL asíncronos,
  a saber, la replicación MySQL. Generalmente hablando, un clúster asíncrono es más
  difícil de usar que uno sincrónico. Por lo tanto, los usuarios de, por ejemplo, el Clúster MySQL,
  encontrarán más información de la necesaria.
 </para>
 <section xml:id="mysqlnd-ms.quickstart.configuration">
  <title>Puesta en marcha</title>
  <para>
   El complemento está implementado como una extensión de PHP. Vea también las
   <link linkend="mysqlnd-ms.installation">instrucciones de instalación</link> para
   instalar la extenxión
   <link xlink:href="&url.pecl.package;mysqlnd_ms">PECL/mysqlnd_ms</link>.
  </para>
  <para>
   Compile o configure la extensión (API) de MySQL para PHP (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>,
   <link linkend="ref.mysql">mysql</link>) que planee usar con soporte
   para la biblioteca <link linkend="book.mysqlnd">mysqlnd</link>. PECL/mysqlnd_ms
   es un complemento para la biblioteca mysqlnd. Para utilizar el complemento con cualqier extensión
   de MySQL para PHP, la extensión ha de utilizar la biblioteca mysqlnd.
  </para>
  <para>
   Después carque la extensión en PHP y active el complemento en el fichero de
   confuguración de PHP usantdo la directiva de configuración llamada
   <link linkend="ini.mysqlnd-ms.enable">mysqlnd_ms.enable</link>.
  </para>
  <para>
   <example>
    <title>Habilitar el complemento (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.ini_file=/ruta/al/complemetno_mysqlnd_ms.ini
]]>
    </programlisting>
   </example>
  </para>
  <para>
   El complemento utiliza su propio fichero de configuración. Use la directiva
   de configuración de PHP
   <link linkend="ini.mysqlnd-ms.ini-file">mysqlnd_ms.ini_file</link>
   para establecer la ruta completa al fichero de configuración específico del complemento.
   Este fichero debe ser legible por PHP (p.ej., el usuario del servidor web).
  </para>
  <para>
   Cree un fichero de configuración específico del complemento. Guarde el fichero en la ruta
   establecida por la directiva de configuración de PHP
   <link linkend="ini.mysqlnd-ms.ini-file">mysqlnd_ms.ini_file</link>.
  </para>
  <para>
   El <link linkend="mysqlnd-ms.plugin-ini-json">fichero de configuración</link> del complemento
   está basado en <acronym>JSON</acronym>. Está dividido en una o más secciones.
   Cada sección tiene un nombre, por ejemplo, <literal>myapp</literal>. Cada sección
   contiene su propio conjunto de ajustes de configuración.
  </para>
  <para>
   Una sección debe incluir, como mínimo, el servidor maestro de replicación MySQL y establecer
   una lista de esclavos. El complemento admite únicamente un servidor maestro por sección.
   La configuración de replicación MySQL de múltiples maestros aún no está totalemnte soportada.
   Use el ajuste de configuración
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.master">master</link>
   para establecer el nombre del anfitrión y el puerto o socket del servidor maestro de MySQL.
   Los servidores esclavos de MySQL se configuran usando la
   palabra clave
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.slave">slave</link>.
  </para>
  <para>
   <example>
    <title>Fichero de configuración mínima específico del complemento (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": [

        ]
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Es necesario configurar una lista de servidores esclavos de MySQL, aunque puede
   contener una lista vacía. Se recomienda que siempre se configure al
   menos un servidor esclavo.
  </para>
  <para>
   Las listas de servidores pueden usar la <link linkend="mysqlnd-ms.plugin-ini-json.server-list-syntax">
   sintaxis anónima o no anónima</link>. Las listas no
   anónimas incluyen sobrenombres para los servidores, tales como <literal>master_0</literal>
   para el maestro del ejemplo de arriba. Esta guía rápida utiliza la
   sintaxis no anónima más prolija.
  </para>
  <para>
   <example>
    <title>Configuración mínima recomendada específica del complemento (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Si al menos existen
   dos servidores en total, el complemento puede empezar a equilibrar la carga e intercambiar
   conexiones. El intercambio de conexiones no siempre es transparente y puede ocasionar
   problemas en ciertos casos. Las secciones de referencia sobre
   <link linkend="mysqlnd-ms.pooling">intercambio y agrupación de conexiones</link>,
   <link linkend="mysqlnd-ms.transaction">manejo de transacciones</link>,
   <link linkend="mysqlnd-ms.failover">tolerancia a fallos</link>
   <link linkend="mysqlnd-ms.loadbalancing">equilibrado de carga</link> y
   <link linkend="mysqlnd-ms.rwsplit">división de lectura-escritura</link> proporcionan
   más detalles. Los problemas potenciales están descritos más tarde en esta guía.
  </para>
  <para>
   Es responsabilidad de la aplicación manejar los problemas potenciales causados
   por el intercambio de conexiones, configurando un servidor maestro con al menos un servidor
   esclavo, lo cual permite el intercambio para trabajar con los problemas relacionados que se puedan encontrar.
  </para>
  <para>
   Los servidores maestros y esclavos de MySQL que se configuren no necesitan
   ser parte de la configuración de replicación MySQL. Para realizar pruebas, se puede usar un único
   servidor MySQL y hacerle saber al complemento que se trata de un servidor maestro y esclavo,
   como se muestra abajo. Esto podría ser de ayuda para detectar muchos problemas potenciales con
   los intercambios de conexión. Sin embargo, tal configuración no será propensa a los problemas
   causados por la demora de replicación.
  </para>
  <para>
   <example>
    <title>Usar un servidor como maestro y esclavo (¡solamente para pruebas!)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.usage">
  <title>Ejecutar sentencias</title>
  <para>
   El complemento se puede usar con cualquier extensión de MySQL para PHP
   (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link>, y
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>) que esté
   compilada para utilizar la biblioteca <link linkend="book.mysqlnd">mysqlnd</link>.
   PECL/mysqlnd_ms se acopla a la biblioteca <link linkend="book.mysqlnd">mysqlnd</link>.
   No cambia la API o el comportamiento de estas extensiones.
  </para>
  <para>
   Siempre que se esté abriendo una conexión a MySQL, el complemento compara el valor del
   parámetro 'host' de la llamada de conexión con los nombres de las secciones
   del fichero de configuración específico del complemento. Si, por ejemplo, el
   fichero de configuración específico del complemento tiene una sección <literal>myapp</literal> , se
   ha de hacer referencia a ésta para abrir una conexión a MySQL para el
   anfitrión <literal>myapp</literal>
  </para>
  <para>
   <example>
    <title>Fichero de configuración específico del complemento (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Abrir una conexión con equilibrado de carga</title>
    <programlisting role="php">
<![CDATA[
<?php
/* El equilibrado de carga sigue las reglas de la sección "myapp" del fichero de configuración del complemento */
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
$pdo = new PDO('mysql:host=myapp;dbname=base_datos', 'nombre_usuario', 'contraseña');
$mysql = mysql_connect("myapp", "nombre_usuario", "contraseña");
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Los ejemplos de conexión de arriba tendrán equilibrio de carga.
   El complemento enviará sentencias de sólo lectura al servidor esclavo de MySQL con la
   IP <literal>192.168.2.27</literal> y escuchará el puerto <literal>3306</literal>
   para la conexión cliente de MySQL. Todas las demás sentencias serán dirigidas al
   servidor maestro de MySQL que se ejecuta en el anfitrión <literal>localhost</literal>. Si se ejecuta en sistemas
   operativos de tipo Unix, el maestro sobre <literal>localhost</literal> aceptará
   conexiones cliente de MySQL en el socket de dominio Unix <literal>/tmp/mysql.sock</literal>,
   mientras que TCP/IP es el puerto predeterminado en Windows.
   El complemento usará el nombre de usuario <literal>nombre_usuario</literal> y la contraseña
   <literal>contraseña</literal> para conectarse a cualquier servidor de MySQL incluido en
   la sección <literal>myapp</literal> del fichero de configuración del complemento. Una vez
   realizada la conexión, el complemento seleccionará <literal>base_datos</literal> como el esquema
   actual.
  </para>
  <para>
   El nombre de usuario, la contraseña y el nombre del esquema son tomados de las llamadas a la
   API de conexión y usados por todos los servidores. En otras palabras: se deben usar los mismos
   nombre de usuario y contraseña para cada servidor MySQL incluido en una sección del fichero de configuración
   del comlemento. No es una limitación generalizada. A partir de PECL/mysqlnd_ms 1.1.0,
   es posible establecer
   <link linkend="mysqlnd-ms.plugin-ini-json.server-config-keywords">username</link> y
   <link linkend="mysqlnd-ms.plugin-ini-json.server-config-keywords">password</link> para cualquier servidor del
   fichero de configuración del complemento, para utilizarlos en lugar de las credenciales pasadas
   a la llamada a la API.
  </para>
  <para>
   El complemento no cambia la API para ejecutar sentencias.
   La <link linkend="mysqlnd-ms.rwsplit">división de lectura-escritura</link>
   se desarrolla aparte. El siguiente ejemplo asume que no existe
   una demora de replicación significante entre el maestro y el esclavo.
  </para>
  <para>
   <example>
    <title>Ejecutar sentencias</title>
    <programlisting role="php">
<![CDATA[
<?php
/* El equilibrado de carga sigue las reglas de la sección "myapp" del fichero de configuración del complemento */
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (mysqli_connect_errno())
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Las sentencias se ejcutarán en el maestro */
if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("CREATE TABLE test(id INT)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* solo lectura: la sentencia se ejecutará en un esclavo */
if (!($resultado = $mysqli->query("SELECT id FROM test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $fila = $resultado->fetch_assoc();
 $resultado->close();
 printf("El esclavó devolvió el ID = '%s'\n", $fila['id'];
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
El esclavó devolvió el ID = '1'
]]>
    </screen>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.connectionpooling">
  <title>Estado de la conexión</title>
  <para>
   El complemento cambia la semántica de un gestor de conexión de MySQL para PHP.
   Un gestor de conexión representa una agrupación de conexiones, en lugar de una
   única conexión de red cliente-servidor de MySQL. La agrupación de conexiones consiste
   en una conexión maestra, y opcionalmente cualquier número de conexiones esclavas.
  </para>
  <para>
   Cada conexión de la agrupación de conexiones tiene su propio estado. Por ejemplo,
   las variables SQL de usuario, las tablas temporales y las transacciones, son parte del estado.
   Se puede encontrar un listado completo con los elementos que pertenecen al estado de una conexión en
   los conceptos de la documentación de
   <link linkend="mysqlnd-ms.pooling">agrupación e intercambio de conexiones</link>.
   Si el complemento decide intercambiar conexiones para equilibrar la carga, a la
   aplicación se le podría proporcionar una conexión que tuviera un estado diferente.
   Las aplicaciones deben considerar esto.
  </para>
  <para>
   <example>
    <title>Configuración del complemento con un esclavo y un maestro</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Problema: estado de conexión y variables SQL de usuario</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Conexión 1, la conexión vincula una variable SQL de usuario, no se ejecuta ningún SELECT en el maestro */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Conexión 2, se ejecuta en el esclavo a causa de SELECT */
if (!($resultado = $mysqli->query("SELECT @myrole AS _role"))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $fila = $resultado->fetch_assoc();
 $resultado->close();
 printf("@myrole = '%s'\n", $fila['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
@myrole = ''
]]>
    </screen>
   </example>
  </para>
  <para>
   El ejemplo abre una conexión con equilibrio de carga y ejecuta dos sentencias.
   La primera sentencia <literal>SET @myrole='master'</literal> no comienza
   con la cadena <literal>SELECT</literal>. Por lo tanto, el complemento no
   la reconoce como una consulta de solo lectura que se ejecutaría en un esclavo. El
   complemento ejecuta la sentencia en una conexión al maestro. La sentencia
   establece una variable SQL de usuario que está vinculada a la conexión con el maestro. El
   estado de la conexión maestra ha sido cambiado.
  </para>
  <para>
   La siguiente sentencia es <literal>SELECT @myrole AS _role</literal>.
   El complemento la reconoce como una consulta de solo lectura y la envía al
   esclavo. La sentencia se ejecuta en una conexión al esclavo. Esta
   segunda conexión no tiene ninguna variable SQL de usuario vinculada a ella.
   Tiene un estado diferente a la primera conexión al maestro.
   La variable SQL de usuario no está establecida. El script del ejemplo imprime
   <literal>@myrole = ''</literal>.
  </para>
  <para>
   Es responsabilidad del desarrollador de la apliación ocuparse
   del estado de la conexión. El complemento no monitoriza todas
   las actividades de cambio de estado. La monitorización de todos los casos posibles
   sería una tarea intensiva de la CPU, si es que esta tarea pudiera ser realizada.
  </para>
  <para>
   Los problemas se pueden evitar fácilmente usando sugerencias SQL.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.sqlhints">
  <title>Sugerencias SQL</title>
  <para>
   Las sugerencias SQL pueden forzar a una consulta a elegir un servidor específico de la agrupación de conexiones.
   Proporcionan al complemento una recomendación para utilizar un servidor indicado, lo que puede resolver
   problemas causados por intercambios de conexión y estados de conexión.
  </para>
  <para>
   Las sugerencias SQL son comentarios que siguen el estándar. Ya que
   los comentarios SQL son ignorados por sistemas de procesamiento SQL,
   no interfieren con otros programas como el Servidor MySQL, el Proxy MySQL,
   o un cortafuegos.
  </para>
  <para>
   El complemento admite tres sugerencias SQL: La
   sugerencia <constant>MYSQLND_MS_MASTER_SWITCH</constant> hace que el complemento ejecute una
   sentencia en el maestro, <constant>MYSQLND_MS_SLAVE_SWITCH</constant>
   fuerza el uso del esclavo, y
   <constant>MYSQLND_MS_LAST_USED_SWITCH</constant> ejecutará una sentencia en
   el mismo servidor que se utilizó con la sentencia anterior.
  </para>
  <para>
   El complemento examina el comienzo de una sentencia para la existencia de una sugerencia
   SQL. Las sugerencias SQL solo son reconocidas si aparecen al comienzo de
   la sentencia.
  </para>
  <para>
   <example>
    <title>Configuración del complemento con un esclavo y un maestro</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Sugerencias SQL para evitar el intercambio de conexión</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (mysqli_connect_errno())
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Conexión 1, la conexión vincula una variable SQL de usuario, no se ejecuta ningún SELECT en el maestro */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Conexión 1, se ejecuta en el maestro debido a la sugerencia SQL */
if (!($resultado = $mysqli->query(sprintf("/*%s*/SELECT @myrole AS _role", MYSQLND_MS_LAST_USED_SWITCH)))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $fila = $resultado->fetch_assoc();
 $resultado->close();
 printf("@myrole = '%s'\n", $fila['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
@myrole = 'master'
]]>
    </screen>
   </example>
  </para>
  <para>
   En el ejemplo de arriba, el uso de <constant>MYSQLND_MS_LAST_USED_SWITCH</constant> evita
   el intercambio de sesión desde el maestro al esclavo al ejecutar la sentencia
   <literal>SELECT</literal>.
  </para>
  <para>
   Las sugerencias SQL también se pueden usar para ejecutar sentencias <literal>SELECT</literal>
   en el servidor maestro de MySQL. Esto podría ser necesario si los servidores esclavos de MySQL
   están normalmente detrás del maestro, pero no se necesitan datos actuales del clúster.
  </para>
  <para>
   En la versión 1.2.0, el concepto de nivel de servicio ha sido introducido para dirigir
   casos en los que no son necesarios datos actuales. El uso de un nivel de servicio requiere menos atención
   y elimina la necesidad de usar sugerencias SQL para este caso. Se puede encontrar más
   información más abajo en la sección de nivel de servicio y consistencia.
  </para>
  <para>
   <example>
    <title>Enfrentarse a la demora de replicación</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Forzar el uso del maestro, el maestro siempre tiene datos recientes y actuales */
if (!$mysqli->query(sprintf("/*%s*/SELECT critical_data FROM important_table", MYSQLND_MS_MASTER_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Un caso de uso puede incluir la creación de tablas en un esclavo.
   Si no se proporciona una sugenrencia SQL, el complemento enviará las sentencias
   <literal>CREATE</literal> e <literal>INSERT</literal> al maestro. Utilice la
   sugerencia SQL <constant>MYSQLND_MS_SLAVE_SWITCH</constant> si quiere
   ejecutar tales sentencias en un esclavo, por ejemplo, para construir tablas de
   informes temporales.
  </para>
  <para>
   <example>
    <title>Creación de una tabla en un esclavo</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Forzar el uso del esclavo */
if (!$mysqli->query(sprintf("/*%s*/CREATE TABLE informes_esclavo(id INT)", MYSQLND_MS_SLAVE_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* Continuar usando esta conexión esclava en particular */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO informes_esclavo(id) VALUES (1), (2), (3)", MYSQLND_MS_LAST_USED_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* ¡No usar MYSQLND_MS_SLAVE_SWITCH, ya que permitiría el intercambio con otro esclavo! */
if ($resultado = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM informes_esclavo", MYSQLND_MS_LAST_USED_SWITCH))) {
  $fila = $resultado->fetch_assoc();
  $resultado->close();
  printf("Hay %d filas en la tabla 'informes_esclavo'", $fila['_num']);
} else {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   La sugerencia SQL <constant>MYSQLND_MS_LAST_USED</constant> prohíbe el intercambio de una
   conexión, por lo que fuerza el uso de la conexión utilizada anteriormente.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.transactions">
  <title>Transacciones</title>
  <para>
   La versión actual del complemento no es segura con transacciones de forma predeterminada,
   ya que no considera su ejecución en ningún caso. Las transacciones SQL son
   unidades de trabajo para ejecutarlas en un único servidor. El complemento no siempre sabe
   cuándo comienza y cuándo finaliza una unidad de trabajo. Por lo tanto, el complemento podría
   decidir intercambiar conexiones en mitad de una transacción.
  </para>
  <para>
   Ningún tipo de equilibrador de carga de MySQL puede detectar los límites de una transacción sin ningún
   tipo de sugerencia por parte de la aplicación.
  </para>
  <para>
   Se pueden usar sugerencias SQL para superar esta limitación. De forma alternativa,
   se puede activar la monitorización de llamadas a la API de transacciones. En el último caso,
   de deben usar llamadas a la API solamente para controlar transacciones. Véase más abajo.
  </para>
  <para>
   <example>
    <title>Configuración del complemento con un esclavo y un maestro</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Usar sugerencias SQL para transacciones</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* No es un SELECT, se usará el maestro */
if (!$mysqli->query("START TRANSACTION")) {
 /* Por favor, use un manejo de errores mejor en su código */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* ¡Evitar el intercambio de conexión! */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO test(id) VALUES (1)", MYSQLND_MS_LAST_USED_SWITCH)))) {
 /* Por favor, realice el ROLLBACK apropiado en su código, y no use simplemente 'die' */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($resultado = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM test", MYSQLND_MS_LAST_USED_SWITCH)))) {
  $fila = $resultado->fetch_assoc();
  $resultado->close();
  if ($fila['_num'] > 1000) {
   if (!$mysqli->query(sprintf("/*%s*/INSERT INTO events(task) VALUES ('cleanup')", MYSQLND_MS_LAST_USED_SWITCH)))) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/UPDATE log SET last_update = NOW()", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/COMMIT", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Desde PHP 5.4.0, la biblioteca <literal>mysqlnd</literal> permite al
   complemento monitorizar el estado del modo <literal>autocommit</literal>, si
   el modo está establecido por llamadas a la API en lugar de usar sentencias SQL como
   <literal>SET AUTOCOMMIT=0</literal>. Esto permite que el complemento
   considere las transacciones. En este caso, es necesario usar sugerencias SQL.
  </para>
  <para>
   Si se está utlizando PHP 5.4.0 o superior, con las llamadas a la API que habilitan el modo <literal>autocommit</literal>,
   y cuando se establece la opción de configuración del complemento
   <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">trx_stickiness=master</link>,
   éste puede deshabilitar automáticamente el equilibrado de carga y el intercambio de conexiones
   para transacciones SQL. Con esta configuración, el complemento detiene el equilibrado de carga
   si <literal>autocommit</literal> está deshabilitado, y dirige todas las sentencias al
   maestro. Esto evita el intercambio de conexiones en mitad de
   una transacción. Una vez que <literal>autocommit</literal> es rehabilitado, el complemento
   inicia de nuevo las sentencias con equilibrado de carga.
  </para>
  <para>
   <example>
    <title>Equilibrado de carga considerando transacciones: el ajuste trx_stickiness</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "trx_stickiness": "master"
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Consideración de transacciones</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Deshabilitar autocommit, el complemento ejecutará todas las sentencias en el maestro */
$mysqli->autocommit(FALSE);

if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 /* Por favor, realice el ROLLBACK apropiado en su código, y no use simplemente 'die' */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($resultado = $mysqli->query("SELECT COUNT(*) AS _num FROM test")) {
  $fila = $resultado->fetch_assoc();
  $resultado->close();
  if ($fila['_num'] > 1000) {
   if (!$mysqli->query("INSERT INTO events(task) VALUES ('cleanup')")) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query("UPDATE log SET last_update = NOW()")) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->commit()) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* El complemento asume que la transacción ha finalizado e inicia el equilibrado de carga de nuevo */
$mysqli->autocommit(TRUE);
$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <note>
   <title>Requisitos de versión</title>
   <para>
    La opción de configuración del complemento
    <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">trx_stickiness=master</link>
    requiere PHP 5.4.0 o superior.
   </para>
  </note>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.qos-consistency">
  <title>Nivel de servicio y consistencia</title>
  <note>
   <title>Requisitos de versión</title>
   <para>
    Los niveles de servicios han sido introducidos en la versión 1.2.0-alpha de PECL mysqlnd_ms.
    <function>mysqlnd_ms_set_qos</function>
    está disponible con PHP 5.4.0 o superior.
   </para>
  </note>
  <para>
   Las diferentes soluciones de clúster MySQL ofrecen diferentes niveles de
   servicios y de consistencia de datos para sus usuarios. Un clúster de replicación MySQL asíncrono
   ofrece la consistencia final de forma predeterminada. Una lectura ejecutada en un esclavo asíncrono
   puede devolver datos actuales, antiguos, o ningún dato, dependiendo de si el esclavo
   ha replicado todos los conjuntos de cambios del maestro.
  </para>
  <para>
   Las aplicaciones que utilizan un clúster de replicación MySQL necesitan ser diseñadas para que funcionen
   correctamente con datos de consistencia final. En algunos casos, sin embargo, los datos antiguos
   no son aceptables. En estos casos solamente son permitidos ciertos accesos a esclavos o incluso a un maestro
   para realizar la calidad de servicio requerida del clúster.
  </para>
  <para>
   A partir de PECL mysqlnd_ms 1.2.0, el complemento puede seleccionar automáticamente
   nodos de replicación de MySQL que proporcionen consistencia de sesión o
   consistencia fuerte. La consistencia de sesión significa que un cliente puede leer sus escrituras.
   Otros clientes pueden ver o no la escritura del cliente. La consistencia fuerte significa
   que todos los clientes verán todas las escrituras del cliente.
  </para>
  <para>
   <example>
    <title>Consistencia de sesión: lectura de sus escrituras</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Solicitud de consistencia de sesión</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* división de lecutura-escritura: se usa el maestro */
if (!$mysqli->query("INSERT INTO orders(order_id, item) VALUES (1, 'christmas tree, 1.8m')")) {
  /* Por favor, use un manejo de errores mejor en su código */
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Solicitud de consistencia de sesión: lectura de sus escrituras */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* El complemento selecciona un nodo que posee los cambios, aquí: el maestro */
if (!$resultado = $mysqli->query("SELECT item FROM orders WHERE order_id = 1"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($resultado->fetch_assoc());

/* Volver a la consistencia final: se permiten datos antiguos */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* El complemento seleccina cualquier esclavo, se permiten datos antiguos */
if (!$resultado = $mysqli->query("SELECT item, price FROM specials"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Los niveles de servicios se pueden establecer en el fichero de configuración del complemento y
   en tiempo de ejecución usando <function>mysqlnd_ms_set_qos</function>.
   En el ejemplo, la función se usa para forzar la
   consistencia de sesión (lectura de sus escrituras) para todas las sentencias futuras hasta próximo aviso.
   La sentencia <literal>SELECT</literal> de la tabla <literal>orders</literal>
   se ejecuta en el maestro para asegurarse de que las escrituras anteriores puedan ser vistas por el cliente.
   La lógica de la división de lectura-escritura ha sido adaptada para satisfacer el nivel de servicio.
  </para>
  <para>
   Después de que una aplicación haya leído sus cambios desde la tabla <literal>orders</literal>,
   vuelve al nivel de servicio predeterminado, que es la consistencia final. Ésta
   no pone restricciones al elegir un nodo para la ejecución de sentencias.
   Por lo tanto, la sentencia <literal>SELECT</literal> de la tabla <literal>specials</literal>
   se ejecuta en un esclavo.
  </para>
  <para>
   La nueva funcionalidad sustituye el uso de sugerencias SQL y la opción
   de configuración <literal>master_on_write</literal>. En muchos casos,
   <function>mysqlnd_ms_set_qos</function> es más fácil de usar, más potente y
   mejora la portabilidad.
  </para>
  <para>
   <example>
    <title>Edad máxima/demora del esclavo</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "failover" : "master"
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Limitar la demora del esclavo</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Demora de la lectura desde los esclavos de no más de cuatro segundos */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* El comlemento elige cualquier esclavo, el cual puede o no poseer los cambios */
if (!$resultado = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Volver a lo predeterminado: usar todos los esclavos y maestros permitidos */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   El nivel de servicio de consistencia final se puede usar con un parámetro
   opcional para establecer la demora máxima de los esclavos elegidos. Si se establece,
   el complemento comprueba <literal>SHOW SLAVE STATUS</literal> para todos
   los esclavos configurados. En el caso del ejemplo, solamente los esclavos
   para los que <literal>Slave_IO_Running=Yes</literal>,
   <literal>Slave_SQL_Running=Yes</literal> y
   <literal>Seconds_Behind_Master &lt;= 4</literal>
   sea verdadero, son tenidos en cuenta para la ejecución de la sentencia
   <literal>SELECT item, price FROM daytrade</literal>.
  </para>
  <para>
   La comprobacion de <literal>SHOW SLAVE STATUS</literal> se realiza de manera transparente desde
   la perspectiva de las aplicaciones. Los errores, si los hubiera, son notificados como
   advertencias. No se establecerá ningún error en el gestor de conexión. Incluso si todas
   las sentencias SQL <literal>SHOW SLAVE STATUS</literal> ejecutadas por el
   complemento fallan, la ejecución de las sentencias del usuario no se detienen, dado
   que la toleracia a fallos del maestro está habilitada. Por lo tanto, no se requieren cambios en la aplicación.
  </para>
  <note>
   <title>Operaciones caras y lentas</title>
   <para>
    La comprobación de <literal>SHOW SLAVE STATUS</literal> para todos los esclavos añade carga adicional
    a la aplicación. Es una operación en segundo plano cara y lenta.
    Intente minimizar su uso. Desafortunadamente, un clúster de replicación MySQL
    no proporciona a los clientes la posibilidad de solicitar una lista de candidatos
    desde una instancia central.
    En consecuencia, no existe una manera más eficiente de comprobar la demora de los esclavos.
   </para>
   <para>
    Por favor, observe las limitaciones y propiedades de <literal>SHOW SLAVE STATUS</literal>
    tal y como están explicadas en el manual de referencia de MySQL.
   </para>
  </note>
  <para>
   Para evitar que mysqlnd_ms emita una advertencia si no se pudieron encontrar esclavos 
   que se demoren no más que el número de segundos definido con respecto al maestro,
   es necesario habilitar la tolerancia a fallos del maestro en el fichero de configuración del complemento.
   Si no se pudieron encontrar esclavos y la tolerancia a fallos está habilitada, el complemento
   eligirá un maestro para ejecutar la setencia.
  </para>
  <para>
   Si no se pudieron encontrar esclavos y la tolerancia a fallos está deshabilitada, el complemento emitirá
   una advertencia, no ejecutará la sentencia y establecerá un error
   sobre la conexión.
  </para>
  <para>
   <example>
    <title>La tolerancia a fallos no está establecida</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>No hay esclavos dentro del límite de tiempo</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Demora de la lectura desde los esclavos de no más de cuatro segundos */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* El comlemento elige cualquier esclavo, el cual puede o no poseer los cambios */
if (!$resultado = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Volver a lo predeterminado: usar todos los esclavos y maestros permitidos */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
PHP Warning:  mysqli::query(): (mysqlnd_ms) Couldn't find the appropriate slave connection. 0 slaves to choose from. Something is wrong in %s on line %d
PHP Warning:  mysqli::query(): (mysqlnd_ms) No connection selected by the last filter in %s on line %d
[2000] (mysqlnd_ms) No connection selected by the last filter
]]>
    </screen>
   </example>
  </para>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.gtid">
  <title>IDs de transacción globales</title>
  <note>
   <title>Requisitos de versión</title>
   <para>
    Se ha introducido una inyección de ID de transacciones global en el lado del cliente en la versión 1.2.0-alpha de mysqlnd_ms.
    Esta característica no es necesaria para clústeres sincrónicos, tales como el Clúster MySQL.
    Utilícela con clústeres asíncronos tales como la replicación MySQL clásica.
   </para>
   <para>
    A partir de MySQL 5.6.5-m8, el servidor MySQL introduce los identificadores de transacciones globales internos.
    La característica del ID de transacciones global interno está soportada por PECL/mysqlnd_ms 1.3.0-alpha o
    posterior.
   </para>
  </note>
  <para>
   PECL/mysqlnd_ms puede usar tanto su propia emulación del ID de transacciones global como la
   característica del ID de transacciones global interna de MySQL 5.6.5-m8 o posterior. Desde la perspectiva del
   desarrolador, los enfoques del lado del cliente y del lado del servidor ofrecen las mismas características en cuanto
   a niveles de servicios proporcionados por PECL/mysqlnd_ms. Las diferencias
   son tratadas en la <link linkend="mysqlnd-ms.gtid">sección de conceptos</link>.
  </para>
  <para>
   Esta guía rápida primero demuestra el uso de la emulación interna del ID de transacciones global en el
   lado del cliente en PECL/mysqlnd_ms antes de mostrar cómo usar su homólogo en el lado del servidor.
   Este orden asegura que la idea subyacente se trata primero.
  </para>
  <para>
   <emphasis role="bold">La idea y la emulación en el lado del cliente</emphasis>
  </para>
  <para>
   En su forma más básica, un ID de Transacciones Global (GTID de sus siglas en inglés) es un contador de una tabla del
   maestro. El contador se incrementa siempre que se consigne una transacción en el maestro.
   Los esclavos replican la tabla. El contador sirve para dos propósitos. En caso de un
   fallo del maestro, ayuda al administrador de la base de datos a identificar al esclavo que fue
   promovido más recientemente como nuevo maestro. Este esclavo es aquel con el
   valor de contador más alto. Las aplicaciones pueden usar el ID de transacciones global para buscar
   los esclavos que ya han replicado una escritura en particular (identificada por un ID de transacciones
   global).
  </para>
  <para>
   PECL/mysqlnd_ms puede inyectar SQL para cada transacción consignada para incrementar un contador GTID.
   El ID creado es accesible por la aplicación para poder identificar una operación de escritura
   de una aplicación. Esto habilita al complemento para proporcionar el nivel de servicio de consistencia de sesión
   (lectura de sus escrituras) mediante no solamente la consulta a los maestros, sino también a los esclavos que ya han
   replicado el cambio. La carga de lectura se le quita al maestro.
  </para>
  <para>
   La emulación del ID de transacciones global en el lado del cliente tiene algunas limitaciones. Por favor,
   lea la <link linkend="mysqlnd-ms.gtid">sección de conceptos</link>
   detenidamente para comprender completamente los principios y las ideas
   subyacentes antes de usarla en entornos de producción. No es necesario un conocimiento
   profundo para continuar con esta guía rápida.
  </para>
  <para>
   Primero, cree una tabla contador en su servidor maestro e inserte un registro en ella.
   El complemento no asiste en la creación de la tabla.
   Los administradores de la base de datos deben asegurarse de que existe. Dependiendo del modo de notificación
   de errores, el complemento ignorará de forma silenciosa la ausencia de la tabla o abandonará.
  </para>
  <para>
   <example>
    <title>Crear una tabla contador en el maestro</title>
    <programlisting role="sql">
<![CDATA[
CREATE TABLE `trx` (
  `trx_id` int(11) DEFAULT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=latin1
INSERT INTO `trx`(`trx_id`) VALUES (1);
]]>
    </programlisting>
   </example>
  </para>
  <para>
   En el fichero de configuración del complemento establezca el SQL para actualizar la
   tabla del ID de transacciones global usando <literal>on_commit</literal>
   en la sección <literal>global_transaction_id_injection</literal>.
   Asegúrese de que el nombre de la tabla usado para la sentencia <literal>UPDATE</literal>
   está completamente cualificado. En el ejemplo,
   <literal>test.trx</literal> se usa para referirse a la tabla <literal>trx</literal>
   del esquema (base de datos) <literal>test</literal>. Use la tabla que se creó en
   el paso anterior. Es importante establecer el nombre de la tabla completamente cualificado,
   ya que la conexión donde se realiza la inyección puede usar una base de datos predeterminada
   diferente. Asegúrese de que al usuario que abra la conexión
   se le permita ejecutar la sentencia <literal>UPDATE</literal>.
  </para>
  <para>
   Habilite la notificación de los errores que pudieran ocurrir cuando mysqlnd_ms realice inyecciones
   de ID de transacciones global.
  </para>
  <para>
   <example>
    <title>Configuración del complemento: SQL para la inyección del GTID en el lado del cliente</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Inyección transparente del ID de transacciones global</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* modo autoconsigna, transacción en el maestro, el GTID debe ser incrementado */
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* modo autoconsigna, transacción en el maestro, el GTID debe ser incrementado */
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* modo autoconsigna, transacción en el maestro, el GTID debe ser incrementado */
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* modo autoconsigna, lectura en el esclavo, sin incremento */
if (!($resultado = $mysqli->query("SELECT id FROM test")))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($resultado->fetch_assoc());
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  ["id"]=>
  string(1) "1"
}
]]>
    </screen>
   </example>
  </para>
  <para>
   El ejemplo ejecuta tres sentencias en el modo autoconsigna en el maestro, causando
   tres transacciones en el maestro. Para cada sentencia, el complemento
   inyectará el <literal>UPDATE</literal> configurado de forma transparente antes de ejecutar
   las sentencias SQL del usuario. Cuando finaliza el script, el contador de IDs
   de transacciones globales en el maestro ha sido incrementado en tres.
  </para>
  <para>
   La cuarta sentencia SQL ejecutada en el ejemplo, un <literal>SELECT</literal>,
   no desencadena un incremento. Solamente las transacciones (escrituras) ejecutadas en un maestro
   incrementarán el contador GTID.
  </para>
  <note>
   <title>SQL para el ID de transacciones global: ¡se busca una solución eficiente!</title>
   <para>
    El SQL usado para la emulación del ID de transacciones global es ineficiente.
    Está optimizado para la trasnparencia, no para el rendimiento. No lo use para entornos de
    producción. Por favor, ayude a encontrar una solución eficiente para su inclusión en el manual.
    Apreciamos su aportación.
   </para>
  </note>
  <para>
   <example>
    <title>Configuración del complemento: SQL para obtener el GTID</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Obtener el GTID después de la ejecución</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* modo autoconsigna, transacción en el maestro, el GTID debe ser incrementado */
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID después de la transacción %s\n", mysqlnd_ms_get_last_gtid($mysqli));

/* modo autoconsigna, transacción en el maestro, el GTID debe ser incrementado */
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID después de la transacción %s\n", mysqlnd_ms_get_last_gtid($mysqli));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
GTID después de la transacción 7
GTID después de la transacción 8
]]>
    </screen>
   </example>
  </para>
  <para>
   Las aplicaciones pueden preguntar a PECL mysqlnd_ms por un ID de transacciones global que
   pertenezca a la última operación de escritura realizada por la aplicación.
   La función <function>mysqlnd_ms_get_last_gtid</function> devuelve el
   GTID obtenido cuando se ejecuta la sentencia SQL desde la
   entrada <literal>fetch_last_gtid</literal> de la sección
   <literal>global_transaction_id_injection</literal> del
   fichero de configuración del complemento. La función puede ser invocada
   después de que el GTID haya sido incrementado.
  </para>
  <para>
   Se aconseja que las aplicaciones no ejecuten la sentencia
   SQL por sí mismas ya que aumenta el riesgo de que accidentalmente se ocasione un incremento
   implícito del GTID. También, si se usa la función, es más fácil migrar
   una aplicación desde una sentencia SQL para obtener un ID de transacciones a otra,
   por ejemplo, si ningún servidor MySQL incluye el soporte interno para IDs de transacciones globales.
  </para>
  <para>
   Esta guía rápida muestra una sentencia SQL que devolverá un GTID igual o mayor
   que el creado por la sentencia anterior. Éste es exactamente el GTID creado
   por la sentencia anterior si ningún cliente ha incrementado el GTID en el
   tiempo transcurrido entre la ejecución de la sentencia y el <literal>SELECT</literal>
   para obtener el GTID. De otro modo, será mayor.
  </para>
  <para>
   <example>
    <title>Configuración del complemento: comprobar un GTID en particular</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "check_for_gtid" : "SELECT trx_id FROM test.trx WHERE trx_id >= #GTID",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Nivel de servicio de consistencia de sesión y GTID combinados</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es más agradable... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* modo autoconsigna, transacción en el maestro, el GTID debe ser incrementado */
if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* GTID es un identificador para la última escritura */
$gtid = mysqlnd_ms_get_last_gtid($mysqli);

/* Consistencia de sesión (lectura de sus escrituras): intentar leer de los esclavos, no sólo del maestro */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION, MYSQLND_MS_QOS_OPTION_GTID, $gtid)) {
    die(sprintf("[006] [%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Ejecutar en el maestro o en el esclavo que ha replicado el INSERT */
if (!($resultado = $mysqli->query("SELECT id FROM test"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

var_dump($resultado->fetch_assoc());
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Un GTID devuelto por <function>mysqlnd_ms_get_last_gtid</function>
   se puede usar como una opción para el nivel de servicio de consistencia de sesión.
   La consistencia de sesión proporciona la lectura de sus escrituras. La consistencia de sesión
   puede ser solicitada llamando a
   <function>mysqlnd_ms_set_qos</function>.
   En el ejemplo, el complemento ejecutará la sentencia <literal>SELECT</literal>
   en el maestro o en un esclavo que ya ha repliacdo
   el <literal>INSERT</literal> anterior.
  </para>
  <para>
   PECL mysqlnd_ms comprobará de forma transparente cada esclavo configurado, si
   éste ha replicado el <literal>INSERT</literal>, mediante la comprobación de la tabla
   GTID de esclavos. La comprobación se realiza ejecutando la sentencia SQL establecida con la
   opción <literal>check_for_gtid</literal> de la
   sección <literal>global_transaction_id_injection</literal> del
   fichero de configuración del complemento. Por favor, observe que este es un procedimiento
   lento y caro. Las aplicaciones deberían intentar usarlo poco y únicamente
   si la carga de lectura en el maestro es alta.
  </para>
  <para>
   <emphasis role="bold">Uso de la característica del ID de transacciones global en el lado del servidor</emphasis>
  </para>
  <para>
   Desde MySQL 5.6.5-m8, el sistema de Replicación MySQL introduce los IDs de transacciones
   globales. Los identificadores de transacciones son automáticamente generados  y
   mantenidos por el servidor. Los usuarios no necesitan ocuparse de ellos.
   No hay necesidad de configurar ninguna tabla de antemano, ni de configurar
   <literal>on_commit</literal>. Ya no es necesaria la emulación en el lado del cliente.
  </para>
  <para>
   Los clientes puede seguir usando los identificadores de transacciones globales para conseguir
   la consistencia de sesión al leer desde esclavos de la Replicación MySQL. El algoritmo
   funciona como está descrito arriba. Se deben configurar diferentes sentencias SQL para
   <literal>fetch_last_gtid</literal> y <literal>check_for_gtid</literal>.
   Estas sentencias se proporcionan más abajo. Por favor, observe que MySQL 5.6.5-m8 es una versión en
   desarrollo. Los detalles de la implementación del servidor pueden cambiar en el futuro y requerir
   la adopción de las sentencias SQL mostradas.
  </para>
  <para>
   Al utilizar la siguiente configuración, cualquier funcionalidad descrita arriba puede
   usarse junto con la característica del ID de transacciones global en el lado del servidor.
   <function>mysqlnd_ms_get_last_gtid</function> y <function>mysqlnd_ms_set_qos</function>
   siguen funcionando como se describió arriba. La única diferencia es que el servidor
   no utiliza un número de secuencia simple, sino un string que contiene un identificador del servidor
   y un número de secuencia. Por lo tanto, los usuarios no podrán obtener fáciltmente un orden desde los GTIDs
   devueltos por <function>mysqlnd_ms_get_last_gtid</function>.
  </para>
  <para>
   <example>
    <title>Configuración de complemento: usar la característica del GTID interna de MySQL 5.6.5-m8</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "fetch_last_gtid" : "SELECT @@GLOBAL.GTID_DONE AS trx_id FROM DUAL",
            "check_for_gtid" : "SELECT GTID_SUBSET('#GTID', @@GLOBAL.GTID_DONE) AS trx_id FROM DUAL",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.cache">
  <title>Integración de una caché</title>
  <note>
   <title>Requisitos de versión y dependencias</title>
   <para>
    La integración de una caché está disponible a partir de PECL/mysqlnd_ms 1.3.0-beta (en desarrollo).
    <link linkend="book.mysqlnd-qc">PECL/mysqlnd_qc 1.1.0</link> (en desarrollo)
    o posterior se usa como una caché. Se deben instalar
    ambos complementos. PECL/mysqlnd_ms debe ser compilado para admitir la característica de la caché.
    Es obligatorio usar PHP 5.4.0 o posterior.
   </para>
  </note>
  <para>
   Los clústeres de bases de datos pueden proporcionar diferentes niveles de consistencia. A partir de
   PECL/mysqlnd_ms 1.2.0 es posible acosejar al complemento para que cosidere solamente los
   nodos del clúster que puedan proporcionar el nivel de consistencia requerido. Por ejemplo,
   si se usa la Replicación MySQL con su consistencia final a lo ancho del
   clúster, es posible solicitar la consistencia de sesión (lectura de sus escrituras)
   en cualquier momento usando <function>mysqlnd_ms_set_quos</function>. Por favor, vea también la
   introducción de
   <link linkend="mysqlnd-ms.quickstart.qos-consistency">nivel de servicio y consistencia</link>.
  </para>
  <para>
   <example>
    <title>Resumen: calidad del servicio para solicitar la lectura de sus escrituras</title>
    <programlisting role="php">
     /* Solicitud de consistencia de sesión: lectura de sus escrituras */
     if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
    </programlisting>
   </example>
  </para>
  <para>
   Asumiendo que a PECL/mysqlnd se le ha indicado explícitamente que proporcione un nivel de consistencia
   no mayor que la consistencia final, es posible reemplazar un acceso de lectura de un nodo de
   la base de datos por una caché en el lado del cliente usando el tiempo de vida (TTL) como
   estrategia de invalidación. El nodo de la base de datos y la caché pueden o no servir
   datos actuales, ya que esto es lo que la consistencia final define.
  </para>
  <para>
   El reemplazo de un acceso de lectura de un nodo de la base de datos por un acceso a la caché local
   puede mejorar el redimiento general y disminuir la carga de la base de datos. Si la entrada de la caché
   es reutilizada por otro cliente que no sea el que creó dicha entrada,
   se guaradará un acceso a la base de datos, por lo que se disminuye la carga de la base de datos. Además,
   el rendimiento del sistema se puede mejorar si el cálculo y la entrega
   de una consulta a la base de datos es más baja que un acceso a la caché local.
  </para>
  <para>
   <example>
    <title>Configuración del complemento: sin entradas especiales para la caché</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Almacenar en caché una petición a un servidor</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es mejor... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Explícitamente permite la consistencia final y el almacenamiento en caché (TTL <= 60 segundos) */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Para que este ejemplo funcione, debemos esperar a que el esclavo se ponga al día. Estilo de fuerza bruta. */
$intentos = 0;
do {
  /* comprobar si el esclavo posee la tabla */
  if ($resultado = $mysqli->query("SELECT id FROM test")) {
    break;
  } else if ($mysqli->errno) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
  }
  /* esperar a que el esclavo se ponga al día */
  usleep(200000);
} while ($intentos++ < 10);

/* La consulta ha sido ejecutada en un esclavo, el resultado está en la caché */
assert($resultado);
var_dump($resultado->fetch_assoc());

/* Servido desde la caché */
$resultado = $mysqli->query("SELECT id FROM test");
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   El ejemplo muestra cómo usar la caché. Primero, se ha de establecer
   la calidad del servicio al de consistencia final y permitir explícitamente el almacenamiento en la caché.
   Esto se lleva a cabo llamando a <function>mysqlnd_ms_set_qos</function>.
   Luego, el conjunto de resultados de cada sentencia de solo lectura se almacena en la caché hasta un
   máximo de segundos según lo permitido por <function>mysqlnd_ms_set_qos</function>.
  </para>
  <para>
   El TTL real es menor o igual al valor establecido
   con <function>mysqlnd_ms_set_qos</function>. El valor pasado a la función
   establece la edad máxima (en segundos) de los datos proporcionados. Para calcular
   el valor real del TTL, se comprueba la demora de replicación de un servidor y se resta
   del valor dado. Si, por ejemplo, la edad máxima es de 60 segundos y
   el esclavo notifica una demora de 10 segundos, el TTL resultante es de 50 segundos.
   El TTL se calcula de forma individual para cada consulta de la caché.
  </para>
  <para>
   <example>
    <title>Lectura de sus escrituras y almacenamiento en la caché combinados</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es mejor... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Explícitamente permite la consistencia final y el almacenamiento en caché (TTL <= 60 segundos) */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Para que este ejemplo funcione, debemos esperar a que el esclavo se ponga al día. Estilo de fuerza bruta. */
$intentos = 0;
do {
  /* comprobar si el esclavo posee la tabla */
  if ($resultado = $mysqli->query("SELECT id FROM test")) {
    break;
  } else if ($mysqli->errno) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
  }
  /* esperar a que el esclavo se ponga al día */
  usleep(200000);
} while ($intentos++ < 10);

assert($resultado);

/* La consulta ha sido ejecutada en un esclavo, el resultado está en la caché */
var_dump($resultado->fetch_assoc());

/* Servido desde la caché */
if (!($resultado = $mysqli->query("SELECT id FROM test")))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
var_dump($resultado->fetch_assoc());

/* Actualización en el maestro */
if (!$mysqli->query("UPDATE test SET id = 2"))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Lectura de sus escrituras */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Obtener los últimos datos */
if (!($resultado = $mysqli->query("SELECT id FROM test")))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
var_dump($resultado->fetch_assoc());
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   La calidad del servicio se puede cambiar en cualquier momento para evitar el uso de la caché.
   Si fuera necesario, se podría cambiar para leer sus escrituras (consistencia de sesión). En este caso,
   la caché no se usará y se leerán datos actuales.
  </para>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.failover">
  <title>Tolerancia a fallos</title>
  <para>
   Por omisión, el complemento no intenta la tolerancia a fallos si falla al conectarse a un equipo
   anfitrión. Esto evita los problemas relacionados con el
   <link linkend="mysqlnd-ms.quickstart.connectionpooling">estado de la conexión</link>.
   Se recomienda tratar de forma manual los errores de conexión de una manera similar a una transacción
   fallida. Se debería capturar el error, reconstruir el estado de la conexión y volver a ejecutar la
   consulta tal como se muestra abajo.
  </para>
  <para>
   Si el estado de la conexión no es la cuestión, de forma alternativa se puede habilitar la tolerancia
   a fallos automática y silenciosa. Dependiendo de la configuración, la tolerancia a fallos automática
   y silenciosa se intentará en el maestro antes de emitir un error, o se intentará
   conectar a otros esclavos, dada la consulta permitida para ello, antes de intentar conectarse
   a un maestro.
  </para>
  <para>
   <example>
    <title>Tolerancia a fallos manual, opcional automáticia</title>
    <programlisting role="ini">
<![CDATA[
  {
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "simulate_slave_failure",
                "port": "0"
            },
            "slave_1": {
                "host": "127.0.0.1",
                "port": 3311
            }
        },
       "filters": { "roundrobin": [] }
    }
 }
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Tolerancia a fallos manual</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "nombre_usuario", "contraseña", "base_datos");
if (!$mysqli)
  /* Por supuesto, su manejo de errores es mejor... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

$sql = "SELECT 1 FROM DUAL";

/* el manejo de errores debería realizarse sin tener en cuenta el complemento */
if (!($res = $enlace->query($sql))) {
  /* específico del complemento: comprobar errores de conexión */
  switch ($enlace->errno) {
    case 2002:
    case 2003:
    case 2005:
      printf("Error de conexión - ¡intentando con el siguiente esclavo!\n");
      /* el equilibrador de carga elegirá el siguiente esclavo */
      $res = $enlace->query($sql);
      break;
    default:
      /* no hay errores de conexión, la tolerancia a fallos es poco probable que ayude */
      die(sprintf("SQL error: [%d] %s", $enlace->errno, $enlace->error));
      break;
  }
}
if ($res) {
  var_dump($res->fetch_assoc());
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </section>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
