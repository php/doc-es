<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: a63190d9c474f19bcc54c643fdd7424623e48c38 Maintainer: seros Status: ready -->
<!-- Reviewed: no -->

<phpdoc:classref xml:id="class.sessionhandler" xmlns:phpdoc="http://php.net/ns/phpdoc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude">
 
 <title>La clase SessionHandler</title>
 <titleabbrev>SessionHandler</titleabbrev>
 
 <partintro>
  
  <!-- {{{ SessionHandler intro -->
  <section xml:id="sessionhandler.intro">
   &reftitle.intro;
   <para>
    <classname>SessionHandler</classname> es una clase especial que puede usarse para extender
    el gestor de almacenamiento de sesiones interno actual de PHP usando herencia. Existen seis métodos que
    envuelven las seris llamadas de retorno del gestor de almacenamiento de sesiones. Por defecto PHP usa el gestor
    de almacenamiento <parameter>files</parameter> como está definido por <link linkend="ini.session.save-handler">session.save_handler</link>.
    Otros son proporcionados por extensiones de PHP tales como SQLite (como <parameter>sqlite</parameter>),
    Memcache (como <parameter>memcache</parameter>), y Memcached (como <parameter>Memcached</parameter>).
   </para>
   <para>
    Esta clase se puede extender y sus métodos se pueden sobreescribir por herencia incluyendo
    la capacidad de llamar a los métodos de la clase madre. Esto permite que, por ejemplo, se intercepten los
    métodos <parameter>read</parameter> y <parameter>write</parameter> para encriptar/desencriptar la
    información de sesión y luego pasar el resultado hacia y desde la clase madre.
   </para>
   <para>
    Ya que <classname>SessionHandler</classname> envuelve los métodos del gestor de almacenamiento interno
    actual, el ejemplo de arriba de encriptación puede aplicarse a cualquier gestor de almacenamiento interno sin
    tener que conocer los entresijos de los gestores.
   </para>
   <para>
    Para usar esta clase se ha de pasar una instancia de esta clase o una que la extienda
    a <function>session_set_save_handler</function>. Esto causará que cualquier
    gestor de sesiones nativo (interno) en uso sea envuelto por esta instancia.
   </para>
  </section>
  <!-- }}} -->
  
  <section xml:id="sessionhandler.synopsis">
   &reftitle.classsynopsis;
   
   <!-- {{{ Synopsis -->
   <classsynopsis>
    <ooclass><classname>SessionHandler</classname></ooclass>
    
    <!-- {{{ Class synopsis -->
    <classsynopsisinfo>
     <ooclass>
      <classname>SessionHandler</classname>
     </ooclass>
     
     <oointerface>
      <interfacename>SessionHandlerInterface</interfacename>
     </oointerface>
    </classsynopsisinfo>
    <!-- }}} -->
    
    <classsynopsisinfo role="comment">&Methods;</classsynopsisinfo>
    <xi:include xpointer="xmlns(db=http://docbook.org/ns/docbook) xpointer(id('class.sessionhandler')/db:refentry/db:refsect1[@role='description']/descendant::db:methodsynopsis[1])" />
   </classsynopsis>
   <!-- }}} -->
   
  </section>
  <section xml:id="sessionhandler.examples">
   <example>
    <title>
     Usar <classname>SessionHandler</classname> para añadir encriptación a los gestores de almacenamiento internos de PHP.
    </title>
    <programlisting role="php">
<![CDATA[
<?php
class EncryptedSessionHandler implements SessionHandler
{
    private $key;

    public function __construct($key)
    {
        $this->key = $key
    }

    public function read($id)
    {
        $data = parent::read($id);

        return mycrypt_decrypt(MCRYPT_3DES, $this->key, $data, MCRYPT_MODE_ECB);
    }

    public function write($id, $data)
    {
        $data = mcrypt_encrypt(MCRYPT_3DES, $this->key, $data, MCRYPT_MODE_ECB);

        return parent::write($id, $data);
    }
}

// interceptaremos el gestor nativo 'files', pero funcionaría de igual forma
// con otros gestores nativos interno como 'sqlite', 'memcache' o 'memcached'
// que son proporcionados por extensiones de PHP.
ini_set('session.save_handler', 'files');
$handler = new EncryptedSessionHandler('mykey');
session_set_save_handler($handler, true);
session_start();

// proceder para establecer y recuperar valores por clave desde $_SESSION
]]>
    </programlisting>
   </example>
  </section>
  
 </partintro>
 
 &reference.session.entities.sessionhandler;
 
</phpdoc:classref>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
