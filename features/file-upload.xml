<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 2bb07c8c43f028c665a33bfc08a22639e9e35dc6 Maintainer: seros Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="features.file-upload" xmlns="http://docbook.org/ns/docbook">
 <title>Manejando la carga de archivos</title>
 
 <sect1 xml:id="features.file-upload.post-method">
  <title>Carga con el método POST</title>
  <simpara>
   Esta característica permite que los usuarios envien tanto archivos de texto como binarios.
   Con la autenticación de PHP y las funciones de manipulación de archivos,
   se tiene completo control sobre quién está autorizado a cargar y
   que hay que hacer con el archivo una vez que se ha cargado.
  </simpara>
  <simpara>
   PHP es capaz de recibir cargas de archivos de cualquier
   navegador compatible con RFC-1867.
  </simpara>
  
  <note>
   <title>Configuraciones Relacionadas</title>
   <para>
    Ver también las directivas <link linkend="ini.file-uploads">file_uploads</link>,
    <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
    <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link>,
    <link linkend="ini.post-max-size">post_max_size</link> y
    <link linkend="ini.max-input-time">max_input_time</link>
    en &php.ini;
   </para>
  </note>
  
  <para>
   PHP también soporta el método PUT para la carga como lo utilizan los clientes
   <productname>Netscape Composer</productname> y
   <productname>Amaya</productname> del W3C. Ver el <link
   linkend="features.file-upload.put-method">soporte del
   método PUT</link> para más detalles.
  </para>
  
  <para>
   <example>
    <title>Formulario para la carga de archivos</title>
    <para>
     Una página de carga de archivos puede ser construida mediante la creación de un formulario especial
     el cual se vería algo como esto:
    </para>
    <programlisting role="html">
<![CDATA[
<!-- El tipo de codificación de datos, enctype, se DEBE especificar como a continuación -->
<form enctype="multipart/form-data" action="__URL__" method="POST">
    <!-- MAX_FILE_SIZE debe preceder el campo de entrada de archivo -->
    <input type="hidden" name="MAX_FILE_SIZE" value="30000" />
    <!-- El nombre del elemento de entrada determina el nombre en el array $_FILES -->
    Enviar este archivo: <input name="userfile" type="file" />
    <input type="submit" value="Send File" />
</form>
]]>
    </programlisting>
    <para>
     El <literal>__URL__</literal> en el ejemplo anterior se debe sustituir
     y apuntar a un archivo PHP.
    </para>
    <para>
     El campo oculto <literal>MAX_FILE_SIZE</literal> (medido en bytes) debe
     preceder al campo de entrada de archivo y su valor es el tamaño máximo de archivo aceptado por PHP.
     Este elemento del formulario se debe usar siempre, ya que evita a los usuarios la molestia de
     esperar a que un gran archivo sea transferido sólo para descubrir que era demasiado
     grande y falló la transferencia. Tener en cuenta: engañar a esta configuración en el
     lado del navegador es muy fácil, así que nunca se debe confiar en que archivos con un tamaño mayor
     serán bloqueados por esta característica. Es simplemente una característica de conveniencia para
     los usuarios en el lado cliente de la aplicación. Sin embargo, la configuración de PHP (en el lado del
     servidor) para un máximo de tamaño, no puede ser engañada.
    </para>
   </example>
  </para>
  
  <note>
   <para>
    Asegúrese de que el formulario de subida de archivos tiene el atributo <literal>enctype="multipart/form-data"</literal>
    de lo contrario la carga de archivos no funcionará.
   </para>
  </note>
  
  <para>
   <varname>$_FILES</varname> contendrá toda la información de los los ficheros subidos.
   Su contenido del formulario de ejemplo es el siguiente. Tenga en cuenta que esto asume la utilización del
   nombre del archivo cargado <emphasis>userfile</emphasis>, tal como se utiliza en el script
   de ejemplo anterior. Este puede ser cualquier nombre.
   <variablelist>
    <varlistentry>
     <term><varname>$_FILES['userfile']['name']</varname></term>
     <listitem>
      <para>
       El nombre original del archivo en la máquina cliente.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>$_FILES['userfile']['type']</varname></term>
     <listitem>
      <para>
       El tipo mime del archivo, si el navegador proporciona esta
       información. Un ejemplo podría ser
       <literal>"image/gif"</literal>. Este tipo mime, sin embargo
       no se verifica en el lado de PHP y por lo tanto no se garantiza
       su valor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>$_FILES['userfile']['size']</varname></term>
     <listitem>
      <para>
       El tamaño, en bytes, del archivo subido.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>$_FILES['userfile']['tmp_name']</varname></term>
     <listitem>
      <para>
       El nombre temporal del archivo en el cual se almacena el archivo
       cargado en el servidor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>$_FILES['userfile']['error']</varname></term>
     <listitem>
      <para>
       El <link linkend="features.file-upload.errors">código de error</link>
       asociado a esta carga de archivo.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  
  <para>
   Los archivos, por defecto se almacenan en el directorio temporal por defecto
   del servidor, a menos que otro lugar haya sido dado con la directiva <link
   linkend="ini.upload-tmp-dir">upload_tmp_dir</link> en
   &php.ini;. El directorio por defecto del servidor puede
   ser cambiado mediante el establecimiento de la variable de entorno
   <envar>TMPDIR</envar> en el entorno en el cual se ejecuta PHP.
   Configurarlo usando <function>putenv</function> desde un script PHP
   no funcionará. Esta variable de entorno también se puede utilizar
   para asegurarse de que las demás operaciones están trabajando sobre los archivos
   cargados.
   <example>
    <title>Validación de la carga de archivos</title>
    <para>
     Ver también las entradas para las funciones <function>is_uploaded_file</function>
     y <function>move_uploaded_file</function> para más información. El
     siguiente ejemplo procesaría la carga de archivo que vendría de un formulario.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
// En versiones de PHP anteriores a 4.1.0, $HTTP_POST_FILES debe utilizarse en lugar
// de $_FILES.

$uploaddir = '/var/www/uploads/';
$uploadfile = $uploaddir . basename($_FILES['userfile']['name']);

echo '<pre>';
if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) {
    echo "El archivo es válido y fue cargado exitosamente.\n";
} else {
    echo "¡Posible ataque de carga de archivos!\n";
}

echo 'Aquí hay más información de depurado:';
print_r($_FILES);

print "</pre>";

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   El script PHP que recibe el archivo cargado, debe implementar
   cualquier lógica que sea necesaria para determinar qué se debe hacer
   con el archivo subido. Se puede, por ejemplo, utilizar la
   variable <varname>$_FILES['userfile']['size']</varname>
   para descartar cualquier archivo que sea demasiado pequeño o demasiado grande. Se
   podría utilizar la
   variable <varname>$_FILES['userfile']['type']</varname>
   para descartar cualquier archivo que no corresponda con un cierto criterio de tipo, pero
   usando esto sólo como la primera de una serie de verificaciones, debido a que este valor
   está completamente bajo el control del cliente y no se comprueba en el lado
   de PHP.
   También se puede usar <varname>$_FILES['userfile']['error']</varname>
   y el planear la lógica de acuerdo con los <link
   linkend="features.file-upload.errors">códigos de error</link>.
   Cualquiera que sea la lógica, se debe borrar el archivo del
   directorio temporal o moverlo a otra parte.
  </simpara>
  <simpara>
   Si ningún archivo es seleccionado para realizar la carga en el formulario, PHP devolverá
   <varname>$_FILES['userfile']['size']</varname> como 0, y
   <varname>$_FILES['userfile']['tmp_name']</varname> como ninguno.
  </simpara>
  <simpara>
   El archivo será borrado del directorio temporal al final
   de la solicitud si no se ha movido o renombrado.
  </simpara>
  <example>
   <title>Cargando un array de archivos</title>
   <para>
    PHP soporta las <link linkend="faq.html.arrays">funcionalidades array de HTML</link>
    incluso con archivos.
   </para>
   <programlisting role="html">
<![CDATA[
<form action="" method="post" enctype="multipart/form-data">
<p>Pictures:
<input type="file" name="pictures[]" />
<input type="file" name="pictures[]" />
<input type="file" name="pictures[]" />
<input type="submit" value="Send" />
</p>
</form>
]]>
   </programlisting>
   <programlisting role="php">
<![CDATA[
<?php
foreach ($_FILES["pictures"]["error"] as $key => $error) {
    if ($error == UPLOAD_ERR_OK) {
        $tmp_name = $_FILES["pictures"]["tmp_name"][$key];
        $name = $_FILES["pictures"]["name"][$key];
        move_uploaded_file($tmp_name, "data/$name");
    }
}
?>
]]>
   </programlisting>
  </example>
  <para>
   Una barra de progreso de carga de archivos puede ser implementada mediante <link
   linkend="session.upload-progress">Session Upload Progress</link>.
  </para>
 </sect1>
 
 <sect1 xml:id="features.file-upload.errors">
  <title>Explicación de los mensajes de error</title>
  <simpara>
   PHP devuelve un código de error apropiado, junto con el
   array del archivo. El código de error se puede encontrar en el
   segmento <literal>error</literal> del array del archivo que PHP crea
   durante la subida del archivo. En otras palabras, el error podría
   encontrarse en <varname>$_FILES['userfile']['error']</varname>.
  </simpara>
  <para>
   <variablelist>
    <varlistentry>
     <term><constant>UPLOAD_ERR_OK</constant></term>
     <listitem>
      <para>
       Valor: 0; No hay error, archivo subido con éxito.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><constant>UPLOAD_ERR_INI_SIZE</constant></term>
     <listitem>
      <para>
       Valor: 1; El archivo subido excede la directiva
       <link linkend="ini.upload-max-filesize">upload_max_filesize</link>
       en &php.ini;.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><constant>UPLOAD_ERR_FORM_SIZE</constant></term>
     <listitem>
      <para>
       Valor: 2; El archivo subido excede la directiva <emphasis>MAX_FILE_SIZE</emphasis>
       que fue especificada en el formulario HTML.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><constant>UPLOAD_ERR_PARTIAL</constant></term>
     <listitem>
      <para>
       Valor: 3; El archivo subido fue sólo parcialmente cargado.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><constant>UPLOAD_ERR_NO_FILE</constant></term>
     <listitem>
      <para>
       Valor: 4; Ningún archivo fue subido.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><constant>UPLOAD_ERR_NO_TMP_DIR</constant></term>
     <listitem>
      <para>
       Valor: 6; Falta la carpeta temporal. Introducido en PHP 5.0.3.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><constant>UPLOAD_ERR_CANT_WRITE</constant></term>
     <listitem>
      <para>
       Valor: 7; No se pudo escribir el archivo en el disco. Introducido en PHP 5.1.0.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><constant>UPLOAD_ERR_EXTENSION</constant></term>
     <listitem>
      <para>
       Valor: 8; Una extensión de PHP detuvo la carga de archivos. PHP no
       proporciona una forma de determinar cual extensión causó la parada
       de la subida de archivos; el examen de la lista de extensiones cargadas con <function>phpinfo</function> puede ayudar.
       Introducido en PHP 5.2.0.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect1>
 
 <sect1 xml:id="features.file-upload.common-pitfalls">
  <title>Dificultades comunes</title>
  <simpara>
   El item <literal>MAX_FILE_SIZE</literal> no puede especificar un tamaño de archivo
   mayor que el que ha sido configurado en el <link
   linkend="ini.upload-max-filesize">upload_max_filesize</link> en
   el archivo &php.ini;. Por defecto es 2 megabytes.
  </simpara>
  <simpara>
   Si hay un límite de memoria activado, un <link
   linkend="ini.memory-limit">memory_limit</link> más grande puede ser necesario.
   Asegurarse de configurar un <link linkend="ini.memory-limit">memory_limit</link>
   lo suficientemente grande.
  </simpara>
  <simpara>
   Si el <link linkend="ini.max-execution-time">max_execution_time</link>
   es demasiado pequeño, la ejecución del script puede excederse de este valor. Asegurarse
   de configurar un <literal>max_execution_time</literal> lo suficientemente grande.
  </simpara>
  <note>
   <simpara>
    <link linkend="ini.max-execution-time">max_execution_time</link> sólo
    afecta al plazo de ejecución del propio script. Todo el tiempo gastado
    en actividades que tengan lugar por fuera de la ejecución del script,
    tales como las llamadas al sistema usando <function>system</function>, la
    función <function>sleep</function>, las consultas a base de datos, el tiempo que tarda
    el proceso de subida de archivos, etc., no se incluye cuando se determina el tiempo
    máximo que el script ha estado funcionando.
   </simpara>
  </note>
  <warning>
   <simpara>
    <link linkend="ini.max-input-time">max_input_time</link> establece el tiempo
    máximo, en segundos, al script se le permite recibir información, esto incluye
    la subida de archivos. Para archivos grandes o múltiples, o usuarios con conexiones más lentas,
    el valor predeterminado de <literal>60 segundos</literal> puede ser excedido.
   </simpara>
  </warning>
  <simpara>
   Si <link linkend="ini.post-max-size">post_max_size</link> se establece demasiado
   pequeño, los archivos grandes no pueden ser cargados. Asegurarse de configurar
   <literal>post_max_size</literal> lo suficientemente grande.
  </simpara>
  <simpara>
   A partir de PHP 5.2.12, la
   configuración <link linkend="ini.max-file-uploads">max_file_uploads</link>
   controla el número máximo de archivos que se pueden cargar en una
   petición. Si más archivos que ese límite son subidos, entonces
   <varname>$_FILES</varname> parará de procesar archivos una vez se alcanza
   el límite. Por ejemplo, si
   <link linkend="ini.max-file-uploads">max_file_uploads</link> se establece en
   <literal>10</literal>, entonces <varname>$_FILES</varname> nunca contendrá
   más de 10 elementos.
  </simpara>
  <simpara>
   No validar sobre cual archivo se opera puede significar que los usuarios pueden acceder
   a información sensible en otros directorios.
  </simpara>
  <simpara>
   Por favor tener en cuenta que el <productname>CERN httpd</productname> parece quitar todo
   lo que empieza con primer espacio en blanco en la cabecera de tipo de contenido mime
   que recibe desde el cliente. Mientras este sea el caso, el <productname>CERN httpd</productname>
   no soportará la funcionalidad de carga de archivos.
  </simpara>
  <simpara>
   Debido a la gran cantidad de estilos de lista de directorios, no podemos garantizar
   que los archivos con nombres exóticos (como el que contiene espacios en blanco) se manejen adecuadamente.
  </simpara>
  <simpara>
   Un desarrollador no debe mezclar los campos <literal>input</literal> normales con los de carga de archivos en la misma
   variable de formulario (mediante un nombre de <literal>input</literal> como <literal>foo[]</literal>).
  </simpara>
 </sect1>
 
 <sect1 xml:id="features.file-upload.multiple">
  <title>Subida de múltiples archivos</title>
  <simpara>
   Múltiples archivos pueden ser subidos utilizando diferentes
   <literal>name</literal> para los <literal>input</literal>.
  </simpara>
  <simpara>
   También es posible subir múltiples archivos simultáneamente y
   tener la información organizada automáticamente en arrays. Para
   ello, es necesario utilizar la misma sintaxis de sumisión de array en el
   formulario HTML como se hace con múltiples selects y checkboxes:
  </simpara>
  <para>
   <example>
    <title>Subida de múltiples archivos</title>
    <programlisting role="html">
<![CDATA[
<form action="file-upload.php" method="post" enctype="multipart/form-data">
  Enviar estos archivos:<br />
  <input name="userfile[]" type="file" /><br />
  <input name="userfile[]" type="file" /><br />
  <input type="submit" value="Send files" />
</form>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Cuando el formulario de arriba se remite, los arrays
   <varname>$_FILES['userfile']</varname>,
   <varname>$_FILES['userfile']['name']</varname> y
   <varname>$_FILES['userfile']['size']</varname> serán
   inicializados (así como en <varname>$HTTP_POST_FILES</varname> para las versiones de PHP anteriores
   a 4.1.0).
   Cuando <link linkend="ini.register-globals">register_globals</link> está activado, globales para los archivos subidos
   también se inicializan. Cada uno de estos será un array indexado
   numéricamente de los valores correspondientes a los archivos remitidos.
  </simpara>
  <simpara>
   Por ejemplo, suponga que los nombres de archivo
   <filename>/home/test/review.html</filename> y
   <filename>/home/test/xwp.out</filename> son remitidos. En este
   caso,<varname>$_FILES['userfile']['name'][0]</varname>
   contendría el valor <filename>review.html</filename>, y
   <varname>$_FILES['userfile']['name'][1]</varname> contendría
   el valor <filename>xwp.out</filename>. De manera similar,
   <varname>$_FILES['userfile']['size'][0]</varname> contendría
   el tamaño del archivo <filename>review.html</filename> y así sucesivamente.
  </simpara>
  <simpara>
   <varname>$_FILES['userfile']['name'][0]</varname>,
   <varname>$_FILES['userfile']['tmp_name'][0]</varname>,
   <varname>$_FILES['userfile']['size'][0]</varname>, y
   <varname>$_FILES['userfile']['type'][0]</varname> también
   son establecidos.
  </simpara>
  <warning>
   <simpara>
    A partir de PHP 5.2.12, la
    configuración <link linkend="ini.max-file-uploads">max_file_uploads</link>
    actúa como un límite en el número de archivos que se pueden
    subir en una petición. Se necesita asegurar que el formulario no
    intenta cargar más archivos que este límite en una petición.
   </simpara>
  </warning>
 </sect1>
 
 <sect1 xml:id="features.file-upload.put-method">
  <title>Soporte del método PUT</title>
  <para>
   PHP ofrece soporte para el método HTTP PUT utilizado por algunos clientes para almacenar
   archivos en un servidor.
   Las peticiones PUT son mucho más simples que una carga de archivos mediante solicitudes POST
   y se ven algo como esto:
   <informalexample>
    <programlisting role="HTTP">
<![CDATA[
PUT /path/filename.html HTTP/1.1
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Esto normalmente significa que el cliente remoto quiere guardar
   el contenido que sigue como: <filename>/path/filename.html</filename>  en el árbol web.
   Obviamente no es una buena idea para Apache o PHP dejar automáticamente
   a todo el mundo que pueda sobrescribir cualquier archivo del árbol web. Para manejar
   esta solicitud se debe primero decir al servidor web que se
   desea que cierto script de PHP maneje la petición. En Apache se hace
   esto con la directiva de <emphasis>Script</emphasis>. Se puede
   colocar casi en cualquier parte del archivo de configuración de Apache. Un
   lugar común es dentro de un bloque <literal>&lt;Directory&gt;</literal> o tal vez dentro
   de un bloque <literal>&lt;VirtualHost&gt;</literal>. Una línea como ésta haría el truco:
   <informalexample>
    <programlisting>
<![CDATA[
Script PUT /put.php
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   Esto le dice a Apache que envíe todas peticiones PUT para URIs que coincidan con
   el contexto en el cual se pone esta línea en el script <filename>put.php</filename>. Esto
   asume, por supuesto, que se tiene habilitado PHP para la extensión
   <filename>.php</filename> y que PHP está activo. El recurso de destino para todas las
   solicitudes PUT a este script tiene que ser en propio script, el archivo subido
   no debe tener un nombre de archivo.
  </simpara>
  <simpara>
   Con PHP entonces se haría algo como lo siguiente en
   el put.php. Esto copiaría el contenido del archivo subido al
   archivo <filename>myputfile.ext</filename> en el servidor.
   Es probable que se deseen realizar algunas verificaciones y/o
   autenticar al usuario antes de realizar esta copia de archivo.
  </simpara>
  <para>
   <example>
    <title>Guardando archivos HTTP PUT</title>
    <programlisting role="php">
<![CDATA[
<?php
/* datos PUT vienen en en el flujo de entrada estándar  */
$putdata = fopen("php://input", "r");

/* Abre un archivo para escribir */
$fp = fopen("myputfile.ext", "w");

/* Leer los datos de 1 KB a la vez
   y escribir en el archivo */
while ($data = fread($putdata, 1024))
  fwrite($fp, $data);

/* Cerrar los flujos */
fclose($fp);
fclose($putdata);
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

