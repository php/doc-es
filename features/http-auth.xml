<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 744111cf061120a5e82033a50ca0031902e102d4 Maintainer: seros Status: ready -->
<!-- Reviewed: no -->
 <chapter xml:id="features.http-auth" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Autenticación HTTP con PHP</title>

  <simpara>
   Es posible usar la función <function>header</function>
   para enviar un mensaje <literal>"Authentication Required"</literal> al navegador
   del cliente causando que se abra una ventana para ingresar usuario y password. Una vez
   se ha llenado el usuario y password, la URL contenida dentro del script PHP será llamada
   nuevamente con las <link linkend="reserved.variables">variables predefinidas</link>
   <varname>PHP_AUTH_USER</varname>, <varname>PHP_AUTH_PW</varname>, 
   y <varname>AUTH_TYPE</varname> puestas por el nombre del usuario, password y el
   tipo de autenticación respectivamente. Esas variables predefinidas son encontradas en
   el array <varname>$_SERVER</varname>. Ambos métodos de autenticación "Basic" y "Digest" (desde PHP 5.1.0) son soportados.
   Ver la función <function>header</function> para más información.
  </simpara>

  <para>
   Un fragmento de ejemplo de un script el cual podría forzar la autenticación
   en una página es el siguiente:
  </para>
  <para>
   <example>
    <title>Ejemplo de Autenticación HTTP Basic</title>
    <programlisting role="php">
<![CDATA[
<?php
if (!isset($_SERVER['PHP_AUTH_USER'])) {
    header('WWW-Authenticate: Basic realm="My Realm"');
    header('HTTP/1.0 401 Unauthorized');
    echo 'Texto a enviar si el usuario pulsa el botón Cancelar';
    exit;
} else {
    echo "<p>Hola {$_SERVER['PHP_AUTH_USER']}.</p>";
    echo "<p>Tu ingresaste {$_SERVER['PHP_AUTH_PW']} como tu password.</p>";
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Ejemplo de Autenticación HTTP Digest</title>
    <para>
      Este ejemplo muestra como implementar un script PHP de 
      autenticación Digest. Para más información leer <link
      xlink:href="&url.rfc;2617">RFC 2617</link>.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$realm = 'Area restringida';

//user => password
$users = array('admin' => 'mypass', 'guest' => 'guest');


if (empty($_SERVER['PHP_AUTH_DIGEST'])) {
    header('HTTP/1.1 401 Unauthorized');
    header('WWW-Authenticate: Digest realm="'.$realm.
           '",qop="auth",nonce="'.uniqid().'",opaque="'.md5($realm).'"');

    die('Texto a enviar si el usuario pulsa el botón Cancelar');
}


// analiza la variable PHP_AUTH_DIGEST
if (!($data = http_digest_parse($_SERVER['PHP_AUTH_DIGEST'])) ||
    !isset($users[$data['username']]))
    die('Datos Erroneos!');


// Generando una respuesta valida
$A1 = md5($data['username'] . ':' . $realm . ':' . $users[$data['username']]);
$A2 = md5($_SERVER['REQUEST_METHOD'].':'.$data['uri']);
$valid_response = md5($A1.':'.$data['nonce'].':'.$data['nc'].':'.$data['cnonce'].':'.$data['qop'].':'.$A2);

if ($data['response'] != $valid_response)
    die('Datos Erroneos!');

// ok, usuario & password validos
echo 'Estas logueado como: ' . $data['username'];


// function to parse the http auth header
function http_digest_parse($txt)
{
    // proteger contra datos perdidos
    $needed_parts = array('nonce'=>1, 'nc'=>1, 'cnonce'=>1, 'qop'=>1, 'username'=>1, 'uri'=>1, 'response'=>1);
    $data = array();
    $keys = implode('|', array_keys($needed_parts));

    preg_match_all('@(' . $keys . ')=(?:([\'"])([^\2]+?)\2|([^\s,]+))@', $txt, $matches, PREG_SET_ORDER);

    foreach ($matches as $m) {
        $data[$m[1]] = $m[3] ? $m[3] : $m[4];
        unset($needed_parts[$m[1]]);
    }

    return $needed_parts ? false : $data;
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <title>Nota de Compatibilidad</title>
   <para>
    Hay que ser cuidadoso cuando se programan las líneas del HTTP header. Para garantizar
    la mayor compatibilidad con todos los clientes, la palabra "Basic" debe ser escrita
    con mayúsculas "B", el string real debe ser encerrado en comillas dobles (no simples),
    y exactamente un espacio debe preceder el código <emphasis>401</emphasis> en la línea
    del header <emphasis>HTTP/1.0 401</emphasis>. Los parámetros de autenticación deben ser
    separados por comas como se vió en el ejemplo resumido anterior.
   </para>
  </note>

  <para>
   En lugar de imprimir simplemente <varname>PHP_AUTH_USER</varname>
   y <varname>PHP_AUTH_PW</varname>, como se hizo en el ejemplo anterior,
   se debería chequear el usuario y password para validar.
   Talvez enviando una consulta a una base de datos, o buscando el
   usuario en un archivo dbm.
  </para>

  <para>
   Cuidado con errores con el Internet Explorer. Parece ser muy
   quisquilloso con el orden de los headers. Enviando el header
   <emphasis>WWW-Authenticate</emphasis> antes que el header
   <literal>HTTP/1.0 401</literal> parece ser un truco por ahora.
  </para>

  <simpara>
   Para prevenir que alguien escriba un script
   el cual revele el password para una página que fué autenticada con un
   mecanismo externo tradicional, las variables PHP_AUTH no deberán ser
   colocadas si la autenticación externa esta habilitada para esa página en
   particular y si &safemode; esta habilitado. Independientemente,
   <varname>REMOTE_USER</varname> puede ser usado para identificar al usuario
   autenticado externamente. Así, se podrá usar <varname>$_SERVER['REMOTE_USER']</varname>.
  </simpara>

  <note>
   <title>Nota de configuración</title>
   <para>
    PHP usa la presencia de una directiva <literal>AuthType</literal> para
    determinar si una autenticación externa esta en uso.
   </para>
  </note>

  <simpara>
   Nótese, sin embargo, que lo anterior no impide que alguien quien
   controle una URL no autenticada pueda robar passwords de URL's
   autenticadas en el mismo servidor.
  </simpara>
  <simpara>
   Tanto Netscape Navigator e Internet Explorer borrarán el caché de la ventana
   de autenticación del navegador local después de recibr una respuesta 401.
   Esto puede "desloguear" efectivamente a un usuario, forzandolo a
   reingresar su usuario y password. Algunas personas usan esto para
   "hacer esperar" logueos, o proveer un botón de "deslogueo".
  </simpara>
  <para>
   <example>
    <title>Ejemplo de Autenticación HTTP forzando a un nuevo usuario/password</title>
    <programlisting role="php">
<![CDATA[
<?php
function authenticate() {
    header('WWW-Authenticate: Basic realm="Test Authentication System"');
    header('HTTP/1.0 401 Unauthorized');
    echo "Debes ingresar un login ID y password validos para accesar a este recurso\n";
    exit;
}
 
if (!isset($_SERVER['PHP_AUTH_USER']) ||
    ($_POST['SeenBefore'] == 1 && $_POST['OldAuth'] == $_SERVER['PHP_AUTH_USER'])) {
    authenticate();
} else {
    echo "<p>Bienvenido: " . htmlspecialchars($_SERVER['PHP_AUTH_USER']) . "<br />";
    echo "Anterior: " . htmlspecialchars($_REQUEST['OldAuth']);
    echo "<form action='' method='post'>\n";
    echo "<input type='hidden' name='SeenBefore' value='1' />\n";
    echo "<input type='hidden' name='OldAuth' value=\"" . htmlspecialchars($_SERVER['PHP_AUTH_USER']) . "\" />\n";
    echo "<input type='submit' value='Re Authenticate' />\n";
    echo "</form></p>\n";
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Este comportamiento no es requerido por la autenticación <literal>HTTP Basic</literal>
   estandar, así que se debería depender de esto. Probando con <literal>Lynx</literal>
   mostrará que <literal>Lynx</literal> no limpia las credenciales de autenticación
   con una respuesta 401 del servidor, asi que presionando back y luego forward
   abrirá el recurso nuevamente si estos no han cambiado. Sin embarogo, el usuario 
   puede presionar la tecla <literal>'_'</literal> para limpiar su información de autenticación.
  </simpara>
  <simpara>
   Para hacer funcionar la Autenticación HTTP en un servidor IIS con la versión CGI
   de PHP, se debe editar la configuracion de IIS "<literal>Directory Security</literal>".
   Hacer click en "<literal>Edit</literal>" y solo chequear "<literal>Anonymous Access</literal>",
   todos los demas campos dejarlos sin chequear.
  </simpara>
  <note>
   <title>Nota de IIS:</title>
   <simpara>
    Para que funcione la Autenticación HTTP con IIS, la directiva de PHP
    <link linkend="ini.cgi.rfc2616-headers">cgi.rfc2616_headers</link> debe
    ser configurada a <literal>0</literal> (el valor por defecto).
   </simpara>
  </note>
  <note>
   <para>
    Si <link linkend="ini.safe-mode">safe mode</link> esta habilitado, 
    el uid del script es agregado a la parte del <literal>reino</literal>
    del header <literal>WWW-Authenticate</literal>.
   </para>
  </note>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
