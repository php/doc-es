<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 33040b3b1b95210112f7b3b71f57a1c005de1a3b Maintainer: hcrow Status: ready -->
<!-- Reviewed: no Maintainer: seros -->
<chapter xml:id="features.connection-handling" xmlns="http://docbook.org/ns/docbook">
 <title>Manejo de Conexiones</title>
 
 <para>
  Internamente en PHP se mantiene un estatus de la conexión. Hay 3
  posibles estados:
  <itemizedlist>
   <listitem><simpara>0 - NORMAL</simpara></listitem>
   <listitem><simpara>1 - ABORTED</simpara></listitem>
   <listitem><simpara>2 - TIMEOUT</simpara></listitem>
  </itemizedlist>
 </para>
 
 <simpara>
  Cuando un script en PHP esta ejecutándose normalmente, está activo
  el estado NORMAL. Si el cliente remoto se desconecta, el flag ABORTED
  es activado. Un cliente remoto se desconecta usualmente porque el
  usuario presiona su botón STOP. Si el tiempo limite PHP-imposed (ver
  <function>set_time_limit</function>) es activado, el flag TIMEOUT se
  activa.</simpara>
 
 <simpara>
  Se puede decidir si se desea que un cliente se desconecte o no a causa
  de que se aborte el script. Algunas veces es útil que los scripts se
  ejecuten inclusive si ya no hay un navegador recibiendo la salida.
  El comportamiento por defecto es que el script sea abortado cuando el
  cliente remoto se desconecte. Este comportamiento puede ser establecido
  a través de la directiva ignore_user_abort en &php.ini; así como a través
  de la directiva correspondiente de Apache en &httpd.conf; 
  <literal>php_value ignore_user_abort</literal> o
  con la función <function>ignore_user_abort</function>. Si se decide
  no decirle a PHP que ignore abortar al usuario y el usuario aborta,
  el script terminará. La única excepción es si se tiene registrada una
  función de cierre usando <function>register_shutdown_function</function>.
  Con una función de cierre, cuando el usuario remoto activa el botón STOP,
  la próxima vez que el script intente mostrar algo, PHP detectará que la
  conexión fue abortada y la función de cierre es llamada.
  Esta función de cierre también es llamada al final del script cuando
  termina normalmente, así que para hacer algo diferente en el caso de que
  un cliente se desconecte usar la función <function>connection_aborted</function>.
  Esta función retornará &true; si la conexión fue abortada.</simpara>
 <simpara>
  El script puede ser terminado también por el temporizador incorporado
  en los scripts. El tiempo por defecto es de 30 segundos. Puede ser cambiado
  usando la directiva <option>max_execution_time</option> de &php.ini; o la
  correspondiente directiva <literal>php_value max_execution_time</literal> de Apache &httpd.conf;
  así como con la función <function>set_time_limit</function>.
  Cuando el temporizador expira el script será abortado y así como el caso
  del cliente anterior que se desconecto, si la función de cierre ha sido
  registrada ésta será llamada. Dentro de esta función de cierre se puede
  comprobar para ver si el timeout causa la función de cierre llamando a
  la función <function>connection_status</function>.
  Esta función retornará 2 si el timeout causo la llamada a la función de cierre.
 </simpara>
 
 <simpara>
  Una cosa a notar es que ambos estados ABORTED y TIMEOUT pueden ser
  activados al mismo tiempo. Esto es posible si se le dice a PHP
  que ignore el aborto del usuario. PHP notará de hecho que un
  usuario podría haber roto la conexión, pero el script se mantendrá
  ejecutándose. Si este activa el limite de tiempo será abortado y
  la función de cierre, si existe, será llamada. A este punto, se
  encontrará que <function>connection_status</function> retorna 3.
 </simpara>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
